<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Evan&#39;s Tech Blog</title>
    <link>https://evan-moon.github.io/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    
    <description>글쓰기를 즐기는 우주 덕후 개발자의 블로그입니다. 사소한 생각 정리부터 튜토리얼, 삽질기 정도를 주로 끄적이고 있습니다.</description>
    <pubDate>Sun, 17 Nov 2019 10:57:11 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>TCP가 연결을 생성하고 종료하는 방법, 핸드쉐이크</title>
      <link>https://evan-moon.github.io/2019/11/17/tcp-handshake/</link>
      <guid>https://evan-moon.github.io/2019/11/17/tcp-handshake/</guid>
      <pubDate>Sun, 17 Nov 2019 10:56:06 GMT</pubDate>
      <description>
      
        &lt;p&gt;저번에 작성했던 &lt;a href=&quot;/2019/11/10/header-of-tcp/&quot; title=&quot;TCP의 헤더에는 어떤 정보들이 담겨있는걸까?&quot;&gt;TCP의 헤더에는 어떤 정보들이 담겨있는걸까?&lt;/a&gt; 포스팅에 이어 이번에는 TCP의 핸드쉐이크 과정과 그 속에서 변화하는 TCP 상태에 대해서 한번 알아보려고 한다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>저번에 작성했던 <a href="/2019/11/10/header-of-tcp/" title="TCP의 헤더에는 어떤 정보들이 담겨있는걸까?">TCP의 헤더에는 어떤 정보들이 담겨있는걸까?</a> 포스팅에 이어 이번에는 TCP의 핸드쉐이크 과정과 그 속에서 변화하는 TCP 상태에 대해서 한번 알아보려고 한다.</p><a id="more"></a><p>TCP는 신뢰성있는 연결을 추구하기 때문에 연결을 생성하고 종료하는 순간에도 나름의 신뢰성 확보를 위해 <code>핸드쉐이크(Handshake)</code>라고 하는 특별한 과정을 거치게 된다. TCP를 사용하여 통신을 하는 각 종단은 핸드쉐이크 과정을 통해 어떤 TCP 옵션들을 사용할 지, 패킷의 순서 번호 동기화와 같이 통신에 필요한 몇 가지 정보를 주고 받는다.</p><p>하지만 말로만 설명하면 재미가 없으니, C를 사용하여 직접 간단한 클라이언트와 서버를 작성해보고 이 친구들이 핸드쉐이크 과정에서 주고 받는 패킷을 몰래 엿본 결과물도 조금씩 첨부하려고 한다.</p><h2 id="연결-지향의-의미에-대해서"><a href="#연결-지향의-의미에-대해서" class="headerlink" title="연결 지향의 의미에 대해서"></a>연결 지향의 의미에 대해서</h2><p>핸드쉐이크를 이야기하기에 앞서, TCP가 생성하고 종료하는 <code>연결</code>에 대한 이야기를 먼저 하려고 한다. 아마 TCP에 대해서 공부해보신 분들은 TCP의 대표적인 특징 중 하나인 <code>연결 지향(Connection Oriented)</code>이라는 키워드에 대해서 들어보았을 것이다.</p><p>연결 지향은 말 그대로 연결되어 있는 상태를 지향한다는 의미이다. 사실 <code>연결</code>과 <code>비연결</code>은 네트워크를 공부하다보면 여러 번 마주치게 되는 단어인데, 필자는 개인적으로 이 단어들의 의미가 조금 헷갈렸었다.</p><p>상식적으로 두 기기가 통신을 하려면 케이블이든 뭐든 연결이 되어있어야 할텐데, 굳이 왜 <code>연결 지향</code>과 <code>비연결 지향</code>을 나누어 놓은 것인지 이해가 되지 않았기 때문이다.</p><p>이게 헷갈리는 이유는 <code>물리적인 연결</code>과 <code>논리적인 연결</code>의 차이 때문이다.</p><p>우리가 일반적으로 기기와 다른 기기를 연결했다고 할 때 떠올리는 생각은 컴퓨터와 모니터를 연결하거나, USB와 컴퓨터를 연결하는 등의 상황이다. 즉, 기기 간의 물리적인 연결이다.</p><center><br>  <img src="/2019/11/17/tcp-handshake/physical-connection.png" width="500"><br>  <small>케이블을 사용하여 두 개의 장치를 물리적으로 연결한다</small><br>  <br><br></center><p>반면, 연결 지향이라는 단어에서 사용하고 있는 연결의 의미는 <code>논리적인 연결(Logical Connection)</code>을 의미한다. 이때 당연히 여러 개의 기기가 서로 통신을 하기위해서는 물리적인 연결 또한 동반되어야한다.</p><center><br>  <img src="/2019/11/17/tcp-handshake/logical-connection.png" width="500"><br>  <br><br></center><p>조금 더 쉽게 이야기해보자면, 두 기기가 서로 연결되어 있는 상태를 유지하는 것이다.</p><p>전화를 예로 들자면, 전화가 전화선에 연결되어있는 것이 물리적인 연결이고 실제로 다른 전화와 통화를 하고 있는 상황이 논리적인 연결, 즉 <code>연결되어 있는 상태</code>인 것이다.</p><p>그렇다면 왜 TCP는 이런 연결 상태를 유지하는 걸까? 그 이유는 간단하다. 바로 <code>연속적인 데이터 전송의 신뢰성</code>을 위해서이다.</p><p>기본적으로 TCP는 패킷 전송 방식을 사용하기 때문에 보내려고 하는 데이터를 여러 개의 패킷으로 쪼개서 보낸다. 이때 네트워크를 통해 모든 데이터를 한번에 팍! 보내는 것이 아니라 일정 단위로 묶어서 스트림처럼 상대방에게 흘려보내게 된다.</p><p>그럼 한번 데이터를 받는 수신자 입장에서 생각해보자. 패킷 전송 방식의 장점 중 하나는 회선을 점유하지 않고 적은 양의 회선으로도 동시에 통신을 할 수 있다는 점이다.</p><p>그렇다는 것은 각 종단이 동시다발적으로 여러 기기들과 패킷을 주고 받고 있다는 의미인데, 이때 <code>누가 보낸 몇 번째 패킷</code>이라는 정보가 없다면 수신 측은 굉장히 혼란스러울 것이다.</p><center><br>  <img src="/2019/11/17/tcp-handshake/pipes.png" width="500"><br>  <small>연결 상태가 없는 패킷을 구분한다는 것은 한 양동이에 담긴 물을 구분하고 싶다는 말과 같다</small><br>  <br><br></center><p>위 그림에서 파이프는 물리적인 연결, 각 파이프의 종단은 포트, 양동이는 패킷을 처리할 프로세스를 의미한다. 이때 연결 상태에 대한 구분을 하지 않고 패킷을 구분하고 싶다는 것은 마치 한 양동이에 담긴 물 중에서 어떤 한 파이프 구멍에서 나온 물 만을 구분해내고 싶다는 말과 비슷하다.</p><p>그렇기 때문에 TCP는 <code>A와 B의 연결 상태</code>, <code>A와 C의 연결 상태</code> 등 각 기기간의 연결 상태를 따로 구분하고 있는 것이다. 이때 TCP는 상대방과 연결 상태를 만들거나 해제하기 위해 특별한 과정을 거치는데, 이 과정을 <code>핸드쉐이크(Handshake)</code>라고 한다.</p><h2 id="3-Way-Handshake"><a href="#3-Way-Handshake" class="headerlink" title="3 Way Handshake"></a>3 Way Handshake</h2><p>먼저, 연결을 만드는 과정부터 살펴보도록 하자. 연결을 생성할 때 거치는 핸드쉐이크 과정을 <code>3 Way Handshake</code>라고 하는데, 3 Way라는 말 그대로 총 3번의 통신 과정을 거친다.</p><p>이 과정을 거치면서 통신을 하는 양 종단은 내가 누구랑 통신하고 있는지, 내가 받아야할 데이터의 시퀀스 번호가 몇 번인지와 같은 정보를 주고 받으면서 연결 상태를 생성하게 된다.</p><center><br>  <img src="/2019/11/17/tcp-handshake/3way-handshake.png" width="400"><br>  <br><br></center><p>이때 <code>요청자(Initiator)</code>는 연결 생성 요청을 먼저 보낸 쪽, <code>수신자(Receiver)</code>는 연결 생성 요청을 받은 쪽을 의미한다. 이렇게 표현하는 이유는 일반적으로 우리가 생각하는 클라이언트와 서버, 둘 중에 어느 쪽이든 자유롭게 먼저 연결 생성 요청을 보낼 수 있기 때문이다.</p><p>그럼 한 번 각각의 상태가 어떤 것을 의미하는지, 두 기기가 서로 주고 받고 있는 <code>SYN</code>과 <code>ACK</code>는 무엇을 의미하는지 살펴보도록 하자.</p><h3 id="CLOSED"><a href="#CLOSED" class="headerlink" title="CLOSED"></a>CLOSED</h3><center><br>  <img src="/2019/11/17/tcp-handshake/3way-closed.png" width="400"><br>  <br><br></center><p>아직 연결 요청을 시작하지 않았기 때문에 아무런 연결도 없는 상태이다.</p><h3 id="LISTEN"><a href="#LISTEN" class="headerlink" title="LISTEN"></a>LISTEN</h3><center><br>  <img src="/2019/11/17/tcp-handshake/3way-listen.png" width="400"><br>  <br><br></center><p>수신자가 요청자의 연결 요청을 기다리고 있는 상태이다.</p><p>이후 요청자가 연결 요청을 보내기 전까지 수신자는 계속 이 상태로 대기하게 된다. 즉, 적극적으로 상대방에게 대시하지 않는다는 것인데, 그래서 이 상태를 <code>수동 개방(Passive Open)</code>이라 하고, 수신자를 <code>Passive Opener</code>라고도 한다.</p><p>소켓 프로그래밍을 할 때, 소켓 바인딩을 한 후 <code>listen</code> 함수를 호출하게 되면 수신자가 LISTEN 상태로 들어가게 된다.</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> ((listen(sockfd, <span class="hljs-number">5</span>)) != <span class="hljs-number">0</span>) &#123;</span><br><span class="line">  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Listen failed...\n"</span>);</span><br><span class="line">  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span></span><br><span class="line">  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Server listening..\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이후 수신자는 요청자의 연결 요청이 확인되면 <code>accept</code> 함수를 호출하여 다음 단계로 넘어가게 된다.</p><h3 id="SYN-SENT"><a href="#SYN-SENT" class="headerlink" title="SYN_SENT"></a>SYN_SENT</h3><center><br>  <img src="/2019/11/17/tcp-handshake/3way-synsent.png" width="400"><br>  <br><br></center><p>요청자가 수신자에게 연결 요청을 하면서 랜덤한 숫자인 <code>시퀀스 번호</code>를 생성해서 SYN 패킷에 담아 보낸 상태이다. 이제 요청자와 수신자는 이 시퀀스 번호를 사용하여 계속 새로운 값을 만들고 서로 확인하며 연결 상태와 패킷의 순서를 확인하게 된다.</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost.initiator &gt; localhost.receiver: Flags [S], seq 3414207244, win 65535</span><br></pre></td></tr></table></figure><p>TCP 세그먼트를 캡쳐할 수 있는 <code>tcpdump</code> 유틸리티로 이 과정을 확인해보면 요청자가 패킷의 플래그를 SYN 패킷을 의미하는 <code>S</code>로 설정하고 시퀀스 번호로 <code>3414207244</code>라는 값을 생성해서 수신자에게 보내고 있음을 알 수 있다.</p><p>이 경우는 요청자가 수신자에게 연결을 생성하자고 적극적으로 대시하는 상황이므로 이 상태를 <code>능동 개방(Active Open)</code>이라고 하고, 요청자를 <code>Active Opener</code>라고도 한다.</p><h3 id="SYN-RECV"><a href="#SYN-RECV" class="headerlink" title="SYN_RECV"></a>SYN_RECV</h3><center><br>  <img src="/2019/11/17/tcp-handshake/3way-synrecv.png" width="400"><br>  <br><br></center><p><code>SYN_RECV</code>는 요청자가 보낸 SYN 패킷을 수신자가 제대로 받은 상태를 의미한다.</p><p>이후 수신자는 제대로 된 시퀀스 번호를 받았다는 확인의 의미인 <code>승인 번호(Acknowledgement)</code> 값을 만들어서 다시 요청자에게 돌려줘야한다. 이때 승인 번호는 처음 <code>요청자가 보낸 시퀀스 번호 + 1</code>이 된다.</p><p>방금 전과 마찬가지로 tcpdump 유틸리티를 사용하여 이 과정을 확인해볼 수 있다.</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost.receiver &gt; localhost.initiator: Flags [S.], seq 435597555, ack 3414207245, win 65535</span><br></pre></td></tr></table></figure><p>수신자가 요청자에게 보내는 패킷을 캡처해보았더니 패킷의 플래그가 <code>S.</code>로 설정되어있다. 이때 <code>.</code>가 의미하는 것은 헤더의 <code>ACK</code> 플래그 필드가 1이라는 것이므로 이 패킷에는 유효한 승인 번호가 담겨있음을 알 수 있다.</p><p>수신자는 이번 통신을 통해 요청자에게 <code>3414207245</code> 이라는 승인 번호를 전달하고 있는데, 이 값은 방금 전 요청자가 보냈던 시퀀스 번호인 <code>3414207244</code>에 1을 더한 값이다.</p><p>또한 랜덤한 수로 자신의 시퀀스 번호인 <code>435597555</code>를 다시 생성하여 함께 요청자에게 보내주고 있는 것을 확인할 수 있다.</p><h3 id="ESTABLISHED-요청자"><a href="#ESTABLISHED-요청자" class="headerlink" title="ESTABLISHED(요청자)"></a>ESTABLISHED(요청자)</h3><center><br>  <img src="/2019/11/17/tcp-handshake/3way-established-client.png" width="400"><br>  <br><br></center><p>요청자는 자신이 맨 처음에 보냈던 시퀀스 번호와 수신자가 응답으로 보내준 승인 번호, 즉 <code>내 시퀀스 번호 + 1</code>를 사용하여 연결이 제대로 성립되었는지 확인할 수 있다. 자신이 보냈던 시퀀스 번호와 이번에 받은 승인 번호의 차가 1이라면 제대로 연결이 되었다고 판단하는 것이다.</p><p>이후 요청자는 연결이 성립되었다고 판단하고 <code>ESTABLISHED</code> 상태로 들어가면서, 이번에는 수신자가 새롭게 만들어서 보내줬던 시퀀스 번호에 1을 더한 값을 다시 승인 번호로 사용하여 다시 수신자에게 보내준다.</p><p>즉, 마지막으로 수신자가 보내줬던 시퀀스 번호인 <code>435597555</code>에 1을 더한 값인 <code>435597556</code>이 요청자의 승인 번호가 될 것이다…만 tcpdump의 동작은 필자의 예상과 달랐다.</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost.initiator &gt; localhost.receiver: Flags [.], ack 1, win 6379</span><br></pre></td></tr></table></figure><center><br>  <img src="/2019/11/17/tcp-handshake/why.jpg" width="500"><br>  <small>왜 1이 거기서 나와…?</small><br>  <br><br></center><p>원래대로라면 <code>435597556</code>이 되어야할 요청자의 마지막 승인 번호가 뜬금없이 <code>1</code>이 되었다. <small>(처음엔 진심 당황했다)</small></p><p>사실 이건 TCP의 자체 동작은 아니고 tcpdump가 제공하는 기능이다. tcpdump가 패킷들의 시퀀스 번호를 알아보기 쉽게끔 <code>상대적인 위치</code>로 알려주기 때문이다. 이후 이 두 종단이 주고 받는 데이터를 tcpdump로 캡처해보면 이게 무슨 말인지 조금 더 쉽게 알 수 있다.</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost.initiator &gt; localhost.receiver: Flags [P.], seq 1:81, ack 1, win 6379, length 80: HTTP</span><br></pre></td></tr></table></figure><p>원래대로라면 요청자가 마지막으로 보내는 승인 번호는 <code>435597556</code>이 될 것이기 때문에 첫 번째로 전송하는 데이터의 시퀀스 번호의 범위 또한 <code>435597556:435597637</code>로 출력되어야한다.</p><p>그러나 인간이 이렇게 큰 숫자를 계속 보면서 분석하기는 쉽지 않기 때문에 승인 번호를 <code>1</code>로 보여주고, 이후 주고받는 첫 번째 시퀀스 번호를 1부터 시작해서 알아보기 쉽게 만들어주는 것이다. 확실히 <code>435597556:435597637</code>보다는 <code>1:81</code>이 알아보기 쉽다.</p><p>하지만 이건 인간이 알아보기 쉽게 tcpdump가 친절함을 베푼 것일뿐 실제로 값이 1로 변경된 것은 아니기 때문에 tcpdump의 <code>-S</code> 옵션을 사용하여 이 기능을 비활성화하면 원래 승인 번호와 시퀀스 번호를 그대로 출력할 수도 있다.</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tcpdump -S</span><br><span class="line">localhost.initiator &gt; localhost.receiver: Flags [.], ack 435597556, win 6379</span><br></pre></td></tr></table></figure><h3 id="ESTABLISHED-수신자"><a href="#ESTABLISHED-수신자" class="headerlink" title="ESTABLISHED(수신자)"></a>ESTABLISHED(수신자)</h3><center><br>  <img src="/2019/11/17/tcp-handshake/3way-established-server.png" width="400"><br>  <br><br></center><p>수신자는 자신이 만들어서 보냈던 시퀀스 번호만 알고 있는 상황이다. 요청자와 마찬가지로 수신자 또한 자신이 보냈던 시퀀스 번호와 이번에 받은 승인 번호의 차가 1이라면 제대로 연결이 되었다고 판단하고 <code>ESTABLISHED</code> 상태로 들어가게된다.</p><p>여기까지 오면 요청자와 수신자는 안전하고 신뢰성있는 연결이 생성되었다고 판단하고 본격적인 통신을 시작할 수 있다.</p><h2 id="4-Way-Handshake"><a href="#4-Way-Handshake" class="headerlink" title="4 Way Handshake"></a>4 Way Handshake</h2><p>연결을 생성할 때와 마찬가지로, 연결을 종료할 때도 특정한 과정을 거쳐서 연결을 종료해야한다.</p><p>그냥 연결을 끊어버리면 안되냐고 할 수도 있지만, 한 쪽에서 일방적으로 연결을 끊어버리면 다른 한 쪽은 연결이 끊어졌는지 지속되고 있는지 알 방법이 없다.</p><p>또한 연결을 종료하기 전에 아직 다 처리하지 못한 데이터가 있을 수도 있기 때문에 양 쪽이 다 정상적으로 연결을 종료할 준비가 되었는 지를 확인하는 과정이 필요한 것이다.</p><p>이때 요청자와 수신자가 총 4번의 통신 과정을 거치기 때문에, 이 과정을 <code>4 Way Handshake</code>라고 부른다.</p><center><br>  <img src="/2019/11/17/tcp-handshake/4way-handshake.png" width="400"><br>  <br><br></center><p>이번에도 <code>요청자(Initiator)</code>와 <code>수신자(Receiver)</code>라는 용어를 사용하고 있는데, 3 Way Handshake와 마찬가지로 클라이언트와 서버, 둘 중에 어느 쪽이든 연결 종료 요청을 시작할 수 있기 때문에 이런 용어를 사용하는 것이다.</p><p>먼저 연결 생성 요청을 했던 쪽이 먼저 연결 종료 요청을 보낼 수도 있고, 반대로 처음에는 연결 생성 요청을 당했던 쪽이 이번에는 먼저 연결 종료 요청을 보낼 수도 있다.</p><p>사실 개발자들은 3 Way Handshake보다 연결을 종료하는 과정인 4 Way Handshake에 더 예민하게 반응할 수 밖에 없는데, 연결을 생성하는 과정에서 문제가 발생하여 연결이 생성되지 않는다면 다시 시도하면 그만이지만, 이미 생성된 연결을 종료하는 과정인 4 Way Handshake에서 문제가 발생하면 그대로 연결이 남아있기 때문이다.</p><p>게다가 4 Way Handshake는 3 Way Handshake처럼 순차적으로 주고받는 방식이 아니라 일방적으로 한 쪽이 기다리고만 있어야하는 과정이 포함되어있기 때문에 중간에 뭐 하나 엇나가면 이 상태로 계속 대기만 하고 있는 <code>데드락(Deadlock)</code> 상황이 연출될 수도 있다.</p><p>물론 조건에 따라 일정 시간이 지나면 타임아웃이 되며 연결을 강제로 종료하기는 하지만 그래도 그 시간 동안 프로세스가 메모리와 포트를 점유하고 있으므로 트래픽이 많은 서버라면 이로 인해 병목이 발생할 가능성이 생긴다.</p><h3 id="FIN-WAIT-1"><a href="#FIN-WAIT-1" class="headerlink" title="FIN_WAIT_1"></a>FIN_WAIT_1</h3><center><br>  <img src="/2019/11/17/tcp-handshake/4way-finwait1.png" width="400"><br>  <br><br></center><p>먼저 연결을 종료하고자 하는 요청자가 FIN 패킷을 상대방에게 보내면서 <code>FIN_WAIT1</code> 상태로 들어서게 된다. 이때 FIN 패킷에는 랜덤한 수로 생성된 <code>시퀀스 번호</code>를 담아서 보낸다.</p><p>이 패킷의 의미를 쉽게 얘기해보자면 “나 더 이상 할 말 없음” 정도이다. 이때 요청자가 먼저 적극적으로 연결 종료 요청을 보내는 것이기 때문에 요청자를 <code>Active Closer</code>, 이 상태를 <code>능동 폐쇄(Active Close)</code>라고 한다.</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost.initiator &gt; localhost.receiver: Flags [F.], seq 701384376, ack 4101704148, win 6378</span><br></pre></td></tr></table></figure><p>하지만 tcpdump를 사용해서 요청자가 수신자에게 보낸 연결 종료 요청 패킷을 보면 <code>F</code> 플래그가 아니라 <code>FIN+ACK</code>를 의미하는 <code>F.</code> 플래그가 설정되어있다.</p><p>이 FIN 패킷에 묻어서 같이 보내지고 있는 승인 번호는 뭘 의미하는 걸까?</p><h4 id="Half-Close-기법"><a href="#Half-Close-기법" class="headerlink" title="Half-Close 기법"></a>Half-Close 기법</h4><p>그 이유는 사실 필자가 예제 TCP 어플리케이션을 작성할 때 연결을 종료하는 함수로 <code>close()</code> 함수가 아니라 <code>shutdown()</code> 함수를 사용했기 때문이다.</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown(sockfd, SHUT_WR);</span><br></pre></td></tr></table></figure><p><code>shutdown()</code> 함수는 <code>Half-Close</code>라는 기법을 지원하는데, 말 그대로 연결을 완전 종료하는 것이 아니라 반만 닫는 것이다.</p><p><code>Half-Close</code>를 사용하면 요청자가 처음 보내는 FIN 패킷에 승인 번호를 함께 담아서 보내게 되는데, 이때 이 승인 번호의 의미는 “일단 연결은 종료할 건데 귀는 열어둔다. 이 승인 번호까지 처리했으니까 마저 보낼 거 있으면 보내”라는 의미가 된다.</p><p>만약 요청자가  <code>close()</code> 함수를 사용하면 호출 즉시 OS에게 소켓의 리소스를 반환하며 모든 스트림이 파기되므로 FIN 패킷을 받은 수신자가 미처 못 보낸 데이터를 뒤늦게 전송하더라도 더 이상 처리할 수 없는 상황이 된다.</p><p>즉, 반만 닫겠다는 말의 의미는 전송 스트림과 수신 스트림 중 하나만 닫겠다는 것을 의미하고, 필자는 <code>SHUT_WR</code> 값을 두 번째 인자로 사용함으로써 전송 스트림만 우선 닫겠다고 선언한 것이다.</p><p>이후 수신자는 미처 못 보낸 데이터가 있다면 열심히 보낼 것이고, 이에 요청자는 아직 살아있는 수신 스트림을 사용하여 데이터를 처리한 후 <code>ACK</code> 패킷을 응답으로 보낼 수 있다. 이후 수신자가 모든 데이터를 처리하고나면 다시 요청자에게 FIN 패킷을 보냄으로써 모든 데이터가 처리되었다는 신호를 보내는 것이다.</p><p>이와 관련된 더 자세한 정보는 구글에 <code>Half-Close</code>나 <code>우아한 종료</code> 등의 키워드로 검색하면 많은 자료가 나오니 한번 살펴보도록 하자.</p><h3 id="CLOSE-WAIT"><a href="#CLOSE-WAIT" class="headerlink" title="CLOSE_WAIT"></a>CLOSE_WAIT</h3><center><br>  <img src="/2019/11/17/tcp-handshake/4way-closewait.png" width="400"><br>  <br><br></center><p>요청자으로부터 FIN 패킷을 받은 수신자는 <code>요청자가 보낸 시퀀스 번호 + 1</code>로 승인 번호를 만들어서 다시 요청자에게 응답해주면서 <code>CLOSE_WAIT</code> 상태로 들어간다.</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost.receiver &gt; localhost.initiator: Flags [.], ack 701384377, win 6378</span><br></pre></td></tr></table></figure><p>아까 요청자가 FIN 패킷의 시퀀스 번호로 <code>701384376</code>을 보냈으니 이번에 수신자가 응답해줄 승인 번호는 <code>701384377</code>이 되는 것이다.</p><p>이후 수신자는 자신이 전송할 데이터가 남아있다면 이어서 계속 전송한 후, 모든 전송이 끝났다면 명시적으로 <code>close()</code>나 <code>shutdown()</code>과 같은 함수를 호출하여 다음 단계로 넘어갈 것이다.</p><p>즉, 요청자는 언제 수신자의 데이터 처리가 끝날지 모르는 상태이기 때문에 수신자가 작업을 마치고 다시 연결 종료 승인을 의미하는 FIN 패킷을 보내줄 때까지 대기해야한다는 말이 된다.</p><p>만약 이 단계에서 수신자의 데이터 처리가 끝나도 연결 종료 함수가 명시적으로 호출되지 않으면 다음 상태로 넘어갈 수 없기 때문에 데드락이 발생할 가능성이 있다.</p><center><br>  <img src="/2019/11/17/tcp-handshake/deadlock.png" width="500"><br>  <small>구글의 자동 완성 검색어가 개발자들의 심정을 대변해주고 있다</small><br>  <br><br></center><p>이때 수신자는 상대방으로부터 연결 종료 요청을 받은 후에야 수동적으로 연결을 종료할 준비를 하기 때문에 수신자를 <code>Passive Closer</code>, 이 상태를 <code>수동 폐쇄(Passive Close)</code>라고 한다.</p><h3 id="FIN-WAIT-2"><a href="#FIN-WAIT-2" class="headerlink" title="FIN_WAIT_2"></a>FIN_WAIT_2</h3><center><br>  <img src="/2019/11/17/tcp-handshake/4way-finwait2.png" width="400"><br>  <br><br></center><p>요청자는 수신자로부터 승인 번호를 받고 자신이 보냈던 시퀀스 번호와 승인 번호의 차가 1이 맞는지 확인한다. 하지만 아직 수신자의 데이터 전송이 전부 끝나지 않았을 수도 있기에 <code>FIN_WAIT2</code> 상태로 들어가서 수신자가 연결 종료를 허락하는 <code>FIN</code> 패킷을 보내줄 때까지 기다린다.</p><p>방금 CLOSE_WAIT 섹션에서 설명했듯이 여기서부터는 수신자가 다시 FIN 패킷을 보내줄 때까지 요청자는 계속 대기하는 시간이다.</p><p>하지만 CLOSE_WAIT와 다르게 무한정 대기만 하는 것은 아니고 커널 파라미터로 타임아웃이 정해져있는 경우, 일정 시간이 경과하면 자동으로 다음 단계로 넘어갈 수 있다.</p><h3 id="LAST-ACK"><a href="#LAST-ACK" class="headerlink" title="LAST_ACK"></a>LAST_ACK</h3><center><br>  <img src="/2019/11/17/tcp-handshake/4way-lastack.png" width="400"><br>  <br><br></center><p>수신자는 자신이 처리할 데이터가 더 이상 없다면 연결을 종료하는 함수를 명시적으로 호출하고, 아까 요청자가 보냈던 연결 종료 요청에 합의한다는 의미로 요청자에게 다시 <code>FIN</code> 패킷을 보낸다.</p><p>이때 수신자가 보내는 FIN 패킷에 담기는 시퀀스 넘버는 역시 랜덤한 값으로 생성하며, 승인 번호는 마지막으로 자신이 응답했던 승인 번호를 그대로 사용한다.</p><p>이후 수신자는 <code>LAST_ACK</code> 상태로 들어가며 요청자가 다시 승인 번호를 보내줄 때까지 대기한다.</p><h3 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h3><center><br>  <img src="/2019/11/17/tcp-handshake/4way-timewait.png" width="400"><br>  <br><br></center><p>수신자가 보낸 FIN 패킷을 받은 요청자는 다시 <code>수신자가 보낸 시퀀스 번호 + 1</code>로 승인 번호를 생성하여 수신자에게 ACK 패킷으로 응답한다. 이후 요청자는 <code>TIME_WAIT</code> 상태로 들어가며, 실질적인 연결 종료 과정에 들어가게 된다. 이때 TIME_WAIT의 역할은 의도하지 않은 에러로 인해 연결이 데드락에 빠지는 것을 방지하는 것이다.</p><p>TIME_WAIT에서 대기하는 시간은 <code>2 MSL(Maximum Segement Lifetime)</code>으로 정의되어 있으며, 정확한 MSL의 시간 값은 커널 파라미터로 정의되어있다.</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl net.inet.tcp | grep msl</span><br><span class="line">net.inet.tcp.msl: 15000</span><br></pre></td></tr></table></figure><p>필자의 컴퓨터인 OSX의 MSL은 15초로 설정되어있다. 즉, 필자의 컴퓨터는 TIME_WAIT 상태에서 30초 정도 대기한다는 것이다. 참고로 이 값은 변경할 수 없기 때문에 TIME_WAIT에서 소비되는 시간은 변경할 수 없다.</p><p>보통 TCP 타임아웃 파라미터로 많이 언급되는 <code>net.ipv4.tcp_fin_timeout</code>은 FIN_WAIT2의 타임아웃을 조절할 수 있는 값이라 TIME_WAIT 상태에는 해당 사항이 없다.</p><p>하지만 CLOSE_WAIT와 마찬가지로 여기서도 데드락이 발생할 수 있다. 그런 이유로 많은 네트워크 엔지니어들이 여기서 소비되는 시간을 줄이거나 운 나쁘게 발생한 데드락을 없애기 위해 <code>tcp_tw_reuse</code> 커널 파라미터를 변경하는 등 여러가지 방법을 사용하고 있다. <small>(데드락 피하자고 만든 상태인데 데드락이 발생하는 현실)</small></p><p>하지만 역시 그냥 가만 냅두는 게 제일 좋다고들 한다.</p><h3 id="CLOSED-수신자"><a href="#CLOSED-수신자" class="headerlink" title="CLOSED(수신자)"></a>CLOSED(수신자)</h3><center><br>  <img src="/2019/11/17/tcp-handshake/4way-closed-server.png" width="400"><br>  <br><br></center><p>요청자가 보낸 ACK 패킷을 받은 수신자는 <code>CLOSED</code> 상태로 들어가며 연결을 완전히 종료한다.</p><h3 id="CLOSED-요청자"><a href="#CLOSED-요청자" class="headerlink" title="CLOSED(요청자)"></a>CLOSED(요청자)</h3><center><br>  <img src="/2019/11/17/tcp-handshake/4way-closed-client.png" width="400"><br>  <br><br></center><p><code>TIME_WAIT</code> 상태에서 2 MSL만큼 시간이 지나면 요청자도 <code>CLOSED</code> 상태로 변경된다. 위에서 설명했듯이 이 시간은 커널 파라미터에 고정되어 있고, 필자가 사용하고 있는 OSX의 경우 30초 정도이다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>이렇게 두 번째 TCP 주제인 핸드쉐이크에 대한 포스팅을 마쳤다. TCP에 대해서 학교에서 배우긴 했지만 이렇게 각 상태에 대해서 자세히 공부하진 않았기 때문에 나름 새로운 경험이었다.</p><p>이 포스팅을 작성하면서 TCP가 단순히 연결을 생성하고 종료하는데만 해도 신뢰성을 확보하기 위해 얼마나 많은 작업을 하는지 알 수 있었다. <small>(더불어 구글이 왜 HTTP/3에 UDP를 사용했는지 알 것 같았다…)</small></p><p>처음에는 필자 블로그 로컬 서버와 브라우저의 핸드쉐이크를 캡처해보려고 했는데, 이 친구들은 단순한 몇 개의 메세지를 주고 받는 수준이 아니라 대량의 데이터를 주고 받는 사이다보니 필자가 원하는 부분을 추적하기가 쉽지 않았다.</p><p>그래서 오랜만에 간단한 소켓 프로그래밍을 하게 되었는데, 음… 하도 오랜만에 C를 사용하다보니 손에 안 익어서 꽤나 고생하긴 했지만 나름 재미있었다. C는 역시 가끔 해야 재밌는 것 같다.</p><p>혹시 필자가 예제로 사용한 어플리케이션을 직접 실행해보고 싶으신 분은 필자의 <a href="https://github.com/evan-moon/simple-tcp-example" rel="external nofollow noopener noreferrer" target="_blank">깃허브 레파지토리</a>에서 클론 받을 수 있다. 간단한 메세지만 서로 주고 받는 어플리케이션이니 <code>tcpdump</code>를 사용해서 패킷을 들여다보기도 한결 편할 것이다.</p><p>이상으로 TCP가 연결을 생성하고 종료하는 방법, 핸드쉐이크 포스팅을 마친다.</p>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/11/17/tcp-handshake/#disqus_thread</comments>
    </item>
    
    <item>
      <title>불안한 마음 정면으로 마주보기</title>
      <link>https://evan-moon.github.io/2019/11/16/the-way-to-control-anxiety/</link>
      <guid>https://evan-moon.github.io/2019/11/16/the-way-to-control-anxiety/</guid>
      <pubDate>Sat, 16 Nov 2019 08:17:57 GMT</pubDate>
      <description>
      
        &lt;p&gt;지난 달, 다니고 싶었던 회사의 면접에서 기초 실력 부족으로 시원하게 박살났다. 다행히 면접이 끝난 직후 필자가 대답하지 못했던, 풀어내지 못했던 질문들과 문제를 깃허브에 정리해두었기 때문에 어떤 것을 공부해야하는지 바로 알 수 있었고, 한 달동안 컴퓨터 사이언스의 기초에 대한 내용을 집요하게 파헤쳤다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>지난 달, 다니고 싶었던 회사의 면접에서 기초 실력 부족으로 시원하게 박살났다. 다행히 면접이 끝난 직후 필자가 대답하지 못했던, 풀어내지 못했던 질문들과 문제를 깃허브에 정리해두었기 때문에 어떤 것을 공부해야하는지 바로 알 수 있었고, 한 달동안 컴퓨터 사이언스의 기초에 대한 내용을 집요하게 파헤쳤다.</p><a id="more"></a><p>대학생 시절 이후로 꺼내보지 않았던, 먼지 쌓인 전공 서적을 다시 펼쳐놓고 정독하기 시작했고, 자바스크립트의 기초 지식을 닥치는대로 구글링하면서 스크랩했다. 사실 작성한 포스팅들의 주제만 봐도 지난 한 달 동안 필자가 공부한 것들이 어떤 주제였는지 대충 보인다.</p><p>필자가 프라하에서 지냈던 한 달 동안 5편의 에세이 포스팅과 1편의 기술 포스팅을 작성한 것과 비교해보면 최근 한 달간의 포스팅들은 전부 기술 포스팅이다. 그것도 기초적인 내용들인 힙, JS 프로토타입, 수학으로 알고리즘 문제 풀기, 최근의 TCP 집중 분석까지…</p><p>그렇게 한 달동안 미친듯이 컴퓨터 사이언스의 기초를 공부하다가, 오늘 오전에 다른 회사의 면접 기술 과제를 만들기 위해 IDE를 켰는데 문득 이런 생각이 스쳤다.</p><blockquote><p>내가 마지막으로 뭘 만들어 본게 언제였지?</p></blockquote><center><br>  <img src="/2019/11/16/the-way-to-control-anxiety/commit.jpeg" width="300"><br>  <br><br></center><p>지난 한 달동안 필자는 어플리케이션을 개발한 적이 없었던 것이다. 만드는 것이 너무 즐거워서 개발자가 되었건만, 정작 한 달동안이나 아무것도 만들지 않고 있었다.</p><p>필자의 지난 한 달은 기초에 대한 공부의 연속이었고, 지금까지 놓치고 있었던 것들을 다시 한번 살펴보는 복습의 시간이었다. 하지만 딱히 공부를 하면서 즐겁지는 않았던 것 같다. 아니, 사실 즐겁게 공부하려는 마음도 없었다고 말하는 게 맞을지도 모른다.</p><p>여기까지 생각이 닿고나니 갑자기 현타가 와서 잠시 공부를 접고 스스로를 돌아보는 시간을 가지려고 한다.</p><h2 id="나는-불안했다"><a href="#나는-불안했다" class="headerlink" title="나는 불안했다"></a>나는 불안했다</h2><p>지난 한 달 동안 필자는 현실에 쫒기고 있었다. 프라하에서 다짐했던 <code>여유를 가지며 살자</code>라는 마음은 서울에 도착하고 몇 주가 지나자 온데 간데 없어져버렸다.</p><p>사실 이런 불편한 감정의 근본적인 원인은 바로 <code>불안감</code>이다. 이런 불안감은 필자의 일상을 흑백으로 바꿔버렸다. 친구들을 만나면 순간순간은 즐거웠지만, 틈만 나면 빨리 집에 가서 바로 책과 노트북을 피고 공부해야한다는 생각이 떠올랐다.</p><p>그냥 딱 봐도 건강한 마음의 상태는 아니다. 물론 겉으로는 아닌 척하고 있지만 속에서부터 곪아가고 있는 상태인 것이다. 그래서 필자는 공부를 잠깐 멈추고, 도대체 무엇 때문에 이렇게 불안해하며 쫒기고 있는 것인지 생각해보기 시작했다.</p><p>물론 간만에 면접에서 털려보면서 필자의 약점을 날 것으로 마주하게 되었다는 이유가 크겠지만, 단순히 이것 때문에 이 정도까지 불안한 마음이 생긴다는 것은 조금 이상했다. 솔직히 면접 털려본 것이 한 두번도 아니니 말이다.</p><p>그렇게 하루 정도 깊게 고민을 해보고나니 몇 가지 불안 요인이 정리가 되었고, 이후 필자는 이 요인들을 리스트업하고 하나씩 살펴보기 시작했다.</p><h3 id="현실과-이상의-괴리"><a href="#현실과-이상의-괴리" class="headerlink" title="현실과 이상의 괴리"></a>현실과 이상의 괴리</h3><p>어릴 때 부모님이나 어른들이 했던 이야기 중에서 가장 이해되지 않았던 말은 <code>하고 싶은 것만 하면서 살 수는 없다</code>였다. <small>(물론 여기에는 반드시 “공부해라”라는 말이 따라온다)</small></p><p>시간이 지나 군대를 다녀오고 대학교에 복학하면서 당시 어른들이 했던 이 말의 의미를 조금씩 이해하게 되었다. 세상 만사 내 맘대로 되는 일만 있는 것은 아니니 어느 정도는 마음을 내려놓으라는 가르침이었으리라.</p><p>죽어도 공부하기 싫은 날에도 장학금을 위해 밤새워가며 공부를 해야했고, 군대에 가기 싫었지만 국방의 의무 때문에 23개월동안 구르다 왔던 경험을 하고 나니 <code>음, 그 말이 바로 이런 느낌이군</code>이라는 생각을 했던 것 같다.</p><p>그래도 하기 싫은 일을 돈 때문에 억지로 하면서 평생 살고 싶지는 않았기에, 내 인생의 행복을 위해서는 <code>하고 싶은 일</code>을 가장 우선 순위로 높게 잡고 있었고, 다행히도 개발자라는 직업을 가지게 되면서 사회의 일원으로써의 자리와 직장인으로써의 안정적인 수입, 그리고 내가 즐기며 할 수 있는 일까지 거머쥔 덕업일치의 생활을 할 수 있었다.</p><p>그러나 이렇게 직장인이 되고 나니, 학생 때와는 또 다른 문제가 생기기 시작했다.</p><p>아직 성 차별, 학력 차별 등 여러가지 문제가 산재하기는 하지만 기본적으로 2019년의 대한민국은 모든 사람에게 평등한 기회를 주려고 노력하는 사회이고, 그런 기회는 보통 개인의 능력이나 실력으로 거머쥘 수 있다.</p><p>그 중에서도 특히 IT업계의 대표적인 전문직인 개발자는 진짜 실력 하나로 비벼서 먹고 살아가는 실력몰빵주의라고 할 수 있다. 그래서 개발자들 사이에서는 치킨 집을 차리기 전까지는 계속 공부해야한다는 자조섞인 농담을 나누기도 한다.</p><p>그래도 필자는 프로그래밍 공부를 한다는 것 자체가 너무 재밌고 좋았다. 애초에 내가 하고 싶은 일을 선택한 것이기도 하고 공부하면 할수록 내가 만든 어플리케이션이 더 좋은 구조, 좋은 성능을 가질 수 있으니까.</p><p>하지만 앞서 이야기 했듯이, 최근 한 달 동안 컴퓨터 사이언스의 기초를 공부하면서 필자는 마냥 즐겁지만은 않았다.</p><p>사실 필자가 즐겁지 않은 공부를 하며 가장 의아했던 부분은 이렇게 기초를 공부하는 과정은 이미 대학생 때 한번 겪었던 경험인데 그때 당시와 지금 느끼는 감정이 너무나도 다르다는 것이었다. 당시에는 똑같은 공부를 해도 하나하나 신기하고 너무 재미있었기 때문이다.</p><p>그럼 대학생 때는 그렇게 재미있었던 내용들이 왜 지금와서는 재미가 없어진 것일까?</p><p>그 이유는 바로 <code>공부의 동기</code> 때문이다. <a href="/2019/08/26/how-does-developer-study/" title="개발자가 공부로 살아남는 방법">개발자가 공부로 살아남는 방법</a> 포스팅에서도 한 번 이야기한 적이 있지만, 사실 공부라는 것은 주제의 난이도보다도 건강한 동기 부여가 더 중요하다.</p><p>하지만 필자는 현재 자의적으로 컴퓨터 사이언스 기초에 대한 공부를 하는 것이 아니라 구직 중이라는 외부 상황에 떠밀려서 공부를 하고 있는 상황이다. 더 쉽게 이야기해보자면, 필자가 원하는 주제를 필요에 따라 공부하는 것이 아니라 당장 하고 싶지 않은데 외부 상황 때문에 억지로 하고 있는 공부인 것이다.</p><center><br>  <img src="/2019/11/16/the-way-to-control-anxiety/study-motivation.jpg" width="300"><br>  <small>어차피 나중에 공부할건데 엄마가 지금 공부하라고 하면 왠지 더 하기 싫어지는 마음이랄까</small><br>  <br><br></center><p>사실 공부할 주제를 선택할 때 <code>이걸 공부하면 내가 어떤 점이 더 나아질까?</code>라는 생각으로 두근거려야 하는데, 최근 한 달간의 공부는 <code>이걸 면접에서 물어볼까?</code>라는 마음으로 주제를 선택했으니 재미있을리가 만무하다.</p><p>그래도 어릴 적 어른들이 이야기했던 하고 싶은 것만 하면서 살 수는 없다는 말처럼 필자가 면접에 합격하기 위해서 부족한 부분을 채우는 과정이 필요하다는 것 또한 분명한 사실이다.</p><p>필자는 일을 재미있게 하고 싶어서 개발자라는 직업을 선택했는데, 현실적인 상황 때문에 재미없게 공부를 하고 있는 이 상황에 대해서 괴리감과 불편함을 느끼기 시작한 것이다.</p><h3 id="스스로에-대한-실망감"><a href="#스스로에-대한-실망감" class="headerlink" title="스스로에 대한 실망감"></a>스스로에 대한 실망감</h3><p>사실 지금까지 필자는 별 생각없이 회사를 선택해왔었다. 재밌게만 일할 수 있으면 됐지, 어디서 일하느냐가 그렇게 중요하지 않다고 생각했기 때문이다.</p><p>그런 식으로 직장을 고르다보니까 스스로 좀 더 많은 권한을 부여받고 많은 일을 할 수 있는 작은 규모의 스타트업을 주로 다니게 되었다.</p><p>그러나 최근 주변에 있는 많은 개발자분들이 <code>작은 곳도 경험해보고 큰 곳도 경험해봐라</code>라는 조언을 많이 해주셨다. 조금 더 다양한 경험을 해보고 성장하라는 의미인 것이다. 그런 이유로 이번에는 지금까지 다녔던 직장보다는 조금 더 규모가 있는 곳을 목표로 잡고 있다.</p><p>그러나 큰 회사들의 경우, 채용 과정과 원하는 인재상까지 필자가 지금까지 다녔던 규모의 회사들과는 조금 다르다.</p><p>규모가 작은 스타트업의 경우 말 그대로 <code>일당백의 당장 일할 수 있는 개발자</code>가 필요하다. 만들어야하는 프로덕트는 산더미같은데 리소스는 늘 부족하다보니 한 사람 한 사람이 많은 역할을 할 수 밖에 없는 것이다. 게다가 리소스가 부족하다보니 누군가를 체계적으로 교육하거나 스스로 학습할 수 있는 여유도 큰 회사에 비해 상대적으로 부족한 경우가 많다.</p><p>이에 반해 큰 회사들은 당장 입사해서 일할 수 있는 개발자를 급하게 찾는 입장은 아니다. 물론 어떤 회사던지 개발자라는 자원은 많으면 많을수록 좋기 때문에 계속 채용을 하기는 하지만, 규모가 작은 스타트업에 비교해봤을 때 당장 일할 사람이 부족해서 허덕이고 있는 정도의 상황은 아닐 가능성이 높다.</p><p>게다가 시스템의 규모 또한 해당 개발팀의 규모에 비례해서 늘어날 수 있기 때문에, 이미 많은 개발자를 보유하고 있는 회사의 시스템은 크기도 방대하고 구조도 복잡한 경우가 많다.</p><p>이런 이유들로 인해 규모가 큰 곳일수록 특정 프레임워크에 익숙한지 물어보기보다는 <code>니가 이걸 진짜 제대로 알고 쓰는거니?</code>에 집중하는 경우가 많기 때문에 컴퓨터 사이언스나 사용하는 언어에 대한 기초를 깊게 물어보는 것이다.</p><p>필자도 당연히 이런 사실들을 알고는 있었지만, 한국에 돌아오고 처음 면접을 볼 때까지만 해도 솔직히 별 걱정이 없었다. 그냥 <code>붙으면 다니고 아니면 다른 데 가지 뭐</code> 정도의 마음이었던 것 같다. 실제로 첫 면접에 떨어진 직후에는 불안한 마음이고 뭐고 멘탈에 별 타격이 없었다.</p><p>그래도 면접에 떨어졌으니 필자가 현재 부족한 것이 무엇인지 알 수 있었고, 당연히 이 부분을 보완하고 싶다는 마음이 생기게 되었다. 하지만 이상하게도 공부를 하면 할수록 뭔가 마음이 싱숭생숭해지기 시작했다.</p><p>얼마 전 SNS에서 여친이랑 헤어진 남자의 심리 변화라는 짤을 본 적이 있다. 여친이랑 헤어진 직후는 후련하고 자유로운 기분이지만 시간이 지나면서 그리운 감정이 커지게되고 후회한다는 그런 내용이었다. 뭔가 그런 느낌이랄까.</p><p>공부를 하면 할수록 면접장에서 제대로 대답하지 못했던 상황들이 계속 떠올랐고, 뒤늦은 부끄러움과 후회가 밀려온 것이다. 그와 동시에 스스로에 대한 실망감도 들기 시작했다.</p><p>솔직히 말하자면 나름 컴퓨터 사이언스에 대해서 알고 있다고 생각했다. 학교에서도 이미 한 번씩 배운 내용들이고, 나름 이것저것 분석해보면서 쌓은 지식들도 있었기 때문이다. 그러나 현실은 달랐다.</p><center><br>  <img src="/2019/11/16/the-way-to-control-anxiety/snl.jpg" width="500"><br>  <br><br></center><p>막상 면접장에 들어서고나서 <code>GC에 대해서 설명해주세요</code>와 같은 질문을 들으면 머리가 하얘졌다. 이런 질문을 들을 때 마다 필자의 머릿 속에는 수많은 개념들과 그림들이 동시에 떠올랐지만 정작 이걸 말로 정리해서 말하지 못했다. 즉, 제대로 알고 있지 않은 것이다.</p><p>이런 경험을 몇 번 하고나니 지금까지 내가 알고있다고 생각했던 지식들이 사실은 제대로 알고 있는 것이 아니었다는 것을 깨닿게 되었고, 지금까지 헛공부한 게 아닌가라는 생각, 다른 개발자들에 비해서 내가 뒤쳐질 수도 있다는 불안감이 스물스물 피어나게 되었다.</p><h3 id="주목당하는-게-부담스럽다"><a href="#주목당하는-게-부담스럽다" class="headerlink" title="주목당하는 게 부담스럽다"></a>주목당하는 게 부담스럽다</h3><p>아이러니하게도 지금 글을 작성하고 있는 바로 이 블로그도 필자의 불안감의 요인 중 하나이다. 정확히 말하면 불안정한 필자의 심리 상태에 불을 붙혀서 불안감을 증폭시킨 요인이라고 할 수 있겠다.</p><p>지금까지 필자는 포스팅을 적고 다른 사람들과 내 지식과 생각을 공유하기 위한 목적으로 약간의 홍보를 통해 포스팅을 공유해왔다. 그러다보니 필자의 글을 재밌게 읽어주신 분들이 <code>포스팅 잘 읽었다</code>, <code>좋은 정보 공유 감사하다</code> 정도의 말씀을 해주시는 경우가 생기게 되었는데, 이때까지는 내 지식이 다른 사람들에게 도움이 될 수 있다는 사실에 그냥 기분이 좋았다.</p><p>하지만 최근 오프라인에서 필자를 알아보는 사람이 나타나는 경험을 몇 번 겪으면서 약간의 부담감이 스물스물 피어나게 되었다. <small>(이럴거라고는 진짜 상상도 못 했다)</small></p><p>이 감정이 최대로 증폭되는 경우는 바로 면접관이 <code>평소에 블로그 잘 보고 있어요</code>라고 하는 경우인데, 이때의 당혹감과 부담감이란 말로 표현할 수가 없다. 긴장을 안하고 있다가도 한 순간에 긴장하게 만들어버리는 마법의 단어인 것 같다.</p><p>그냥 사람들이 알아보는 것이 부담스럽다는 뜻은 아니다. 사람들이 필자를 알아보기 시작하면서 조금씩 <code>이 사람들이 날 어떻게 생각할까?</code>를 신경쓰기 시작했다는 것이 문제다.</p><p>사실 필자가 블로그 포스팅을 작성하는 이유는 필자의 지식을 타인에게 공유하고 싶다는 목적도 있지만 기본적으로는 공부한 내용을 정리하려는 목적이 크다. 자신의 지식을 글로 정리하는 과정에서 공부의 효율성을 높히고 기억에 오래 남는 효과를 기대하는 것이다.</p><p>하지만 필자가 엄청 뛰어난 기억력을 가지고 있지 않은 이상, 몇 번 공부한 내용이라고 한들 실제로 그 지식을 사용하지않고 오랜 기간이 지난다면 기억에서 점점 잊혀지기 마련이다. 결국 뭐가 되었든 공부의 기본은 반복 학습이고, 한 번 포스팅을 작성했다고 해서 그 지식이 온전히 필자의 것이 되는 게 아니라는 말이다.</p><p>그런 이유 때문에 필자는 계속 스스로 과거에 작성했던 포스팅을 읽어보면서 되새김질하기도 한다.</p><p>그러나 글을 읽는 독자 입장에서는 포스팅을 작성한 사람이 이 지식을 완벽하게 알고 있다는 생각이 들 수도 있다. 필자만 해도 다른 개발자 분들의 블로그 포스팅을 읽어보면서 막연하게 블로그 포스팅을 잘 쓰는 사람과 실력이 좋은 사람을 동일시했었다. 이 내용에 대해서 빠삭하게 잘 아니까 이렇게 글도 잘 쓰겠지라는 생각 때문이었다.</p><p>하지만 글을 잘 쓰고 정리를 잘 한다는 것이 필자의 프로그래밍 실력이 좋다는 것을 의미하진 않는다. 독자들이 생각하고 기대하는 것보다 필자의 실력이 만족스럽지 않을 수도 있다는 것이다.</p><p>필자가 느끼는 부담감은 이런 상황에서 비롯된 것이었다. 다른 사람이 <code>에반님 그때 정리해주신 그 내용 말이에요~</code>라고 운을 떼는 순간, <code>이거 대답 못하면 어쩌지?</code>라는 생각이 들 게 된다. 특히 그 사람이 면접관이라면 더 그렇다.</p><p>또한 간혹 고수, 존경과 같은 과분한 말을 해주시는 경우도 있는데, 애초에 필자는 고수도 아니고 누군가에게 존경받을 만한 사람은 더더욱 아닌, 그저 일개 4년차 꼬꼬마 개발자이기 때문에 감사한 마음과 동시에 약간의 부담감이 생기기도 햇다.</p><p>그래서 이런 상황들을 겪을 때마다 이런 생각이 들기 시작했다.</p><blockquote><ul><li>내 실력은 3 정도 밖에 안 되는데, 사람들이 내 실력을 6이나 7 정도로 생각하면 어떡하지?</li><li>내가 쓴 포스팅에 대한 질문에 제대로 답변하지 못하면 어떡하지?</li><li>난 존경받을만한 사람도 아니고 고수도 아닌데… 내가 이런 말을 들을 자격이 되는건가…?</li></ul></blockquote><p>그런 이유로 언젠가부터 점점 <code>사람들이 생각하는 나</code>라는 껍데기를 만들어야한다는 강박관념이 스물스물 피어나기 시작했고, 그 와중에 면접에서 거하게 털리면서 이 불안감 또한 함께 증폭된 것이다.</p><h2 id="결국은-마인드의-문제다"><a href="#결국은-마인드의-문제다" class="headerlink" title="결국은 마인드의 문제다"></a>결국은 마인드의 문제다</h2><p>사실 이런 불안한 마음들은 사람이라면 자연스럽게 생길 수 있는 마음이다. 그러나 이런 감정들은 막연하게 <code>불안하다</code> 정도의 느낌이라서, 명확하게 <code>무엇 때문에 내가 불안하다</code>라는 생각까지는 평소에 잘 생각하지 않는다.</p><p>하지만 자신이 불안한 이유를 확실히 파악하지 못하면 그 문제를 해결할 수 없다. 그래서 필자는 불안함의 원인에 대해서 리스트업을 하면서 이 문제들과 정면으로 마주한 것이다.</p><p>필자는 스스로 불안감의 요인에 대한 원인을 정리하고 리스트업하면서, 자연스럽게 이 문제에 대해 스스로 질문하고 답변하는 과정을 통해 나름의 해결 방법들을 정의할 수 있었다.</p><h3 id="동기-부여를-확실히-하자"><a href="#동기-부여를-확실히-하자" class="headerlink" title="동기 부여를 확실히 하자"></a>동기 부여를 확실히 하자</h3><p>앞서 이야기했듯이 필자가 컴퓨터 사이언스 기초 공부를 하며 재미없다고 느끼게 된 이유는 <code>하기 싫어도 해야한다</code>라는 마음 때문이다. 물론 현실적으로 보면 틀린 말은 아니다. 면접에 합격하기 위해서는 필자의 약점을 보완해야하니 말이다.</p><p>그러나 이번 한 번만 공부하고 말 것이 아니라면 이런 식의 동기 부여는 좋지 않다. 외압에 의한 동기 부여는 잠깐 동안 스스로를 몰아 세우며 빠르게 성장할 수는 있어도, 지속적인 성장에는 오히려 걸림돌이 된다.</p><p>사실 근본적으로 생각해보면 대학생 때나 지금이나 공부하고 있는 내용은 크게 다르지 않다. 하지만 그때는 기초 공부가 재미있었고 지금은 아니었던 이유가 바로 여기에 있다.</p><p>당시에는 내가 이걸 공부함으로써 성장할 수 있다는 사실이 동기가 되었지만, 지금은 면접에 붙어야한다는 사실이 동기가 되었기 때문에 같은 것을 공부해도 상당히 다른 느낌을 받을 수 밖에 없다는 것이다.</p><p>그래서 필자는 다시 초심으로 돌아가 <code>성장</code>에 초점을 맞춰 보려고 한다. 비록 빡센 기초 공부의 시작은 면접 때문이었을지 몰라도, 결과적으로는 필자가 성장할 수 있는 좋은 기회이기도 하기 때문이다.</p><h3 id="면접은-그냥-면접일-뿐"><a href="#면접은-그냥-면접일-뿐" class="headerlink" title="면접은 그냥 면접일 뿐"></a>면접은 그냥 면접일 뿐</h3><p>사실 기껏해야 한 두시간의 짧은 면접 시간 동안 한 사람의 역량을 오롯히 파악하는 것 자체가 굉장히 어려운 일이다.</p><p>그래서 대부분의 회사는 1차 기술, 2차 임원 등으로 면접 전형을 나눠서 평가하고 있지만, 이렇게 하더라도 컴퓨터 사이언스라는 학문의 범위가 너무 넓기 때문에 진짜 그 사람의 모든 강점과 약점을 파악한다는 것은 거의 불가능하다.</p><p>하지만 회사든 구직자든 면접 한번 보자고 서로 며칠 씩이나 붙어있을 수는 없는 노릇이니 최대한 짧은 시간 안에 객관적이고 효율적으로 실력을 평가할 수 있는 방법이나 질문을 통해 구직자를 평가하려고 노력하는 것이다.</p><p>당연히 이러한 사실은 회사도 알고 있기 때문에 면접관 스스로 혹은 회사의 가이드대로 어느 정도 객관성을 띄고 있는 질문을 준비하기는 하지만, 이 질문이 구직자의 강점이나 약점을 얼마나 캐낼 수 있는지는 며느리도 모르는 일이다.</p><p>그 말인 즉슨, 면접의 평가 결과는 어느 정도 단편성을 지니고 있을 수 밖에 없다는 것이다.</p><p>허지만 면접 과정에서 구직자가 면접관이 물어본 질문에 대답을 못했을 경우, 그 질문이 구직자의 약점을 관통했다는 것 자체는 물론 사실이다. 그래서 필자도 질문에 대답하지 못했던 내용을 정리하고 공부했던 것이다.</p><p>그러나 약점이 존재한다는 것이 실력없고 형편없다는 의미는 아니다. 약점은 보완하면 되는 것이고, 면접은 무슨 수능처럼 1년에 한 번만 볼 수 있는 것도 아니니까 다음 기회에 다시 도전하면 된다.</p><p>필자의 보컬 선생님 말을 빌리자면, 오히려 그런 기회를 통해 자신의 약점을 발견할 수 있음에 감사하라고 한다. 이런 기회조차 없는 상황이라면 오히려 더 성장하기 힘들 것이라는 이야기도 들었다.</p><p>이게 그저 정신승리라고 생각하는 사람도 있겠지만, 스스로 건강한 마음을 가질 수 있어야만 꾸준한 도전이 가능하기 때문에 이런 식의 멘탈 케어는 개인의 성장이나 발전에도 도움이 된다고 생각한다.</p><p>중요한 것은 면접에 떨어졌다는 것이 아니라, 면접을 통해 자신의 약점을 발견하고 올바른 동기 부여를 통해 꾸준한 공부를 할 수 있는 원동력을 확보하는 것이기 때문이다.</p><h3 id="블로그는-그냥-꾸준히-쓰자"><a href="#블로그는-그냥-꾸준히-쓰자" class="headerlink" title="블로그는 그냥 꾸준히 쓰자"></a>블로그는 그냥 꾸준히 쓰자</h3><p>필자는 애초에 자기 자신에게 후한 평가를 주는 성격은 아니다. 그냥 이건 필자 본연의 성격이기 때문에 개발자가 아니라 그냥 한 명의 인간으로써도 그렇다. 그래서 필자의 글을 읽은 분들이 칭찬과 격려의 의미로 해주시는 말들도 잘 받아들이지 못했던 것 같다. <small>(칭찬을 잘 안 받아들이는 타입이다)</small></p><p>사실 앞서 이야기했던 두 가지 케이스는 나름 혼자 생각해보면서 결론을 내렸지만, 이 문제만은 아직 명확한 결론을 내지 못한 상태이다. 그냥 다들 큰 의미없이 좋은 뜻으로 하는 말이니까 듣고 흘리라는 조언도 듣긴 했지만, 성격이 성격인지라 그러기도 쉽지 않기 때문이다.</p><p>그렇다고 블로그 작성을 그만 둘거냐면 그것도 아니다. 블로그 포스팅 작성은 공부와 공유의 목적도 있지만 그 전에 필자의 취미 생활이기도 하기 때문이다. 그래서 처음에는 포스팅은 꾸준히 쓰되 홍보를 하지말까라는 생각도 했었지만, 뭔가 명확한 결론이 나기  전까지는 그냥 하던대로 하는 것이 좋겠다는 결론을 내렸다.</p><p>사실 이건 필자 스스로 느끼는 부담감이고, 이것 외에는 블로그 포스팅 작성이 필자에게 득이 되었으면 되었지 실이 될 만한 것은 없기 때문이다. 그래서 이런 저런 생각보다는 글쓰기라는 행위 자체에만 집중하려고 한다. 그래서 지금도 아무 생각없이 일단 글을 쓰고 있다.</p><p>그리고 이런 이유 때문에 생기는 불안한 마음은 필자가 꾸준히 공부해서 점점 성장하고 자신감이 많이 붙게 된다면 자연스럽게 흐려질 것이라고 생각한다. 이런 과정 또한 필자가 성장하는 과정이고 컴포트 존을 벗어날 수 있는 좋은 기회일테니, 정면으로 부딫혀서 극복해봐야 하는 것 아닐까싶다.</p><p>일단 지금은 그냥 필자에게 관심을 가지고 지켜봐주시는 분들이 있다는 것에 감사하며 꾸준히 글이나 끄적이는 게 최선인 것 같다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>이번 포스팅은 어떻게 보면 실로 오랜만에 적어본, 남들을 위한 글이 아닌 나를 위한 글이었다. 글을 적으면서 생각을 정리하다보니 불안했던 마음도 어느 정도 사그러드는듯 하다.</p><p>비단 필자 뿐만 아니라, 필자와 비슷한 상황에 있는 다른 사람들도 비슷한 감정을 느낄 것이라고 생각한다. 일 안하고 하고 싶은 거 하면서 사는 백수 생활이라는 것이 물론 편하긴 하지만 그에 따른 부담감과 불안함도 당연히 따라오는 것이니 말이다.</p><p>게다가 이런 상태에서 발생한 불안감은 사소한 일상의 좌절만으로도 쉽게 증폭되기 때문에, 더욱 더 이런 멘탈 관리가 중요한 것 같다.</p><p>그래도 이렇게 글로 생각을 정리하는 과정을 거치면서 필자가 왜 불안한 마음이 드는 지 확실히 알 수 있었고, 이에 따른 나름의 해결책 또한 정의해볼 수 있었다. 이런 게 바로 글이 가진 매력이 아닐까.</p><p>물론 완전히 떨쳐내지는 못할 것이다. 사람인 이상 불확실한 미래를 걱정하며 불안한 감정이 생기는 것은 자연스러운 것이니까.</p><p>하지만 막연하게 불안함에 떨고 쫒기면서 하기 싫은 공부를 억지로 하거나 부담감을 가지고 포스팅을 작성하는 상황보다는 내가 이 공부를 함으로써 어떤 방향으로 성장할 수 있을 지 확실히 인지하고, 내가 작성한 글들이 타인에게 좋은 영향을 줄 수 있을거란 믿음을 가지는 것이 훨씬 건강한 마인드라는 것은 자명하다.</p><p>면접 떨어진 건 아쉽긴 하지만, 부족한 실력은 공부해서 채우면 된다. 어차피 백수니까 공부할 시간도 남아돈다. 사실 이 시간 또한 언젠가 다시 직장인이 되면 그리워질 시간일테니, 최대한 마음 편하게 즐겨보려고 한다.</p><p>이렇게 불안한 마음을 다스릴 수 있는 글쓰기라는 취미 생활을 가지고 있다는 것도 어찌보면 행복일지도.</p>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/11/16/the-way-to-control-anxiety/#disqus_thread</comments>
    </item>
    
    <item>
      <title>TCP의 헤더에는 어떤 정보들이 담겨있는걸까?</title>
      <link>https://evan-moon.github.io/2019/11/10/header-of-tcp/</link>
      <guid>https://evan-moon.github.io/2019/11/10/header-of-tcp/</guid>
      <pubDate>Sun, 10 Nov 2019 09:39:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;저번에 &lt;a href=&quot;/2019/10/08/what-is-http3/&quot; title=&quot;HTTP/3는 왜 UDP를 선택한 것일까?&quot;&gt;HTTP/3는 왜 UDP를 선택한 것일까?&lt;/a&gt; 포스팅을 진행하며 TCP에 대해 간단한 언급을 했었지만, 해당 포스팅에서는 기존의 HTTP에서 사용하던 TCP에 어떤 문제가 있었는지에 집중해서 이야기했었지만 이번에는 TCP 자체에 조금 더 집중해서 이야기해보려고 한다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>저번에 <a href="/2019/10/08/what-is-http3/" title="HTTP/3는 왜 UDP를 선택한 것일까?">HTTP/3는 왜 UDP를 선택한 것일까?</a> 포스팅을 진행하며 TCP에 대해 간단한 언급을 했었지만, 해당 포스팅에서는 기존의 HTTP에서 사용하던 TCP에 어떤 문제가 있었는지에 집중해서 이야기했었지만 이번에는 TCP 자체에 조금 더 집중해서 이야기해보려고 한다.</p><a id="more"></a><p>원래는 이 포스팅에서 TCP의 개괄적인 내용을 모두 다루려고 했으나 생각보다 양이 너무 많아서 몇 개의 포스팅으로 나누어 작성하려고 한다.<small>(파도파도 끝이 없는 이 놈의 할배 프로토콜…)</small></p><p>그런 이유로 이번 포스팅에서는 TCP의 헤더 안에 들어 있는 필드들이 어떤 의미를 가지고 있는지에만 집중해서 이야기 해보도록 하겠다.</p><h2 id="TCP-Transmission-Control-Protocol"><a href="#TCP-Transmission-Control-Protocol" class="headerlink" title="TCP, Transmission Control Protocol"></a>TCP, Transmission Control Protocol</h2><p><code>TCP(Transmission Control Protocol)</code>는 OSI 7계층 중 전송 계층에서 사용되고 있는 프로토콜로, 장비들 간의 통신 과정에서 정보를 안정적으로, 순서대로, 에러없이 교환할 수 있도록 하는 것에 목적을 둔 프로토콜이다.</p><p>컴퓨터 공학에서는 컴퓨터에게 가까운 부분일 수록 <code>낮다</code>거나 <code>뒤에 있다</code>는 표현을, 사람에게 가까운 <code>높다</code>거나 <code>앞에 있다</code>라는 표현을 자주 사용하는데, OSI 7계층에서도 마찬가지로 낮은 계층일수록 기계에 가까운 부분이고 높은 부분일수록 사람에게 가까운 부분이라고 생각하면 편하다.</p><center><br>  <img src="/2019/11/10/header-of-tcp/osi.png" width="500"><br>  <br><br></center><p>이때 우리에게 친숙한 <code>HTTP</code>, <code>SMTP</code>, <code>FTP</code>와 같은 프로토콜 친구들이 가장 높은 계층인 응용 계층에 위치한다. 그에 비해 더 낮은 계층에 존재하는 <code>TCP</code>, <code>UDP</code>, <code>IP</code> 같은 프로토콜들은 상대적으로 접할 일이 많이 없기는 하다.</p><p>이런 프로토콜들은 대부분 OS에서 알아서 처리해주기 때문에 상위 계층에서 프로그래밍을 하는 개발자가 굳이 여기서 일어나는 일까지 하나하나 신경쓸 필요가 없기 떄문이다.</p><p>애초에 이게 레이어 모델이 존재하는 이유 중 하나이다. 네트워크라는 것이 수많은 기술의 집약체인 만큼 한 명의 개발자가 모든 것을 다 알기는 힘들다. 그래서 각 계층 간 철저한 역할 분담을 통해 어떤 작업을 할 때 신경써야하는 범위를 좁혀주는 것이다.</p><p>덕분에 우리는 HTTP를 사용할 때 DNS는 어디를 사용할지, 패킷은 어떻게 처리할지 등 여러 가지 작업을 한번에 신경쓸 필요가 없다.</p><p>하지만 아무리 레이어가 나누어져 있다고 한들 하위 레이어에서 일어나는 일을 전혀 모르고 있다면, 어플리케이션 레이어에서는 아무 문제 없지만 하위 레이어에서 문제가 발생했을 때 전혀 손도 못 대는 케이스도 발생할 수 있다.</p><p>이런 이유로 자신이 사용하고 있는 프로토콜의 대략적인 작동 원리와 개요 정도는 알고 있으면 좋다고 생각하기 때문에, 이번 포스팅을 작성하며 그 동안 대략적인 몇 가지 특징으로만 알고 있던 TCP를 조금 뜯어보려고 한다.</p><h2 id="TCP는-왜-만들어진걸까"><a href="#TCP는-왜-만들어진걸까" class="headerlink" title="TCP는 왜 만들어진걸까?"></a>TCP는 왜 만들어진걸까?</h2><p>개인적으로 어떤 기술을 공부할 때, 무작정 외우는 것이 아니라 <code>이게 왜 필요한 것인지</code>를 알고 그 이유에 대해 공감하며 공부하는 편이 효과적이라고 생각한다.</p><p>TCP는 워낙 옛날에 나온 기술이니 당시 상황을 100% 공감하기는 쉽지 않겠지만, 그래도 이 프로토콜이 개발된 이유를 살펴보면 당시 엔지니어들의 고충을 알아볼 수 있다.</p><h3 id="패킷-교환-방식을-사용해보자"><a href="#패킷-교환-방식을-사용해보자" class="headerlink" title="패킷 교환 방식을 사용해보자!"></a>패킷 교환 방식을 사용해보자!</h3><p>TCP는 방금 이야기 했듯이 1970년 냉전 당시 미 국방성이 개발하던 알파넷 프로젝트의 일부로 개발되었는데, 그 당시 알파넷을 연구할 때 관심을 가진 주제 중에 하나가 바로 <code>핵전쟁이 나도 살아남는 네트워크</code>였다.<small>(핵전쟁의 상대방은 당연히 마더 러씨아…)</small></p><p>왜냐하면 1970년대의 네트워크는 <code>회선 교환 방식</code>을 사용하고 있었기 때문에 중계국이 폭격을 맞아서 박살나거나 중간에 연결된 선이 하나가 잘려나가면 그대로 통신이 끊어져 버렸기 때문이다.</p><center><br>  <img src="/2019/11/10/header-of-tcp/old-telephone.jpg" width="500"><br>  <small>직접 보지는 않았지만 이런 느낌이지 않았을까…?</small><br>  <br><br></center><p>저 당시 중계국이 하는 일은 그냥 이거다. A가 중계국에 “B랑 연결해주세요!”라고 하면, 위의 사진과 같이 케이블이 마구 꽂혀있는 패치 테이블에서 A 라벨이 붙은 구멍과 B 라벨이 붙은 구멍을 찾아서 케이블로 연결해준다.</p><p>말 그대로 <code>회선을 교환하는 방식</code>인 것이다. 저러다가 A가 C랑 통신하고 싶으면 B 구멍에서 케이블을 빼서 C 구멍에 꽂으면 된다.</p><p>이렇게 회선 교환 방식의 경우에는 통신을 하고 싶은 상대방과 물리적으로 회선을 하나 딱 잡아놓고 계속 통신을 하는 것이기 때문에 회선의 효율이 낮을 수 밖에 없다. 우리가 전화를 걸 때 상대방이 통화 중이면 <code>상대방이 통화 중이니...</code> 어쩌고 나오는 것과 같은 원리이다.</p><p>물론 회선을 독점하기 때문에 대량의 데이터를 빠른 속도로 주르륵 보낼 수 있는 등의 장점도 있긴 하지만, 이때 미국에게 중요한 것은 <code>핵이 터져도 끊기지 않는 연결</code>이었기 때문에 하나의 회선에 전적으로 의존하는 연결이라는 건 큰 단점으로 다가왔을 것이다.</p><p>그래서 나온 아이디어가 바로 <code>패킷 교환 방식</code>이다. 데이터를 하나의 회선을 사용하여 보내다가 해당 회선이나 중계국이 개박살나면 전송되던 데이터와도 영원히 이별하게 되니, 데이터를 잘게 쪼갠 후 여러 개의 회선을 통해 보내자는 것이다. 일종의 분산투자랄까.</p><center><br>  <img src="/2019/11/10/header-of-tcp/packets.png" width="500"><br>  <small>이렇게 되면 노드 하나가 박살나도 모든 데이터가 유실되진 않을 것이다</small><br>  <br><br></center><p>최악의 경우 중간에 있는 회선이나 중계국이 박살나서 데이터가 약간 유실될 수는 있겠지만 전체 네트워크를 한 번에 타격하지 않는 이상 모든 데이터가 유실될 가능성은 적다. 또한 하나의 회선을 잡아놓고 계속 통신하는 것이 아니라 패킷에 목적지를 마킹해놓고 그냥 보내기만 하면 되니, 회선의 사용 효율 또한 높아질 수 있다.</p><p>이런 이유로 미 국방성은 이 아이디어를 채택하여 알파넷에 적용했고, 초기 테스트도 대성공하여 패킷 교환 방식의 실용성을 증명했다.</p><p>이후 몇 개의 대학과 군에서만 사용되던 알파넷이 대중들에게 공개되고 전 세계적으로 연결되며 인터넷으로 발전하게 되었고, 덩달아 알파넷의 통신 프로토콜이었던 TCP도 함께 떡상하게 된 것이다.</p><h3 id="패킷-교환-방식의-문제점"><a href="#패킷-교환-방식의-문제점" class="headerlink" title="패킷 교환 방식의 문제점"></a>패킷 교환 방식의 문제점</h3><p>하지만 패킷 교환 방식도 당연히 만능이 아니기에, 몇 가지 문제가 있었다. 우리가 TCP를 공부할 때 함께 따라오는 ARQ나 SYN, ACK 등의 개념들이 바로 이런 문제들을 해결하기 위해 과거의 엔지니어들이 머리를 싸맨 결과인 것이다.</p><blockquote><p>Q: 전송 중간에 패킷이 쥐도새도 모르게 사라지거나 훼손되면 어떡해요?<br>A: <strong>그럼 그 패킷만 다시 보내라고 해!(ARQ)</strong></p><p>Q: 송신 측이 패킷을 쪼갠 순서를 알아야 수신 측이 재조립할 수 있겠는데요?<br>A: <strong>그럼 순서번호를 패킷이랑 같이 보내!(시퀀스 번호)</strong></p><p>Q: 수신 측이 처리할 수 있는 속도보다 송신 측이 패킷을 빠르게 보내버리면 어떡하죠?<br>A: <strong>그럼 수신 측이 처리할 수 있는 양을 송신 측에 알려주고 그 만큼만 보내라고 해! (슬라이딩 윈도우)</strong></p></blockquote><p>TCP가지고 있는 많은 기능과 개념들은 마냥 글로만 봤을 땐 복잡해보이고 뭔가 외울 것도 많아보이지만, 당시 상황을 생각해보면 반드시 필요한 것들이었음을 알 수 있다.</p><p>그리고 이런 기능들은 상대방이 보낸 세그먼트의 헤더에 들어있는 정보를 파악하여 작동하기 때문에, 이 기능들을 하나씩 알아보기 전에 TCP의 헤더에는 어떤 정보들이 들어있고, 이 정보들이 의미하는 것이 무엇인지 살펴보려고 한다.</p><h2 id="TCP의-헤더를-까보자"><a href="#TCP의-헤더를-까보자" class="headerlink" title="TCP의 헤더를 까보자"></a>TCP의 헤더를 까보자</h2><p>HTTP, TCP, IP와 같은 프로토콜들은 각자 자신이 맡은 역할이 있고, 보내고자 하는 데이터에 자신의 헤더를 붙혀서 데이터의 정보를 표현한다.</p><p>TCP는 전송의 신뢰성과 흐름 제어, 혼잡 제어 등의 역할을 맡고 있는 프로토콜이기 때문에, TCP 헤더에도 이러한 기능을 사용하기 위한 여러가지 값들이 담겨있다.</p><p>즉, 이 헤더를 보면 개괄적인 TCP의 기능들을 한 차례 쓱 훑어볼 수 있다는 말이고, 그런 이유로 필자는 TCP 포스팅의 첫 번째 스텝으로 <code>헤더 까보기</code>를 골랐다.</p><center><br>  <img src="/2019/11/10/header-of-tcp/tcp-header.png"><br>  <br><br></center><p>TCP는 여러 개의 필드로 나누어진 <code>20 bytes</code>, 즉 <code>160 bits</code>의 헤더를 사용하며, 각 필드의 비트를 0 또는 1로 변경하여 전송하고자 하는 세그먼트의 정보를 나타낸다.</p><p>하지만 이 <code>20 bytes</code>라는 것은 아무 옵션도 없는 기본적인 헤더일 때의 용량이고, TCP의 여러가지 옵션들을 사용하면 헤더 맨 뒤에 옵션 필드들이 추가로 붙기 때문에 최대 <code>40 bytes</code>가 더해진 <code>60 bytes</code>까지도 사용할 수도 있다.</p><p>그럼 이 그림에 표기된 순서대로 각 필드가 어떤 정보를 담고 있는지 한번 살펴보도록 하자.</p><h3 id="Source-port-Destination-port"><a href="#Source-port-Destination-port" class="headerlink" title="Source port, Destination port"></a>Source port, Destination port</h3><center><br>  <img src="/2019/11/10/header-of-tcp/header-source-destination.png"><br>  <br><br></center><p>이 필드들은 세그먼트의 출발지와 목적지를 나타내는 필드로, 각각 16 bits 를 할당받는다. 이때 출발지와 목적지의 주소를 판별하기 위해서는 <code>IP 주소</code>와 <code>포트 번호</code>가 필요하다.</p><p>IP 주소는 당연히 한 계층 밑인 네트워크 계층에 있는 IP의 헤더에 담기기 때문에, TCP 헤더에는 IP 주소를 나타내는 필드가 없고 포트를 나타내는 필드만 존재한다.</p><h3 id="Sequence-Number"><a href="#Sequence-Number" class="headerlink" title="Sequence Number"></a>Sequence Number</h3><center><br>  <img src="/2019/11/10/header-of-tcp/header-sequence.png"><br>  <br><br></center><p>시퀀스 번호는 전송하는 데이터의 순서를 의미하며, 32 bits를 할당받는다. 최대 <code>4,294,967,296</code> 까지의 수를 담을 수 있기 때문에 시퀀스 번호가 그리 쉽게 중복되지는 않는다.</p><p>이 시퀀스 번호 덕분에, 수신자는 쪼개진 세그먼트의 순서를 파악하여 올바른 순서로 데이터를 재조립할 수 있게 된다.</p><p>송신자가 최초로 데이터를 전송할 때는 이 번호를 랜덤한 수로 초기화 하며, 이후 자신이 보낼 데이터의 1 bytes당 시퀀스 번호를 1씩 증가시키며 데이터의 순서를 표현하다 <code>4,294,967,296</code>를 넘어갈 경우 다시 0부터 시작한다.</p><h3 id="Acknowledgment-Number"><a href="#Acknowledgment-Number" class="headerlink" title="Acknowledgment Number"></a>Acknowledgment Number</h3><center><br>  <img src="/2019/11/10/header-of-tcp/header-ack.png"><br>  <br><br></center><p>승인 번호는 데이터를 받은 수신자가 예상하는 다음 시퀀스 번호를 의미하며, 32 bits를 할당받는다.</p><p>연결 설정과 연결 해제 때 발생하는 핸드쉐이크 과정에서는 <code>상대방이 보낸 시퀀스 번호 + 1</code>로 자신의 승인 번호를 만들어내지만, 실제로 데이터를 주고 받을 때는 <code>상대방이 보낸 시퀀스 번호 + 자신이 받은 데이터의 bytes</code>로 승인 번호를 만들어낸다.</p><p>예를 들어 1 MB짜리 데이터를 전송한다고 생각해보자. 이렇게 큰 데이터를 한번에 전송할 수는 없으므로, 송신자는 이 데이터를 여러 개의 세그먼트로 쪼개서 조금씩 전송해야한다. 이때 송신자가 한번에 전송할 수 있는 데이터 양은 네트워크나 수신자의 상태에 따라 가변적이긴 하지만, 그냥 <code>100 bytes</code>라고 가정해보자.</p><p>송신자는 첫 전송으로 100 bytes 만큼만 데이터를 전송하며 시퀀스 번호를 <code>0</code>으로 초기화한다. 시퀀스 번호는 1 bytes당 1씩 증가하기 때문에 첫 번째 바이트 뭉치는 0, 두 번째 바이트 뭉치는 1, 세 번째 바이트 뭉치는 2와 같은 순서로 매겨질 것이다.</p><p>즉, 이번 전송을 통해 수신자는 0~99까지 총 100개의 바이트 뭉치를 받았고, 그 다음 전송 때 받아야할 시퀀스 번호는 2가 아닌 100이 되는 것이다.</p><center><br>  <img src="/2019/11/10/header-of-tcp/ack.png"><br>  <small>100 bytes 만큼 하나의 세그먼트로 묶어서 전송한다</small><br>  <br><br></center><p><code>tcpdump</code>를 사용하여 패킷을 캡쳐해보면 실제로 송신 측이 보낸 데이터의 길이만큼 수신 측의 승인 번호가 증가하는 모습을 확인해 볼 수 있다.</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">localhost.http-alt &gt; localhost.49680: Flags [P.], seq 160:240, ack 161, win 6374, length 80</span><br><span class="line">localhost.49680 &gt; localhost.http-alt: Flags [.], ack 240, win 6374</span><br></pre></td></tr></table></figure><p>송신 측이 보낸 세그먼트를 보면 시퀀스 번호가 <code>seq 160:240</code>로 찍혀있고, 수신 측은 자신의 승인 번호로 콜론 뒤 쪽의 값을 사용하고 있다.</p><p>이때 시퀀스 번호의 형식은 <code>n 이상:m 미만</code>의 범위를 나타낸다. 콜론 뒤쪽의 번호는 송신 측의 시퀀스 범위에 포함되지 않으므로 수신 측이 저 번호를 그대로 가져다 쓰는 것이다.</p><p>즉, 승인 번호는 <code>다음에 보내줘야하는 데이터의 시작점</code>을 의미한다는 것을 알 수 있다.</p><h3 id="Data-Offset"><a href="#Data-Offset" class="headerlink" title="Data Offset"></a>Data Offset</h3><center><br>  <img src="/2019/11/10/header-of-tcp/header-data-offset.png"><br>  <br><br></center><p>데이터 오프셋 필드에는 전체 세그먼트 중에서 헤더가 아닌 <code>데이터</code>가 시작되는 위치가 어디부터인지를 표시한다.</p><p>이 오프셋을 표기할 때는 <code>32비트 워드</code> 단위를 사용하며, 32 비트 체계에서의 <code>1 Word = 4 bytes</code>를 의미한다. 즉, 이 필드의 값에 4를 곱하면 세그먼트에서 헤더를 제외한 실제 데이터의 시작 위치를 알 수 있는 것이다.</p><p>이 필드에 할당된 4 bits로 표현할 수 있는 값의 범위는 <code>0000 ~ 1111</code>, 즉 <code>0 ~ 15 Word</code>이므로 기본적으로 <code>0 ~ 60 bytes</code>의 오프셋까지 표현할 수 있다. 하지만 옵션 필드를 제외한 나머지 필드는 필수로 존재해야 하기 때문에 최소 값은 20 bytes, 즉 <code>5 Word</code>로 고정되어 있다.</p><p>이 필드가 필요한 이유는, 밑에서 설명할 <code>옵션(Option)</code> 필드의 길이가 고정되어 있지 않기 때문이다.</p><h3 id="Reserved-3-bits"><a href="#Reserved-3-bits" class="headerlink" title="Reserved (3 bits)"></a>Reserved (3 bits)</h3><center><br>  <img src="/2019/11/10/header-of-tcp/header-reserved.png"><br>  <br><br></center><p>미래를 위해 예약된 필드로, 모두 <code>0</code>으로 채워져야 한다. 상단의 헤더 그림에도 그냥 <code>0 0 0</code>으로 찍혀있는 것을 확인해볼 수 있다.</p><h3 id="Flags-NS-FIN"><a href="#Flags-NS-FIN" class="headerlink" title="Flags (NS ~ FIN)"></a>Flags (NS ~ FIN)</h3><center><br>  <img src="/2019/11/10/header-of-tcp/header-flags.png"><br>  <br><br></center><p>9개의 비트 플래그이다. 이 플래그들은 현재 세그먼트의 속성을 나타낸다. 기존에는 6개의 플래그만을 사용했지만, 혼잡 제어 기능의 향상을 위해 <code>Reserved</code> 필드를 사용하여 <code>NS, CWR, ECE</code> 플래그가 추가되었다.</p><p>먼저 기존에 존재하던 플래그들의 의미는 다음과 같다.</p><table><thead><tr><th>필드</th><th>의미</th></tr></thead><tbody><tr><td>URG</td><td><code>Urgent Pointer(긴급 포인터)</code> 필드에 값이 채워져있음을 알리는 플래그. 이 포인터가 가리키는 긴급한 데이터는 높게 처리되어 먼저 처리된다. 요즘에는 많이 사용되지 않는다.</td></tr><tr><td>ACK</td><td><code>Acknowledgment(승인 번호)</code> 필드에 값이 채워져있음을 알리는 플래그. 이 플래그가 0이라면 승인 번호 필드 자체가 무시된다.</td></tr><tr><td>PSH</td><td><code>Push</code> 플래그. 수신 측에게 이 데이터를 최대한 빠르게 응용프로그램에게 전달해달라는 플래그이다. 이 플래그가 0이라면 수신 측은 자신의 버퍼가 다 채워질 때까지 기다린다. 즉, 이 플래그가 1이라면 이 세그먼트 이후에 더 이상 연결된 세그먼트가 없음을 의미하기도 한다.</td></tr><tr><td>RST</td><td><code>Reset</code> 플래그. 이미 연결이 확립되어 <code>ESTABLISHED</code> 상태인 상대방에게 연결을 강제로 리셋해달라는 요청의 의미이다.</td></tr><tr><td>SYN</td><td><code>Synchronize</code> 플래그. 상대방과 연결을 생성할 때, 시퀀스 번호의 동기화를 맞추기 위한 세그먼트임을 의미한다.</td></tr><tr><td>FIN</td><td><code>Finish</code> 플래그. 상대방과 연결을 종료하고 싶다는 요청인 세그먼트임을 의미한다.</td></tr></tbody></table><p>기존의 Reserved 필드를 사용하여 새롭게 추가된 <code>NS</code>, <code>CWR</code>, <code>ECE</code> 플래그는 네트워크의 <code>명시적 혼잡통보(Explicit Congestion Notification, ECN)</code>을 위한 플래그이다.</p><p>ECN을 사용하지 않던 기존의 네트워크 혼잡 상황 인지 방법은 타임아웃을 이용한 방법이었다. 그러나 처리 속도에 민감한 어플리케이션에서는 이런 대기 시간 조차 아깝기 때문에, 송신자와 수신자에게 네트워크의 혼잡 상황을 명시적으로 알리기 위한 특별한 매커니즘이 필요하게 되었는데, 이것이 바로 <code>ECN</code>이다.</p><p>이때 <code>CWR</code>, <code>ECE</code>, <code>ECT</code>, <code>CE</code> 플래그를 사용하여 상대방에게 혼잡 상태를 알려줄 수 있는데, 이 중 <code>CWR</code>, <code>ECE</code>는 TCP 헤더에 존재하고 <code>ECT</code>, <code>CE</code>는 IP 헤더에 존재한다.</p><table><thead><tr><th>필드</th><th>의미</th></tr></thead><tbody><tr><td>NS</td><td>ECN에서 사용하는 CWR, ECE 필드가 실수나 악의적으로 은폐되는 경우를 방어하기 위해 RFC 3540에서 추가된 필드</td></tr><tr><td>ECE</td><td><code>ECN Echo</code> 플래그. 해당 필드가 1이면서, SYN 플래그가 1일 때는 ECN을 사용한다고 상대방에게 알리는 의미. SYN 플래그가 0이라면 네트워크가 혼잡하니 세그먼트 윈도우의 크기를 줄여달라는 요청의 의미이다.</td></tr><tr><td>CWR</td><td>이미 ECE 플래그를 받아서, 전송하는 세그먼트 윈도우의 크기를 줄였다는 의미이다.</td></tr></tbody></table><p>ECN은 이 포스팅의 주제와는 또 다른 이야기이므로 궁금하신 분들은 MR.ZERO님의 <a href="https://mr-zero.tistory.com/20" rel="external nofollow noopener noreferrer" target="_blank">Explict Congestion Notification?</a> 블로그를 참고하길 바란다.</p><h3 id="Window-Size"><a href="#Window-Size" class="headerlink" title="Window Size"></a>Window Size</h3><center><br>  <img src="/2019/11/10/header-of-tcp/header-window-size.png"><br>  <br><br></center><p>윈도우 사이즈 필드에는 한번에 전송할 수 있는 데이터의 양을 의미하는 값을 담는다. $2^{16} = 65535$ 만큼의 값을 표현할 수 있고 단위는 바이트이므로, 윈도우의 최대 크기는 <code>64KB</code>라는 말이 된다.</p><p>하지만 이 최대 크기는 옛날 옛적에 생긴 기준이라 요즘같이 대용량 고속 통신 환경에는 맞지 않는 경우도 있다. 그래서 비트를 왼쪽으로 시프트하는 방식으로 윈도우 사이즈의 최대 크기를 키울 수 있는 방식도 사용하고 있으며, 몇 번 시프트할 지는 옵션 필드의 <code>WSCALE</code> 필드를 사용하여 표기한다.</p><h3 id="Checksum"><a href="#Checksum" class="headerlink" title="Checksum"></a>Checksum</h3><center><br>  <img src="/2019/11/10/header-of-tcp/header-checksum.png"><br>  <br><br></center><p>체크섬은 데이터를 송신하는 중에 발생할 수 있는 오류를 검출하기 위한 값이다.</p><p>TCP의 체크섬은 전송할 데이터를 16 Bits씩 나눠서 차례대로 더해가는 방법으로 생성한다. 방식은 단순하지만 16 bits의 덧셈을 그대로 보자니 숫자가 너무 길어질 것이 뻔하므로 간단하게 반토막인 8 bits로만 한번 해보도록 하겠다.</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  11010101</span><br><span class="line">+ 10110100</span><br><span class="line">-----------</span><br><span class="line"> 110001001</span><br></pre></td></tr></table></figure><p>앗, 8 bits인 두 수를 더 했더니 자리 수가 하나 올라가서 9 bits가 되었다. 이렇게 자리 수가 넘쳐버리면 체크섬 필드에 담을 수 없다.</p><p>이렇게 두 개의 수를 더했을 때 자리 수가 하나 올라간 부분을 <code>캐리(Carry)</code>라고 하는데, 계산 결과에서 이 부분만 떼어내서 다시 계산 결과에 더해주면 된다.</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  10001001</span><br><span class="line">+        1 (방금 해에서 넘친 부분)</span><br><span class="line">-----------</span><br><span class="line">  10001010</span><br></pre></td></tr></table></figure><p>이런 방식을 <code>Warp Around</code>라고 한다. 이제 마지막 계산 결과에 <code>1의 보수</code>를 취해주면 체크섬이 된다. <code>1의 보수</code>라고 하면 뭐지 싶겠지만 그냥 비트를 반전하면 된다.</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10001010</span><br><span class="line">01110101 (1의 보수를 취한 모습)</span><br></pre></td></tr></table></figure><p>이제 <code>01110101</code>이 이 데이터의 체크섬이 되는 것이다. 이 예제에서는 8 bits를 가지고 진행했기 때문에 8 bits짜리 체크섬이 나왔지만, 실제로는 16 bits 단위로 데이터를 잘라서 이 과정을 진행하기 때문에 16 bits인 체크섬 필드에 딱 들어맞는 이쁜 값이 나온다.</p><p>수신 측은 데이터를 받으면 위의 과정을 동일하게 거치되 1의 보수를 취하지 않은 값인 <code>10001010</code>까지만 만든 다음, 이 값과 송신 측이 보낸 체크섬을 더해서 모든 비트가 1이라면 이 데이터가 정상이라고 판단할 수 있다.</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  10001010</span><br><span class="line">+ 01110101</span><br><span class="line">-----------</span><br><span class="line">  11111111</span><br></pre></td></tr></table></figure><p>만약 이 값에 0이 하나라도 있으면 송신 측이 보낸 데이터에 뭔가 변조가 있었음을 알 수 있다.</p><h3 id="Urgent-Pointer"><a href="#Urgent-Pointer" class="headerlink" title="Urgent Pointer"></a>Urgent Pointer</h3><center><br>  <img src="/2019/11/10/header-of-tcp/header-urgent.png"><br>  <br><br></center><p>말 그대로 긴급 포인터이다. URG 플래그가 1이라면 수신 측은 이 포인터가 가르키고 있는 데이터를 우선 처리한다.</p><h3 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h3><center><br>  <img src="/2019/11/10/header-of-tcp/header-options.png"><br>  <br><br></center><p>옵션 필드는 TCP의 기능을 확장할 때 사용하는 필드들이며, 이 필드는 크기가 고정된 것이 아니라 가변적이다. 그래서 수신 측이 어디까지가 헤더고 어디서부터 데이터인지 알기 위해 위에서 설명한 데이터 오프셋 필드를 사용하는 것이다.</p><p>데이터 오프셋 필드는 <code>20 ~ 60 bytes</code>의 값을 표현할 수 있다고 했는데, 아무런 옵션도 사용하지 않은 헤더의 길이, 즉 Source Port 필드부터 Urgent Pointer 필드까지의 길이가 <code>20 bytes</code>이고, 옵션을 모두 사용했을 때 옵션 필드의 최대 길이가 <code>40 bytes</code>이기 때문이다.</p><p>만약 데이터 오프셋 필드의 값이 5, 즉 20 bytes보다 크지만 TCP의 옵션을 하나도 사용하고 있지 않다면, 초과한 bytes 만큼 이 필드를 0으로 채워줘야 수신 측이 헤더의 크기를 올바르게 측정할 수 있다.</p><p>대표적인 옵션으로는 윈도우 사이즈의 최대 값 표현을 확장할 수 있는 <code>WSCALE</code>, Selective Repeat 방식을 사용하기 위한 <code>SACK</code> 등이 있으며, 이외에도 거의 30개 정도의 옵션을 사용할 수 있기 때문에 이 친구들을 하나하나 설명하는 것은 조금 힘들 것 같다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>이렇게 간략한 TCP의 개요와 헤더 구조에 대해서 알아보았다. 사실 이 내용들은 TCP라는 놈의 껍데기 한 겹 정도에 불과한 내용이지만, 이게 거의 50년 묵은 프로토콜이다보니 포스팅 하나로 정리하기에는 내용이 굉장히 방대하다.</p><p>서두에서 이야기 했듯이 TCP나 IP 같은 프로토콜은 소켓 프로그래밍이라도 하지 않는 이상 직접적으로 마주할 기회가 흔치 않은 것이 사실이다.</p><p>하지만 직접 마주하지 않더라도 필자는 매일 HTTP를 사용하는 웹 개발자이기 때문에, 자신이 매일 사용하는 프로토콜이 어떤 식으로 굴러가는 지 정도는 알고 있는 것이 좋다고 생각한다.</p><p>TCP가 커널에 어떻게 구현되어있는지 직접 확인해보고싶은 분은 깃허브에 올라가있는 리눅스 소스인 <a href="https://github.com/torvalds/linux/tree/master/net/ipv4" rel="external nofollow noopener noreferrer" target="_blank">linux/net/ipv4</a> 안에 있는 구현체들을 통해 확인해볼 수 있다.<small>(리눅스 소스 자체가 너무 커서 클론 받는 데 한 세월이라는 게 함정)</small></p><p>혹시 자신이 직접 TCP 통신 과정을 확인해보고 싶은 분은 간단한 <a href="https://github.com/evan-moon/simple-tcp-example" rel="external nofollow noopener noreferrer" target="_blank">TCP 예제 프로그램</a>과 <code>tcpdump</code>, <code>netstat</code> 등의 유틸리티를 통해 확인해볼 수 있다. <code>tcpdump</code>를 클라이언와 서버가 주고 받는 패킷의 내용을 확인해보고, <code>netstat</code>을 사용하여 클라이언트와 서버의 TCP 상태를 확인해볼 수도 있다.</p><p>다음 포스팅에서는 TCP의 핸드쉐이크나 흐름 제어, 혼잡 제어 기법에 대해서 한번 다뤄보도록 하겠다.</p><p>이상으로 TCP의 헤더에는 어떤 정보들이 담겨있는걸까? 포스팅을 마친다.</p>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/11/10/header-of-tcp/#disqus_thread</comments>
    </item>
    
    <item>
      <title>수학과 함께 복잡한 문제를 단순하게 만들자!</title>
      <link>https://evan-moon.github.io/2019/10/30/make-simple-with-math/</link>
      <guid>https://evan-moon.github.io/2019/10/30/make-simple-with-math/</guid>
      <pubDate>Wed, 30 Oct 2019 13:38:26 GMT</pubDate>
      <description>
      
        &lt;p&gt;최근 많은 IT 기업들이 개발자를 채용할 때 코딩 테스트를 시행하고 있다. 회사마다 어떤 스타일의 문제를 출제하는지 차이는 있지만, 대부분 간단한 알고리즘 풀이 또는 &lt;code&gt;Codility&lt;/code&gt;나 &lt;code&gt;프로그래머스&lt;/code&gt;와 같은 사이트처럼 실무에서 겪을 만한 상황을 살짝 섞어놓는 느낌의 문제를 선호하는 것 같다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>최근 많은 IT 기업들이 개발자를 채용할 때 코딩 테스트를 시행하고 있다. 회사마다 어떤 스타일의 문제를 출제하는지 차이는 있지만, 대부분 간단한 알고리즘 풀이 또는 <code>Codility</code>나 <code>프로그래머스</code>와 같은 사이트처럼 실무에서 겪을 만한 상황을 살짝 섞어놓는 느낌의 문제를 선호하는 것 같다.</p><a id="more"></a><p>이런 문제들의 특성 상 CS 기초와 문제 분석 능력, 직감 등을 다양하게 사용하여 해결해야 하기 때문에 단기간 연습한다고 실력이 확 느는 것은 아닌 것 같다.</p><p>이런 문제들은 우리에게 단순히 <code>너 이 알고리즘 알아?</code>라고 물어보는 것이 아니라 <code>어떤 방법을 사용해서 풀어볼래?</code>라고 물어본다.</p><p>사실 자료구조나 알고리즘 자체는 보면 공부하고 몇 번 구현해보면 어느 정도 숙달될 수 있지만, 이렇게 문제를 분석하고 단순화해서 적합한 방법을 선택할 수 있는 능력은 단순히 공부로 만들어 낼 수 있는 종류의 것은 아닌 것 같다.</p><p>필자는 최근 취업 준비를 하면서 이런 문제를 종종 풀어보고 있는데, 확실히 CS 기초도 부족하긴 하지만, 문제를 분석하고 좋은 방법을 선택할 수 있는 능력이 많이 부족함을 느꼈다.</p><p>그래서 자료구조나 알고리즘을 처음부터 다시 공부하면서, 동시에 문제 해결 능력을 기르기 위한 방법이 어떤 것이 있을지 고민해보기 시작했다.</p><h2 id="수학적인-사고-방식으로-문제를-단순화하자"><a href="#수학적인-사고-방식으로-문제를-단순화하자" class="headerlink" title="수학적인 사고 방식으로 문제를 단순화하자"></a>수학적인 사고 방식으로 문제를 단순화하자</h2><p>필자는 최근 면접에 거하게 털리고 나서 CS 기초나 자바스크립트 기초를 처음부터 다시 공부하기 시작했는데, 막상 이렇게 공부한 지식을 가지고 코딩 테스트 문제를 한번 풀어보려고 했더니, 생각처럼 잘 되지 않았다.</p><p>대부분 알고 있겠지만, 많은 코딩 테스트 문제은행 서비스에서는 문제를 해결하고 나면 다른 사람들은 이 문제를 어떤 방식으로 해결했는지도 함께 보여준다. 필자같은 경우는 사실 이게 궁금해서 문제를 푸는 것도 있는 것 같다.</p><p>그러던 와중에 대부분의 사람들이 완전탐색으로 풀었던 문제를 어떤 굇수 분이 단순한 산수 연산 몇 번으로 풀어내는 것을 본 적이 있었다.</p><center><br>  <img src="/2019/10/30/make-simple-with-math/genius.jpg" width="350"><br>  <small>역시 세상은 넓고 굇수는 많다</small><br>  <br><br></center><p>당연히 필자도 해당 문제를 완전탐색으로 풀었고 그 방법 밖에 없을 것이라고 생각했지만, 그 굇수분은 문제의 패턴을 찾아내어 문제를 단순화 시킨 것이다.</p><p>물론 조금 난해한 감이 있어서 실무에서 사용하기에는 조금 이견이 갈릴 수 있는 코드이긴 했지만, 대부분의 사람들이 완전탐색으로 풀었던 복잡한 문제를 단순한 식 몇개로 풀어냈다는 사실이 충격이었다.</p><p>이때 필자가 느낀 점은, <code>수학적인 사고</code>에 대한 필요성이었다. 물론 알고리즘 역시 이런 수학적인 사고를 바탕으로 효율적인 해결 방식을 일반화한 것이긴 하지만, 필자가 원했던 것은 좀 더 근본적인 문제 해결 능력이었다.</p><p>물론 수학적인 사고라고 해서 문제를 읽고 막 복잡한 식을 세우는 것이 아니다. 자연어로 이루어진 문제를 분석하고, 해결 가능한 수준으로 나누고, 패턴을 찾아내는 과정 또한 수학적인 사고에서 비롯된다. 애초에 수학 자체가 복잡한 문제를 단순화하고 패턴을 찾아내어 일반화하는 학문이다.</p><p>그리고 <a href="/2019/07/17/programmer-with-math/" title="프로그래머는 수학을 잘해야할까?">프로그래머는 수학을 잘해야할까?</a> 포스팅에서 한번 이야기한 적 있지만, 필자가 이야기하고싶은 수학은 어려운 이론이나 공식을 말하는 것이 아니다.</p><p>개인적인 생각이기는 하지만, 필자는 <code>수의 성질</code>을 이해하는 것이 제일 중요하다고 생각했다. 예를 들면 홀수에 1을 더하면 짝수가 된다던가, 1부터 100까지의 합을 구할 때 <code>101 * 100 / 2</code>를 하면 된다던가와 같은 것들이 그렇다.</p><p>그런 이유로 최근 <a href="http://www.yes24.com/Product/goods/61791203" rel="external nofollow noopener noreferrer" target="_blank">프로그래머, 수학으로 생각하라</a>라는 책을 읽게 되었는데, 이 책의 초입부부터 재미있는 문제 해결 방법이 몇개 나와서 그 문제들과 해결 방법에 대해서 공유를 해볼까 한다.</p><h2 id="오늘로부터-100억일-후는-무슨-요일일까"><a href="#오늘로부터-100억일-후는-무슨-요일일까" class="headerlink" title="오늘로부터 100억일 후는 무슨 요일일까?"></a>오늘로부터 100억일 후는 무슨 요일일까?</h2><p>$n$일 후의 요일을 구하는 문제는 수학적인 사고를 필요로 하는 대표적인 문제 중 하나이다.</p><p>게다가 굳이 코딩 테스트까지 가지 않고 일상 속에서 비즈니스 로직만 만지고 있더라도 꽤나 자주 접할 수 있는 문제이다. 그래서 워밍업으로 상대적으로 익숙한 요일 구하기 문제를 먼저 살펴보려고 한다.</p><blockquote><p>필자가 이 글을 작성하고 있는 <code>2019년 10월 29일</code>은 <code>화요일</code>이다. 그럼 오늘로부터 100억일 후는 과연 무슨 요일일까?</p></blockquote><p>음, 단순하게 생각해보면… 오늘은 화요일이니까 1일 후는 수요일, 2일 후는 목요일과 같은 순차적인 방법으로 접근할 수도 있겠다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.time(<span class="hljs-string">'calc'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> week = [<span class="hljs-string">'일'</span>, <span class="hljs-string">'월'</span>, <span class="hljs-string">'화'</span>, <span class="hljs-string">'수'</span>, <span class="hljs-string">'목'</span>, <span class="hljs-string">'금'</span>, <span class="hljs-string">'토'</span>];</span><br><span class="line"><span class="hljs-keyword">let</span> today = <span class="hljs-number">2</span>;</span><br><span class="line"><span class="hljs-keyword">let</span> shift = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>); i++) &#123;</span><br><span class="line">  shift = i % week.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">today += shift;</span><br><span class="line"><span class="hljs-keyword">if</span> (today &gt; week.length - <span class="hljs-number">1</span>) &#123;</span><br><span class="line">  today -= week.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(week[today]);</span><br><span class="line"><span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">'calc'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">토</span><br><span class="line">calc: 60948.138ms</span><br></pre></td></tr></table></figure><p>아무리 요즘 컴퓨터가 연산 능력도 좋고 무보수로 일해주는 SCV라고 하지만 100억회를 반복하는 루프를 계산하게 하는 것은 너무나도 가혹한 처사이다. 이 알고리즘은 시간 복잡도가 $O(n)$이기에, 루프만 돌았을 뿐인데도 수행 시간이 1분이 넘는다.</p><p>이렇게 무식하게 풀어낼 수는 없으니, 다른 방법을 찾아야한다. 다행히 우리는 요일이 <code>7</code>일 마다 반복된다는 것을 알고 있다. 오늘이 화요일이라면 7일 후도 당연히 화요일이고, 14일 후도 화요일이다.</p><p>즉, 요일이 반복된다는 <code>주기성</code>이 존재한다는 것이다. <code>오늘부터 7의 배수만큼 지난 날은 무조건 화요일</code>이라는 패턴을 찾았다면 그 다음부터는 간단해진다.</p><p>어떤 수를 1씩 증가시켜가면서 계속 7로 나누면 <code>0~6</code>이 순차적으로 나타나는 주기성이 있으므로, 배수를 구할 때와 마찬가지로 <code>100억</code>을 <code>7</code>로 나누고 그 나머지를 확인하면 되기 때문이다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.time(<span class="hljs-string">'calc'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> week = [<span class="hljs-string">'일'</span>, <span class="hljs-string">'월'</span>, <span class="hljs-string">'화'</span>, <span class="hljs-string">'수'</span>, <span class="hljs-string">'목'</span>, <span class="hljs-string">'금'</span>, <span class="hljs-string">'토'</span>];</span><br><span class="line"><span class="hljs-keyword">let</span> today = <span class="hljs-number">2</span>;</span><br><span class="line"><span class="hljs-keyword">let</span> shift = <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>) % week.length;</span><br><span class="line"></span><br><span class="line">today += shift;</span><br><span class="line"><span class="hljs-keyword">if</span> (today &gt; week.length - <span class="hljs-number">1</span>) &#123;</span><br><span class="line">  today -= week.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(week[today]);</span><br><span class="line"><span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">'calc'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">토</span><br><span class="line">calc: 0.156ms</span><br></pre></td></tr></table></figure><p>수행 시간이 <code>60000ms</code>에서 <code>0.156ms</code>로 줄었다. 이렇게 문제에서 주기성을 찾아내고, 나머지의 주기성과 연관지을 수만 있다면, 완전탐색을 하지 않고도 나머지를 사용하여 문제를 가볍게 풀 수 있다.</p><h3 id="10-100000000-일-후의-요일도-구해보자"><a href="#10-100000000-일-후의-요일도-구해보자" class="headerlink" title="$10^{100000000}$일 후의 요일도 구해보자"></a>$10^{100000000}$일 후의 요일도 구해보자</h3><p>자, 그럼 여기서 한번 더 나아가보자. 이런 방법으로 우리가 $10^{100000000}$일, 즉 <code>10의 1억승</code>일 이후의 요일도 구할 수 있을까? 10의 1억승을 뭐라고 부르는지는 모르겠지만, $10^{68}$이 무량대수라고 부르는 엄청 큰 숫자이니 쉽게 가늠이 안되는 수인 것은 분명하다.</p><p>당연히 $10^{100000000}$은 자바스크립트의 <code>Number.MAX_SAFE_INTEGER</code> 값을 아득히 넘어서는 숫자이기 때문에 위와 같은 방식으로는 계산이 불가능 하다. 여기서부터는 컴퓨터한테 계산을 맡기는 것보다는 문제를 단순화하고 주기성을 찾아내는 일이 더 중요해진다.</p><p>오늘은 <code>10월 29일 화요일</code>이니 오늘부터 $n$일 후의 요일을 쭉쭉 살펴보도록 하자. 방금 예제로 만들었던 로직을 활용하여 $10^{30}$일 이후까지 살펴보니, 대략 다음과 같은 패턴이 있다는 것을 알 수 있었다. 모든 결과를 적으면 너무 표가 길어지니, $10^{12}$일 이후의 결과만 기재하도록 하겠다.</p><table><thead><tr><th>일자</th><th>요일</th><th>인덱스</th></tr></thead><tbody><tr><td>$10^0$일 후</td><td>수</td><td>3</td></tr><tr><td>$10^1$일 후</td><td>금</td><td>5</td></tr><tr><td>$10^2$일 후</td><td>목</td><td>4</td></tr><tr><td>$10^3$일 후</td><td>월</td><td>1</td></tr><tr><td>$10^4$일 후</td><td>토</td><td>6</td></tr><tr><td>$10^5$일 후</td><td>일</td><td>0</td></tr><tr><td>$10^6$일 후</td><td>수</td><td>3</td></tr><tr><td>$10^7$일 후</td><td>금</td><td>5</td></tr><tr><td>$10^8$일 후</td><td>목</td><td>4</td></tr><tr><td>$10^9$일 후</td><td>월</td><td>1</td></tr><tr><td>$10^{10}$일 후</td><td>토</td><td>6</td></tr><tr><td>$10^{11}$일 후</td><td>일</td><td>0</td></tr><tr><td>$10^{12}$일 후</td><td>수</td><td>3</td></tr></tbody></table><p>필자는 이 과정에서 두 가지 정보를 얻을 수 있었다. 요일이 <code>수, 금, 목, 월, 토, 일</code>의 순서로 계속 반복되고 있다는 것과 오늘 요일인 <code>화요일</code>이 등장하지 않는다는 것이다.</p><p>즉, 10의 지수가 6 증가할 때마다 같은 요일이 돌아온다. 바꿔말하면 0의 개수가 6개씩 늘어날 때마다 같은 요일이 돌아온다는 말과 같다.</p><p>그렇다면 결국 10의 지수를 6으로 나눈 나머지 값을 사용하여 방금 전과 동일한 방법으로 요일을 구할 수 있다는 말이다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> week = [<span class="hljs-string">'수'</span>, <span class="hljs-string">'금'</span>, <span class="hljs-string">'목'</span>, <span class="hljs-string">'월'</span>, <span class="hljs-string">'토'</span>, <span class="hljs-string">'일'</span>];</span><br><span class="line"><span class="hljs-keyword">const</span> exp = <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">10</span>, <span class="hljs-number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(week[exp % week.length]);</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">토</span><br></pre></td></tr></table></figure><p>비록 $10^{100000000}$이라는 어마무시한 수를 컴퓨터가 담아낼 수 없기 때문에 직접 계산할 수는 없지만, 지수의 증가로 인한 요일의 주기를 파악함으로써 상상도 안가는 먼 미래의 요일을 구할 수 있게 되었다.<small>(사실 이걸 구하는 게 뭔 의미가 있겠냐만…)</small></p><p>만약 위에서 요일을 구했던 정직한 방법으로 이 문제를 풀려고 했다면 불가능했겠지만, 문제를 분석하고 주기성을 찾아냄으로써 어찌어찌 풀 수는 있었다.</p><h2 id="욕실-바닥에-타일-깔기"><a href="#욕실-바닥에-타일-깔기" class="headerlink" title="욕실 바닥에 타일 깔기"></a>욕실 바닥에 타일 깔기</h2><p>사실 방금 풀어보았던 요일 맞추기 문제처럼 눈에 띄게 일정한 주기를 가지고 반복되는 숫자를 찾아내는 문제는 익숙해지는데 그렇게 오랜 시간이 걸리지는 않는다.</p><p>그러나 우리가 일상에서 겪는 대부분의 문제는 저렇게 패턴을 대놓고 보여주지 않는 경우가 많다.</p><p>이때 필요한 것이 문제를 분석하고 패턴을 찾아내는 일이다. 사실 주기성이라는 수의 성질을 이용할 수 있다는 것의 진짜 의의는 바로 <code>패턴</code>을 만들고 찾아낼 수 있다는 것에 있다. 이번에는 그 패턴을 이용하여 유효성을 검사하는 문제이다.</p><center><br>  <img src="/2019/10/30/make-simple-with-math/tile.png" width="500"><br>  <br><br></center><blockquote><p>에반은 타일 시공 업체에 취직해서 첫 욕실 바닥 시공을 하게 되었다.<br>그러나 에반은 실수로 가로 1cm, 세로 2cm의 직사각형 타일들만 챙겨나오게 되었다…</p><p>다행히 모든 욕실 바닥은 표준화가 되어있어서 가로 1cm, 세로 1cm의 정사각형 칸으로 이루어져있지만, 욕실 바닥 모양과 칸의 수는 모두 제각각이다.</p><p>에반은 자신의 직사각형 타일로 욕실 바닥을 빠짐없이 메꿔야하지만, 욕실 바닥의 모양에 따라 작업이 불가능한 곳도 있다.<br>게다가 에반은 힘이 없어서 타일을 반으로 쪼개서 사용할 수도 없다.</p><p>에반은 어떻게 작업의 가능 여부를 알 수 있을까?</p></blockquote><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> floor = [</span><br><span class="line">  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],</span><br><span class="line">  [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],</span><br><span class="line">  [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],</span><br><span class="line">  [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],</span><br><span class="line">  [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],</span><br><span class="line">  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],</span><br><span class="line">  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>이 문제의 경우, 타일로 욕실 바닥을 채울 수 있는 경우의 수를 하나씩 검사해볼 수도 있겠지만, 그렇게 풀어내기에는 워낙 경우의 수가 많기도 하고 로직도 복잡해질 것이 뻔하다.</p><p>그렇다면 욕실 바닥에 있는 칸의 개수를 세어보면 어떨까? 만약 칸의 개수가 홀수라면 에반이 가진 타일로는 절대 바닥을 채울 수가 없을 것이다.</p><p>하지만 이 문제에 나와있는 바닥의 총 칸 수는 슬프게도 <code>34</code>칸이다. 게다가 홀수, 짝수 여부만으로는 해당 타일로 전부 바닥을 채울 수 있을지는 장담할 수 없다. 조금 더 확실한 검증 방법이 없을까?</p><p>이 문제는 주기성과 전혀 관련이 없을 것 같지만, 사실 굉장히 간단한 패턴이 숨어있다. 바로 에반이 가지고 있는 타일이 두개의 칸으로 이루어져 있다는 것이다.</p><p>조금 더 생각을 쉽게 하기 위해 타일과 바닥에 색을 칠해보도록 하자.</p><center><br>  <img src="/2019/10/30/make-simple-with-math/tile-fill.png" width="500"><br>  <br><br></center><p>이렇게 색을 칠하고나니 에반이 가지고 있는 타일은 <code>검은색 1칸</code>과 <code>흰색 1칸</code>으로 이루어진 두 칸짜리 타일이 되었다. 즉, 만약 에반이 가지고 있는 타일로 욕실의 바닥을 빈틈없이 메꿀 수 있다면, 욕실 바닥의 검은색 칸의 수와 흰색 칸의 수가 같아야 한다는 것이다.</p><p>그러나 우리에게 주어진 욕실 바닥의 검은색 칸의 수는 <code>16</code>칸, 흰색 칸의 수는 <code>18</code>칸이다. 즉, 이 욕실 바닥은 에반이 가진 타일로는 채울 수 없는 바닥이라는 뜻이 된다.</p><p>이 문제는 단순히 두 칸으로 이루어진 에반의 타일에 <code>검은색</code>과 <code>흰색</code>이라는 주기성을 부여하여 풀어나가는 문제이다. 에반의 타일이 가지고 있는 색의 주기와 욕실 바닥의 주기가 동일하지 않다면 그 욕실 바닥은 <code>채울 수 없는 바닥</code>이 되는 것이다.</p><p>그럼 검은색 칸을 <code>-1</code>, 흰색 칸을 <code>1</code>으로 정의하고, 욕실 바닥의 해당 칸을 만날 때마다 <code>-1</code>과 <code>1</code>을 번갈아가며 더한 후 마지막에 값이 <code>0</code>이 되면 검은색 칸과 흰색 칸의 수가 동일하다고 생각할 수 있겠다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> floor = [</span><br><span class="line">  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],</span><br><span class="line">  [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],</span><br><span class="line">  [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],</span><br><span class="line">  [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],</span><br><span class="line">  [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],</span><br><span class="line">  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],</span><br><span class="line">  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],</span><br><span class="line">];</span><br><span class="line"><span class="hljs-keyword">const</span> tile = [<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">let</span> tileIndex = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">floor.forEach(<span class="hljs-function">(<span class="hljs-params">row, index</span>) =&gt;</span> &#123;</span><br><span class="line">  tileIndex = <span class="hljs-built_in">Number</span>(index % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>);</span><br><span class="line">  row.forEach(<span class="hljs-function"><span class="hljs-params">col</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (col === <span class="hljs-number">1</span>) &#123;</span><br><span class="line">      count += tile[tileIndex];</span><br><span class="line">    &#125;</span><br><span class="line">    tileIndex = tileIndex === <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`검은 타일과 흰 타일의 개수 차이는 <span class="hljs-subst">$&#123;<span class="hljs-built_in">Math</span>.abs(count)&#125;</span> 입니다.`</span>);</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">검은 타일과 흰 타일의 개수 차이는 2 입니다.</span><br></pre></td></tr></table></figure><p>각 <code>row</code>를 순회할 때 <code>tileIndex</code>를 다시 교정해주는 이유는, 이 행렬의 컬럼의 개수가 짝수이기 떄문이다. 타일의 주기 또한 짝수이기에 다음 줄에서는 이전 줄의 가장 마지막에 있던 타일의 색이 다시 한번 나오게 된다.<small>(컬럼을 홀수로 만들면 이 과정이 필요없는데, 문제 잘못 만들었다…)</small></p><p>문제만 보면 전혀 주기성과 관련이 없어보이는 문제였지만, 이렇게 문제 내에서 반복되는 패턴을 찾아내고 주기성을 부여함으로써 조금 더 간단한 방법으로 문제를 해결할 수 있다.</p><h2 id="한-붓-그리기-쾨니히스베르크의-다리-증명하기"><a href="#한-붓-그리기-쾨니히스베르크의-다리-증명하기" class="headerlink" title="한 붓 그리기, 쾨니히스베르크의 다리 증명하기"></a>한 붓 그리기, 쾨니히스베르크의 다리 증명하기</h2><p>쾨니히스베르크의 다리는 현대 위상 수학의 시작을 이끌었던 굉장히 유명한 문제로, 프로이센의 쾨니히스베르크<small>(현재 러시아 칼리닌그라드)</small>라는 도시에 있는 다리를 사용한 문제이다.</p><center><br>  <img src="/2019/10/30/make-simple-with-math/Konigsberg_bridges.png" width="500"><br>  <br><br></center><blockquote><p>쾨니히스베르크의 한 가운데에는 프레골라 강이 흐르고 있고, 여기에는 가운데의 섬들과 연결되어있는 7개의 다리가 있다.</p><p>임의의 지점에서 출발하여 이 다리들을 한 번씩만 건너서 모든 다리를 건널 수 있을까?</p></blockquote><p>즉, 한 붓 그리기 문제인 것이다. 이 문제를 그대로 보면 생각하기가 어려우니, 조금 더 그림을 단순하게 그리고 각 지역에 식별자를 부여한 후, 문제의 조건들을 정리해보도록 하자.</p><center><br>  <img src="/2019/10/30/make-simple-with-math/bridges.png" width="500"><br>  <br><br></center><blockquote><ul><li>임의의 지점에서 출발할 수 있다.</li><li>모든 다리를 건너야 한다.</li><li>한번 건넌 다리는 다시 건널 수 없다.</li><li>각 구역은 몇 번을 들리든 상관없다.</li><li>출발한 구역으로 다시 돌아와도 되고 안 돌아와도 상관없다.</li></ul></blockquote><p>사실 몇 번 펜으로 쭉쭉 그어보면 대충 불가능하다는 감이 온다. 하지만 <code>절대로 건널 수 없다</code>라는 결론을 내리기 위해서는 왜 불가능하다는 것인지 증명하는 과정이 필요하다. 혹시 방법이 있는데 단순히 못 찾을 것일수도 있으니 말이다.</p><p>우선 이 문제를 조금 더 쉽게 생각해보기 위해 복잡한 지도 모양의 그림이 아닌, 단순화된 그래프로 다시 그려보도록 하겠다.</p><center><br>  <img src="/2019/10/30/make-simple-with-math/graph.png" width="150"><br>  <br><br></center><p>이때 그래프 내에서 A, B, C, D 구역의 역할을 하는 점을 <code>정점(Vertex)</code>이라고 하고, a~g 다리의 역할을 하는 선을 <code>간선(edge)</code>라고 하며, 각 정점에 붙어있는 간선의 개수를 <code>차수(Degree)</code>라고 한다.</p><p>쾨니히스베르크의 문제에서 다리를 건넌다는 것은 어떤 한 정점에서 다른 정점으로 넘어가는 것을 의미하며, 한번 건넌 다리는 다시 건널 수 없다는 것은 다른 정점으로 넘어갈 때 사용한 간선을 삭제해야한다는 것을 의미한다.</p><p>다리를 건너 이동할 수 있는 케이스를 한번 쭉 살펴보면 대략 <code>처음 출발할 때</code>, <code>마지막 도착할 때</code>, <code>통과할 때</code>의 3가지 케이스로 분류해볼 수 있는데, 이 3가지 케이스에서 간선이 삭제되는 개수에는 패턴이 숨어있다.</p><p><strong>처음 출발할 때</strong></p><center><br>  <img src="/2019/10/30/make-simple-with-math/start.png" width="500"><br>  <br><br></center><p>어느 정점에서 출발하던 다른 정점으로 이동하는 경우는 출구 역할을 하는 간선만 삭제될 것이다. 즉, 출발 정점의 차수가 <code>1</code> 줄어든다.</p><p><strong>마지막 도착할 때</strong></p><center><br>  <img src="/2019/10/30/make-simple-with-math/end.png" width="500"><br>  <br><br></center><p>출발할 때와는 반대로, 도착하는 정점은 입구의 역할을 했던 간선만 삭제하면 되므로, 해당 정점의 차수는 <code>1</code> 줄어든다.</p><p><strong>통과할 때</strong></p><center><br>  <img src="/2019/10/30/make-simple-with-math/cross.png" width="500"><br>  <br><br></center><p>통과할 때는 <code>입구</code>의 역할을 하는 간선과 <code>출구</code>의 역할을 하는 간선을 삭제해야하므로, 해당 정점의 차수가 <code>2</code>씩 줄어든다.</p><p>즉, 어떤 그래프에서 한 붓 그리기가 성공했다는 것은 정점을 순회하다가 더 이상 건널 수 있는 간선이 없어졌을 때, 반드시 <code>모든 정점의 차수가 0이어야 한다는 것</code>이다. 만약 차수가 0이 아닌 정점이 존재한다면 그 정점에는 아직 건너지 않았던 간선이 연결되어 있다는 말이 되므로 한 붓 그리기는 실패한 것이 된다.</p><p>이때 우리는 각 정점의 차수가 <code>1</code>이나 <code>2</code> 씩 줄어들고 있다는 점에서 이 문제를 풀 수 있는 힌트를 얻을 수 있다.</p><h3 id="차수의-홀짝-여부에-집중하자"><a href="#차수의-홀짝-여부에-집중하자" class="headerlink" title="차수의 홀짝 여부에 집중하자"></a>차수의 홀짝 여부에 집중하자</h3><p>차수가 1씩 줄어드는 경우는 한번 수행될 때마다 차수의 홀짝 여부가 변경되고, 2씩 줄어드는 경우는 차수의 홀짝 여부가 절대 변하지 않는다.</p><p>정점 차수의 홀짝 여부를 이야기하고 있는 이유는 바로 <code>0이 짝수</code>이기 때문이다.</p><p>즉, 정점에서 출발, 도착, 통과 시 변하는 차수의 홀짝 패턴을 파악하면 모든 경우의 수를 그려보지 않더라도 간단하게 이 그래프가 한 붓 그리기가 가능한 그래프인지 아닌지 알 수 있다.</p><h3 id="출발지와-도착지가-같은-경우"><a href="#출발지와-도착지가-같은-경우" class="headerlink" title="출발지와 도착지가 같은 경우"></a>출발지와 도착지가 같은 경우</h3><p>우선 위에서 살펴본 바와 같이 중간에 통과하는 정점의 차수는 무조건 2씩 줄어들기 때문에 몇 번을 통과하든 차수의 홀짝 여부가 절대 변하지 않는다.</p><p>즉, 어떤 방식으로 건너든 통과 정점의 차수가 0이 되려면, 해당 정점의 차수는 처음부터 <code>짝수</code>여야한다는 것이다.</p><p>만약 통과 정점의 차수가 홀수라면 반드시 마지막에는 차수가 1이 되고, 이 간선을 타고 해당 정점에 도착하게되면 더 이상 남아있는 간선이 없기 떄문에 다른 정점으로 건너갈 수 없게 된다.</p><center><br>  <img src="/2019/10/30/make-simple-with-math/cant-get-out.jpg" width="350"><br>  <small>차수가 홀수인 통과 정점에 들어서면 맘대로 나갈 수 없다</small><br>  <br><br></center><p>또한 출발지와 목적지가 같은 경우에는 맨 처음 출발할 때 출발 정점의 차수를 <code>1</code> 줄이고 도착할 때 다시 <code>1</code>을 줄여야하기 때문에 해당 정점의 차수가 총 <code>2</code>만큼 줄어들게 된다.</p><p>이 경우에도 출발 정점의 차수는 홀짝 여부가 변경될 수 없기 때문에 반드시 처음부터 짝수인 차수를 가지고 있어야 한다는 말이 된다. 즉, 출발지와 도착지가 같은 경우 한 붓 그리기가 성공하려면 <code>모든 정점의 차수가 짝수</code>여야 한다는 결론이 나온다.</p><h3 id="출발지와-도착지가-다른-경우"><a href="#출발지와-도착지가-다른-경우" class="headerlink" title="출발지와 도착지가 다른 경우"></a>출발지와 도착지가 다른 경우</h3><p>출발지와 도착지가 다른 경우에도 통과 정점의 차수는 처음부터 짝수여야 한다는 점은 달라지지 않지만, 이번에는 출발지와 도착지가 다르기 때문에 출발 정점과 도착 정점의 차수는 반드시 <code>홀수</code>여야 한다는 점이 다르다.</p><p>중간에 통과하는 정점은 반드시 차수가 <code>2</code> 씩 줄어들기 때문에 홀짝이 변하지 않지만, 출발과 도착 시에는 차수가 <code>1</code>만 줄어들기 때문에 홀짝 여부가 변하기 때문이다.</p><p>즉, 출발지와 도착지가 다른 경우는 <code>출발지와 도착지는 홀수 차수, 그 외 정점은 짝수</code>여야한다.</p><h3 id="쾨니히스베르크의-다리는-왜-한-붓-그리기가-불가능할까"><a href="#쾨니히스베르크의-다리는-왜-한-붓-그리기가-불가능할까" class="headerlink" title="쾨니히스베르크의 다리는 왜 한 붓 그리기가 불가능할까?"></a>쾨니히스베르크의 다리는 왜 한 붓 그리기가 불가능할까?</h3><p>이 두 가지 조건을 정리해보자면 그래프의 정점을 순회하며 한 붓 그리기가 가능한 경우는 <code>모든 정점이 짝수 차수를 가지고 있거나 홀수 차수가 2개인 경우</code>라고 정리해볼 수 있다. 다시 쾨니히스베르크의 다리를 도식화한 그래프를 살펴보고 이 조건에 맞아떨어지는지 확인해보자.</p><center><br>  <img src="/2019/10/30/make-simple-with-math/graph.png" width="150"><br>  <br><br></center><p>이 그래프의 정점들의 차수를 정리해보면 <code>A=3, B=5, C=3, D=3</code>으로 모든 정점의 차수가 홀수이므로, 위에서 찾아낸 어떤 조건과도 맞지 않는다.</p><p>즉, 쾨니히스베르크의 다리는 한 붓 그리기가 불가능한 구조라는 것이 증명된 것이다.</p><p>그래프 이론에서 이렇게 한 붓 그리기, 즉, 그래프의 모든 경로를 단 한 번씩만 통과하는 경로를 <code>오일러 경로(Eulerian Trail)</code>라고 부르는데, 그 이유는 갓 레온하르트 오일러 형님이 이미 1735년에 이 문제를 증명하고 자기 논문에 써먹었기 때문이다.</p><p>해당 논문은 <a href="http://eulerarchive.maa.org//docs/originals/E053.pdf" rel="external nofollow noopener noreferrer" target="_blank">Solutio Problematis ad Geometriam Situs Pertinentis</a>에서 확인할 수 있지만… 제목에서도 느껴지듯이 이게 영어가 아니다. 이 시대의 가방끈 기신 분들이 작성한 논문이 다들 그러하듯 <code>라틴어</code>로 작성되어있기 때문에 읽어보는 건 사실 힘들다. 그래도 혹시 필자의 상상을 뛰어넘어 라틴어가 가능하신 굇수분들이 있을 수 있으니 일단 첨부하겠다.</p><p>어쨌든 오일러 형님의 문제 풀이에서 주목해야하는 아이디어는 각 정점의 차수를 조사할 때 차수 자체가 아닌 <code>수의 홀짝</code>에 주목했다는 점이다. 정점에서 출발할 때, 도착할 때, 통과할 때 정점이 가진 차수의 상태가 홀짝으로 변화하는 그 패턴을 파악하지 못했다면 이 문제를 해결하기는 힘들었을 것이다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>이번 포스팅에서 살펴본 3개의 문제는 어려운 수학 공식을 사용하는 문제가 아니다.</p><p>7일마다 반복되는 패턴에서 착안하여 $10^{100000000}$일 후의 요일도 뭔가 패턴이 있을 것이라는 추론, 두 칸짜리 타일을 보고 검은색과 흰색이 반복되는 패턴을 떠올릴 수 있는 것, 그래프 순회의 모든 경우의 수를 따져보지 않고 각 정점의 차수가 홀짝으로 변화하는 패턴을 생각해낼 수 있는 것 등은 복잡한 수학 공식을 모르더라도 수의 성질만 알고 있다면 누구든지 접근할 수 있는 문제 해결 방식이다.</p><p>이렇게 수의 근본적인 성질을 파악하고 이용하면 복잡한 문제를 단순하게 풀 수 있다. 슬픈 점은 이게 단순히 공부로 얻어질 수 있는 능력이 아니라는 것이다. 이런 능력을 키우기 위해서는, 그냥 이렇게 생각하는 연습을 많이 해야하는 것 같다.</p><p>코딩 테스트를 많이 풀어보는 것도 물론 좋지만, 일상 속에서 겪는 다양한 문제들 속에서 이렇게 패턴을 찾아내고 분석해보는 것도 나름 도움이 되지 않을까? 예를 들면 친구가 <code>11월 10일</code>에 약속을 잡자고 했는데, 그때가 무슨 요일인지 핸드폰으로 확인하는 것이 아니라 한번 직접 계산해본다던가 하는 식으로 말이다.</p><p>이상으로 수학과 함께 복잡한 문제를 단순하게 만들자! 포스팅을 마친다.</p>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/10/30/make-simple-with-math/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[JS 프로토타입] 프로토타입을 사용하여 상속하기</title>
      <link>https://evan-moon.github.io/2019/10/27/inheritance-with-prototype/</link>
      <guid>https://evan-moon.github.io/2019/10/27/inheritance-with-prototype/</guid>
      <pubDate>Sat, 26 Oct 2019 15:55:05 GMT</pubDate>
      <description>
      
        &lt;p&gt;이번 포스팅에서는 &lt;a href=&quot;/2019/10/23/js-prototype/&quot; title=&quot;이전 포스팅&quot;&gt;이전 포스팅&lt;/a&gt;에 이어, 프로토타입을 사용한 다양한 상속 패턴에 대한 이야기를 해볼까 한다.&lt;/p&gt;
&lt;p&gt;사실 자바스크립트에는 상속이나 캡슐화와 같은 개념이 명시적으로 존재하지는 않기 때문에 자바나 C++ 같은 클래스 기반 언어를 사용하던 개발자들은 자바스크립트에 클래스가 없다는 사실에 혼란스러워한다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>이번 포스팅에서는 <a href="/2019/10/23/js-prototype/" title="이전 포스팅">이전 포스팅</a>에 이어, 프로토타입을 사용한 다양한 상속 패턴에 대한 이야기를 해볼까 한다.</p><p>사실 자바스크립트에는 상속이나 캡슐화와 같은 개념이 명시적으로 존재하지는 않기 때문에 자바나 C++ 같은 클래스 기반 언어를 사용하던 개발자들은 자바스크립트에 클래스가 없다는 사실에 혼란스러워한다.</p><a id="more"></a><p>즉, 자바스크립트에서의 상속이나 캡슐화 등은 <code>OOP(객체지향프로그래밍)</code>에 익숙한 개발자들이 자바스크립트에서도 이런 개념들을 가져다 사용하기 위해 프토토타입을 사용하여 이를 유사하게 구현한 일종의 디자인 패턴이라고 할 수 있다.</p><p>자바스크립트에서의 상속은 프로토타입 체인을 사용하여 구현하고, 캡슐화는 클로저를 사용해서 구현하게 되는데, 이번 포스팅에서는 이 중 프로토타입을 사용한 상속 패턴에 집중해서 설명해볼까 한다.</p><h2 id="프로퍼티와-메소드는-원본-객체를-통해-공유될-수-있다"><a href="#프로퍼티와-메소드는-원본-객체를-통해-공유될-수-있다" class="headerlink" title="프로퍼티와 메소드는 원본 객체를 통해 공유될 수 있다"></a>프로퍼티와 메소드는 원본 객체를 통해 공유될 수 있다</h2><p>객체의 상속을 알아보기 전에 객체를 생성할 때 프로퍼티와 메소드를 부여하는 방법에 대해서 알아보도록 하자. <a href="/2019/10/23/js-prototype/" title="이전 포스팅">이전 포스팅</a>에서 필자는 자바스크립트는 클래스가 아닌 <code>함수</code>를 사용하여 객체를 생성한다고 이야기 했었다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span> (<span class="hljs-params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="hljs-keyword">const</span> evan = <span class="hljs-keyword">new</span> User();</span><br></pre></td></tr></table></figure><p>이때 <code>User</code> 함수를 생성자로 호출하면서 생성된 <code>evan</code> 객체는 <code>User.prototype</code> 객체를 원본 객체로 하여 복제된 객체이다.</p><p>이때 두 가지 방법을 사용하여 새롭게 생성되는 객체들에게 프로퍼티나 메소드를 부여할 수 있는데, 첫 번째는 생성자 함수 내에서 <code>this</code>를 사용하여 선언하는 방법, 두 번째는 새롭게 생성되는 객체들이 복사할 원본 객체인 <code>프로토타입 객체</code>에 선언하는 방법이다.</p><p>먼저, <code>this</code>를 사용하여 프로퍼티나 메소드를 정의하는 방법에 대해서 살펴보자.</p><h3 id="생성자-함수-내에서-this를-사용하는-방법"><a href="#생성자-함수-내에서-this를-사용하는-방법" class="headerlink" title="생성자 함수 내에서 this를 사용하는 방법"></a>생성자 함수 내에서 this를 사용하는 방법</h3><p>자바스크립트도 생성자 역할을 하는 함수 내에서 <code>this</code>를 사용하여 다른 언어와 비슷한 느낌으로 객체들에게 프로퍼티나 메소드를 부여할 수 있다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span> (<span class="hljs-params">name</span>) </span>&#123;</span><br><span class="line"><span class="hljs-meta">  'use strict'</span>;</span><br><span class="line">  <span class="hljs-keyword">this</span>.say = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, World!'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> evan = <span class="hljs-keyword">new</span> User();</span><br><span class="line"><span class="hljs-built_in">console</span>.log(evan.say());</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br></pre></td></tr></table></figure><p>참고로 생성자 함수 내에서 <code>strict</code> 모드를 사용한 이유는, 해당 생성자 함수가 실수로 <code>new</code> 예약어 없이 호출되어 <code>this</code>가 전역 객체로 평가되는 불상사를 방어하기 위해서이다.<small>(이 내용은 프로토타입과는 관련이 없기 때문에 자세히 다루지는 않겠다)</small></p><p>이 방법은 일반적인 생성자의 사용 방법과 비슷해서 직관적으로 이해가 되는 편이다. 이때 생성자 함수 안의 <code>this</code>는 새롭게 생성된 객체를 의미하기 때문에, 함수 내에서 <code>this</code>를 통해 정의한 프로퍼티나 메소드는 이 생성자 함수를 사용하여 객체가 생성될 때마다 새롭게 정의된다.</p><p>무슨 말인지 조금 더 쉽게 알아보기 위해 생성자 함수를 통해 두 개의 새로운 객체를 생성하고, 이 객체들의 메소드를 비교해도록 하자.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> evan = <span class="hljs-keyword">new</span> User();</span><br><span class="line"><span class="hljs-keyword">const</span> john = <span class="hljs-keyword">new</span> User();</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(evan.say === john.say);</span><br></pre></td></tr></table></figure><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-literal">false</span></span><br></pre></td></tr></table></figure><p>생성자 함수가 호출될 때 <code>this</code>는 각각 <code>evan</code> 객체와 <code>john</code> 객체를 의미했을 것이고, <code>say</code> 메소드 또한 이 객체들에게 직접 할당되었을 것이다. 자바스크립트의 <code>완전할당연산자(===)</code>는 다른 메모리에 적재된 객체는 다르다고 평가하므로 이 두 객체의 메소드들은 각자 다른 메모리에 담긴, 전혀 다른 함수라고 할 수 있다.</p><p>이때 <code>evan</code> 객체나 <code>john</code> 객체를 출력해보면, 객체 내부에 <code>say</code> 메소드가 정의되어 있는 모습 또한 확인해볼 수 있다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(evan);</span><br></pre></td></tr></table></figure><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User &#123;<span class="hljs-attr">say</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>&#125;</span></span><br></pre></td></tr></table></figure><p>이 당연한 이야기를 하는 이유는 바로 밑에서 후술할 <code>프로토타입 객체에 정의하는 방법</code>과 차이점을 분명히 하기 위해서이다. 프로토타입 객체를 사용해서 프로퍼티나 메소드를 정의하게되면 지금과는 전혀 다른 결과가 나온다.</p><h3 id="프로토타입-객체에-정의하는-방법"><a href="#프로토타입-객체에-정의하는-방법" class="headerlink" title="프로토타입 객체에 정의하는 방법"></a>프로토타입 객체에 정의하는 방법</h3><p>이번에는 <code>User</code> 생성자 함수의 프로토타입 객체인 <code>User.prototype</code>을 사용하여 메소드를 한번 정의해보도록 하자. <code>this</code>를 통해서 정의하는 방법과 어떤 차이가 있을까?</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span> (<span class="hljs-params">name</span>) </span>&#123;&#125;</span><br><span class="line">User.prototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello, World!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> evan = <span class="hljs-keyword">new</span> User();</span><br><span class="line"><span class="hljs-built_in">console</span>.log(evan.say());</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br></pre></td></tr></table></figure><p>일단 <code>this</code>를 사용하여 정의했던 메소드와 동일한 느낌으로 작동하고 있다. 그래서 동일한 동작이라고 생각할 수도 있지만, 사실 두 방법들 사이에는 중요한 차이가 존재한다.</p><p>바로 생성자 함수를 통해 생성된 모든 객체들이 해당 메소드를 <code>공유하고 있냐, 없냐</code>의 차이이다. 이전과 마찬가지로 두 개의 객체를 생성하고, 두 객체의 메소드를 비교해보자.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> evan = <span class="hljs-keyword">new</span> User();</span><br><span class="line"><span class="hljs-keyword">const</span> john = <span class="hljs-keyword">new</span> User();</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(evan.say === john.say);</span><br></pre></td></tr></table></figure><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-literal">true</span></span><br></pre></td></tr></table></figure><p>음? 이번에는 아까와는 다르게 두 객체의 메소드가 같다고 한다. 방금 전과는 다르게 이번에는 <code>evan.say</code>와 <code>john.say</code>가 객체에 따로따로 정의된 메소드가 아닌, 원본 객체의 메소드를 공유하고 있는 상황이기 때문이다.</p><p>생성된 <code>evan</code> 객체를 한번 콘솔에 출력해보면, 원본 객체의 프로퍼티나 메소드를 공유하고 있다는 말이 무엇인지 알 수 있다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(evan);</span><br></pre></td></tr></table></figure><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>evan</code> 객체를 출력해보니, 이 객체는 아무 메소드나 프로퍼티도 가지고 있지 않고 텅 비어있는 친구다.</p><p>즉, 생성자 함수 내에서 <code>this</code>를 사용하지 않고, 원본 객체에 메소드나 프로퍼티를 정의하게 되면 객체들에게는 해당 프로퍼티가 없고, 원본 객체의 프로퍼티나 메소드를 참조한다는 것이다.</p><p>이 특징을 제대로 인지하지 못하면 이런 상황도 발생할 수 있다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User.prototype.name = <span class="hljs-string">'Evan'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(evan.name);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(john.name);</span><br></pre></td></tr></table></figure><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Evan</span><br><span class="line">Evan</span><br></pre></td></tr></table></figure><p>그렇기 때문에 각 객체마다 고유한 프로퍼티를 부여하고 싶다면 원본 객체에 정의하는 것이 아니라, 생성자 함수 내에서 <code>this</code>를 사용하여 정의해야한다. 다시 말하지만 원본 객체에 정의한 프로퍼티나 메소드는 생성된 객체들 끼리 <code>공유</code>된다.</p><p>한 가지 이상한 점은, 분명히 <code>evan</code> 객체에는 아무런 프로퍼티나 메소드도 없었는데, 필자는 분명히 <code>evan.say</code>를 통해 해당 메소드에 접근할 수 있었다는 것이다. 어떻게 이런 일이 가능한 것일까?</p><h2 id="프로토타입-룩업"><a href="#프로토타입-룩업" class="headerlink" title="프로토타입 룩업"></a>프로토타입 룩업</h2><p>그 질문에 대한 해답은 바로 자바스크립트가 객체 내에서 프로퍼티를 찾는 방법 중 하나인 <code>프로토타입 룩업(Prototype Lookup)</code>에서 알아볼 수 있다. 방금 전 자바스크립트가 <code>evan</code> 객체에서 <code>say</code> 메소드를 찾아냈던 과정은 다음과 같다.</p><center><br>  <img src="/2019/10/27/inheritance-with-prototype/prototype_lookup.png" width="500"><br>  <br><br></center><blockquote><ol><li><code>evan.say</code>로 접근 시도</li><li>어, <code>say</code> 프로퍼티가 없네? <code>__proto__</code>를 통해 원본 객체로 올라가보자!</li><li><code>User.prototype</code>객체야, 너는 <code>say</code> 프로퍼티 가지고 있니?</li><li>있네? Profit!</li></ol></blockquote><p>이런 식으로 우리가 어떤 객체의 프로퍼티에 접근을 시도했을 때, 자바스크립트는 먼저 그 객체가 해당 프로퍼티를 가지고 있는지를 확인하고, 해당 프로퍼티가 없다면 그 객체의 원본 객체로 거슬러 올라가서 다시 확인하게 된다.</p><p>이 집요한 확인 과정은 모든 객체의 조상인 <code>Object.prototype</code>에 다다를 때까지 계속되고, 만약 여기에도 존재하지 않는 프로퍼티라면 그때서야 <code>undefined</code>를 반환하게 된다.</p><p>이 말인 즉슨, 모든 객체는 자신의 프로토타입 체인 내에 있는 모든 원본 객체들의 프로퍼티나 메소드에 접근할 수 있다는 뜻이다.</p><p>쉽게 말해, 방금 생성한 <code>evan</code> 객체는 아무 프로퍼티나 메소드도 가지고 있지 않지만, 자신의 원본 객체인 <code>User.prorotype</code>에 정의된 <code>say</code> 메소드도 사용할 수 있고, <code>Object.prototype</code>에 있는 <code>toString</code>이나 <code>hasOwnProperty</code>와 같은 메소드도 사용할 수 있다는 것이다.</p><center><br>  <img src="/2019/10/27/inheritance-with-prototype/prototype_lookup2.png" width="150"><br>  <small>evan 객체는 프토토타입 체인 내에 있는 모든 원본 객체의 프로퍼티를 공유받는다</small><br>  <br><br></center><p>이 프로토타입 룩업 과정은 객체의 프로퍼티나 메소드에 접근하는 그 순간마다 수행되기 때문에, 클래스가 정의될 때 모든 상속관계가 함께 평가되는 클래스 기반 언어의 상속과는 조금 다른 느낌이다.</p><p>그러나 추상적으로 생각해보면 원본 객체(부모)의 속성을 물려받고 있다는 점에서 착안하여, 프로토타입 룩업을 토대로 상속을 구현할 수 있다.</p><h2 id="프로토타입을-사용한-상속"><a href="#프로토타입을-사용한-상속" class="headerlink" title="프로토타입을 사용한 상속"></a>프로토타입을 사용한 상속</h2><p>자바스크립트에서 프로토타입을 사용하여 상속을 구현하는 방법은 크게 <code>Object.create</code> 메소드를 사용하는 방법과 이 메소드를 사용하지않는 <small>(더러운)</small> 방법, 두 가지로 나누어질 수 있다.</p><p>사실 <code>Object.create</code>만 사용해도 프로토타입을 사용한 상속은 충분히 구현이 가능하다. 하지만 굳이 두 가지를 나눠서 이야기한 이유는, <code>Object.create</code> 메소드가 <code>Internet Explorer 9</code>부터 지원이 되기 때문이다.</p><p>하지만 필자는 필자의 행복을 위해 쓰는 포스팅에서 <code>IE 8</code> 이하 환경에 대한 자세한 이야기는 별로 하고 싶지 않으므로 <code>Object.create</code>를 사용하지 않는 방법에 대한 코드를 간단하게 <a href="https://gist.github.com/evan-moon/a7e5a51e20d22016ea443a03480765b7" rel="external nofollow noopener noreferrer" target="_blank">필자의 Github Gist 링크</a>로 첨부하겠다.</p><h3 id="Object-create를-사용하자"><a href="#Object-create를-사용하자" class="headerlink" title="Object.create를 사용하자"></a>Object.create를 사용하자</h3><p><code>Object.create</code> 메소드는 첫 번째 인자로 생성할 객체의 원본 객체가 될 객체, 두 번째 인자로 새로 생성할 객체에 추가할 프로퍼티를 객체 타입으로 받는다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">Object</span>.create(proto: <span class="hljs-built_in">Object</span>, properties?: <span class="hljs-built_in">Object</span>);</span><br></pre></td></tr></table></figure><p>이때 두 번째 인자는 선택사항이며, 단순하게 <code>{ test: 1 }</code>처럼 넘기는 것이 아니라, <code>Object.defineProperties</code> 메소드를 사용할 때 처럼 데이터 서술자와 접근 서술자를 지정해줘야한다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">Object</span>.create(User.prototype, &#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    configurable: <span class="hljs-literal">false</span>,</span><br><span class="line">    enumerable: <span class="hljs-literal">true</span>,</span><br><span class="line">    value: <span class="hljs-string">'I am Foo!'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>자세한 프로퍼티들의 의미는 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties" rel="external nofollow noopener noreferrer" target="_blank">MDN Web Docs: Object.defineProperties</a>에서 확인해보도록 하자.</p><p>이 메소드에서 중요한 포인트는 <code>객체의 프로토타입 객체</code>를 지정할 수 있다는 것이며, 이 말인 즉슨 객체의 프로토타입 체인을 내 맘대로 만져줄 수 있다는 것이다. 심지어 동적으로 변경도 가능하다.<small>(사실 이게 JS의 변태적인 면…)</small></p><p>그럼 이제 <code>Object.create</code> 메소드와 프로토타입을 사용하여 상속을 한번 구현해보도록 하자.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperClass</span> (<span class="hljs-params">name</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">SuperClass.prototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`I am <span class="hljs-subst">$&#123;<span class="hljs-keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>우선 부모 클래스 역할을 할 <code>SuperClass</code> 생성자 함수를 생성하고, 이 함수의 프로토타입 객체에 <code>say</code> 메소드를 정의했다. 그럼 이제 자식 클래스 역할을 할 생성자 함수를 구현하고, 이 두 개의 함수의 상속 관계도 함께 정의해보자.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubClass</span> (<span class="hljs-params">name</span>) </span>&#123;</span><br><span class="line">  SuperClass.call(<span class="hljs-keyword">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line">SubClass.prototype = <span class="hljs-built_in">Object</span>.create(SuperClass.prototype);</span><br><span class="line">SubClass.prototype.constructor = SubClass;</span><br><span class="line">SubClass.prototype.run = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-keyword">this</span>.name&#125;</span> is running`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>뭘 이것저것 많이 만진 것 같지만, 막상 하나하나 뜯어보면 별 거 없다.</p><p><strong>SuperClass.call(this)</strong><br><code>Function.prototype.call</code> 메소드는 호출된 함수의 실행 컨텍스트를 첫 번째 인자로 받은 녀석으로 변경한다. 즉, <code>this</code>의 타겟을 변경하는 것이다.</p><p>즉, <code>SuperClass.call(this, name)</code>의 의미는 부모 생성자 함수의 생성자를 호출하되, 실행 컨텍스트를 자식 생성자 함수로 변경하라는 의미이다. 자바로 치면 <code>super</code> 메소드를 호출하는 것과 비슷한 느낌이랄까.</p><p>필자는 이때 <code>call</code> 메소드를 사용했지만, 뭐가 됐든 부모 생성자 함수의 실행 컨텍스트만 변경해주면 장땡이기 때문에 <code>apply</code>나 <code>bind</code> 메소드를 사용해도 상관없다.</p><p><strong>SubClass.prototype 변경</strong><br>그 후 <code>Object.create</code> 메소드를 사용하여 <code>SuperClass.prototype</code> 객체를 원본 객체로 하는 새로운 객체를 생성하고, 이 객체를 <code>SubClass</code>의 프로토타입 객체로 할당해준다. 자식 생성자 함수의 프로토타입 객체와 부모 생성자 함수의 프로토타입 객체 간의 프로토타입 체인, 쉽게 말해 부모 자식 관계를 만들어 주는 것이다.</p><p><strong>SubClass.prorotype.constructor 변경</strong><br>우리는 부모 생성자 함수의 프로토타입 객체를 토씨 하나 안바꾸고 그대로 복제했기 때문에, 새롭게 생성한 자식 생성자 함수의 프로토타입 객체의  <code>constructor</code> 프로퍼티는 여전히 부모 생성자 함수인 <code>SuperClass</code>를 참조하고 있다.</p><p>하지만 자식 생성자 함수인 <code>SubClass</code>를 통해 생성된 객체가 <code>SuperClass</code>를 사용하여 생성된 것처럼 처리되면 안되므로, 다시 <code>constructor</code> 프로퍼티를 <code>SubClass</code>로 변경해줘야한다.</p><p>이런 과정들을 거치면 다음과 같은 관계가 성립된다.</p><center><br>  <img src="/2019/10/27/inheritance-with-prototype/extends.png" width="500"><br>  <br><br></center><p>이제 한번 <code>SubClass</code> 생성자 함수를 사용하여 객체를 생성해보고, 제대로 부모 생성자 함수의 속성들을 물려받았는지 확인해보자.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> evan = <span class="hljs-keyword">new</span> SubClass(<span class="hljs-string">'Evan'</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(evan);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(evan.__proto__);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(evan.__proto__.__proto__)</span><br></pre></td></tr></table></figure><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SubClass &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">'Evan'</span> &#125; <span class="hljs-comment">// 에반 객체</span></span><br><span class="line">SubClass &#123; <span class="hljs-attr">constructor</span>: [<span class="hljs-built_in">Function</span>: SubClass], <span class="hljs-attr">run</span>: [<span class="hljs-built_in">Function</span>] &#125; <span class="hljs-comment">// 에반 객체의 원본 객체</span></span><br><span class="line">SuperClass &#123; <span class="hljs-attr">say</span>: [<span class="hljs-built_in">Function</span>] &#125; <span class="hljs-comment">// 에반 객체의 원본 객체의 원본 객체</span></span><br></pre></td></tr></table></figure><p><code>evan</code> 객체는 <code>SubClass</code>의 프로토타입 객체를 복제해서 정상적으로 생성되었고, <code>evan</code> 객체의 원본 객체와 원본 객체의 원본 객체도 잘 체이닝되어있다.</p><p>즉, <code>evan -&gt; SubClass.prototype -&gt; SuperClass.prototype</code>으로 이어지는 프로토타입 체인이 완성된 것이다. 이때 <code>evan</code> 객체의 <code>run</code>이나 <code>say</code> 메소드를 호출하면, 위에서 언급한 프로토타입 룩업을 통해 원본 객체의 메소드를 호출할 수 있다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p><a href="/2019/10/23/js-prototype/" title="이전 포스팅">이전 포스팅</a>에 이어 이번에는 자바스크립트에서 프로토타입을 활용한 상속 패턴에 대한 내용을 한번 다뤄보았다.</p><p>솔직히 말해서, 필자가 실무에서 이러한 패턴을 사용해서 상속을 구현해본 경험은 거의 없다. 필자가 개발자로 일을 시작하고 얼마 되지 않아 ES6가 나오기도 했었고, 필자는 당시 자바가 더 익숙했기 때문에 새로 추가된 <code>class</code> 키워드에 흠뻑 빠져있었다.</p><p>하지만 일을 시작하고 몇 년이 지나면서 레거시 코드에서 이 상속 패턴을 꽤 마주치기도 했고, 면접에서 이런 패턴에 대해서 물어보는 경우도 있었기 때문에 확실히 공부할 필요는 있는 것 같다.</p><p>아무리 요즘 ES5를 거의 사용하지 않는다고 하지만, 사실 이런 상속 패턴이 자바스크립트를 사용한 프로그램 아키텍처의 근간이기도 하니 말이다.</p><p>이상으로 프로토타입을 사용하여 상속하기 포스팅을 마친다.</p>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/10/27/inheritance-with-prototype/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[JS 프로토타입] 자바스크립트의 프로토타입 훑어보기</title>
      <link>https://evan-moon.github.io/2019/10/23/js-prototype/</link>
      <guid>https://evan-moon.github.io/2019/10/23/js-prototype/</guid>
      <pubDate>Wed, 23 Oct 2019 12:29:01 GMT</pubDate>
      <description>
      
        &lt;p&gt;이번 포스팅에서는 자바스크립트(JavaScript)하면 빠질 수 없는 &lt;code&gt;프로토타입(Prototype)&lt;/code&gt;에 대해서 한번 이야기해보려고 한다.&lt;/p&gt;
&lt;p&gt;프로토타입은 자바스크립트를 ES5 시절부터 사용해오던 분들에게는 매우 익숙하지만 ES6부터 시작하신 분들은 대부분 클래스를 사용하기 때문에 익숙한 개념은 아닐 것이라고 생각한다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>이번 포스팅에서는 자바스크립트(JavaScript)하면 빠질 수 없는 <code>프로토타입(Prototype)</code>에 대해서 한번 이야기해보려고 한다.</p><p>프로토타입은 자바스크립트를 ES5 시절부터 사용해오던 분들에게는 매우 익숙하지만 ES6부터 시작하신 분들은 대부분 클래스를 사용하기 때문에 익숙한 개념은 아닐 것이라고 생각한다.</p><a id="more"></a><p>필자가 처음 프론트엔드 개발을 시작했을때는 자바스크립트의 <code>ES5</code> 버전에서 막 <code>ES6</code>로 넘어가고 있던 시절이었는데, 기존에는 자바(Java)를 주로 사용하고 있던 필자가 프론트엔드 개발로 넘어오면서 제일 애먹었던 부분이 바로 이 프로토타입이었다.<small>(물론 애먹는 건 현재진행형이다)</small></p><p>물론 지금은 자바스크립트의 위상이 많이 올라가면서 프로토타입 패턴에 대한 관심도 많아지기 시작했지만, 그래도 당시나 지금이나 여전히 주류는 C 계열 언어나 Java에서 사용하는 클래스를 기반으로한 객체 생성 방식이다. </p><p>그래서 자바스크립트를 처음 접하는 개발자에게 프로토타입 기반 프로그래밍은 상대적으로 낯선 방식일 수 밖에 없고, 이로 인해 기존 개발자들이 자바스크립트로 진입하는데 어려움이 있었다. 그런 이유로 ES6에서는 <code>class</code> 예약어가 등장한 것이다.</p><p>사실 필자도 아직 클래스 기반의 객체 생성 방식이 익숙하기 때문에 프로토타입에 대한 공부가 더 필요하다.</p><p>그래서 이번 포스팅에서는 프로토타입 패턴이 무엇인지, 자바스크립트 내에서 프로토타입이 어떤 방식으로 사용되고 있는지에 집중해서 한번 이야기해보려고 한다.</p><h2 id="ES6부터-클래스를-지원하는데도-프로토타입을-굳이-알아야-하나요"><a href="#ES6부터-클래스를-지원하는데도-프로토타입을-굳이-알아야-하나요" class="headerlink" title="ES6부터 클래스를 지원하는데도 프로토타입을 굳이 알아야 하나요?"></a>ES6부터 클래스를 지원하는데도 프로토타입을 굳이 알아야 하나요?</h2><p>자바스크립트는 ES6부터 <code>class</code> 키워드를 사용하여 클래스를 지원하고 있다. 정확히 말하면 프로토타입으로 클래스를 흉내내서 구현한 것이라고 말하는 것이 맞다.</p><p>그런 이유로 많은 개발자들이 자바스크립트의 클래스를 단순한 <code>문법 설탕(Syntactic Sugar)</code>라고 이야기하지만, 사실 개인적으로 자바스크립트의 클래스는 ES5 시절 프로토타입을 사용하여 객체를 생성했던 방법보다 더 엄격한 제약을 가지고 있기 때문에 단순한 문법 설탕이라기보다는 <code>상위 요소(Superset)</code>라고 하는게 맞지 않나 싶다.</p><p>그러면 그냥 클래스를 쓰면 되는데 왜 프로토타입을 알아야 하는 것일까?</p><p>그 이유는 ES6에서 <code>class</code> 키워드를 통해 클래스를 지원하고 있기는 하지만, 이건 자바스크립트가 클래스 기반 언어가 되었다는 의미는 아니기 때문이다. 결국 자바스크립트 안에서의 클래스는 클래스의 탈을 쓴 프로토타입이다.</p><p>그리고 예전에 작성된 레거시 프론트엔드 코드의 경우에는 ES5로 작성된 것도 많기 때문에 아직까지 프론트엔드 개발자들은 ES5를 만져야하는 경우가 왕왕 있는 것이 현실이다. 물론 ES5를 ES6 이상의 버전으로 마이그레이션하려고 해도 기존의 프로토타입 기반의 객체 생성이나 상속이 구현된 코드를 이해할 수 없다면 마이그레이션 또한 불가능하다.</p><h2 id="프로토타입은-디자인-패턴이다"><a href="#프로토타입은-디자인-패턴이다" class="headerlink" title="프로토타입은 디자인 패턴이다"></a>프로토타입은 디자인 패턴이다</h2><p><code>프로토타입</code>이라고 하면 일반적으로 자바스크립트를 떠올리지만, 사실 프로토타입은 자바스크립트에서만 사용되는 것은 아니고, 그냥 일종의 디자인 패턴 중 하나이다. 자바스크립트 뿐만 아니라 <code>ActionScript</code>, <code>Lua</code>, <code>Perl</code> 등 프로토타입 기반 프로그래밍을 지원하는 다른 언어도 많다.</p><p>그래서 자바스크립트의 프로토타입을 자세히 알아보기 전에 디자인 패턴으로써의 프로토타입을 먼저 알아볼까 한다.</p><p>프로토타입 패턴은 <code>객체를 효율적으로 생성하는 방법</code>을 다루는 패턴 중 하나인데, 주로 객체를 생성하는 비용이 클 때 이를 회피하기 위해 사용된다.</p><p>객체를 생성할 때의 비용이 크다는 말은, 말 그대로 객체를 생성할 때마다 뭔가 일을 많이 해야한다는 뜻이다.</p><p>예를 들어 RPG 게임의 캐릭터를 하나 구현해본다고 생각해보자. 이 캐릭터는 여러가지 장비를 장착할 수 있는 기능을 가지고 있는데, 처음 캐릭터가 생성될 때 딸랑 맨 몸으로 시작하면 유저들이 싫어할 것 같으니 기본적인 장비 몇 가지를 장착한 상태로 생성될 수 있도록 만들어주려고 한다.</p><figure class="highlight java hljs"><figcaption><span>Player.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Weapon</span> </span>&#123;&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Armor</span> </span>&#123;&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicSward</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Weapon</span> </span>&#123;&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicArmor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Armor</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">public</span> Weapon weapon;</span><br><span class="line">    <span class="hljs-keyword">public</span> Armor armor;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Player</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.weapon = <span class="hljs-keyword">new</span> BasicSward(); <span class="hljs-comment">// 초심자의 목도</span></span><br><span class="line">        <span class="hljs-keyword">this</span>.armor = <span class="hljs-keyword">new</span> BasicArmor(); <span class="hljs-comment">// 초보자용 갑주</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>간단하게 만들어보면 대충 이런 느낌이다. <code>Player</code> 객체는 자신이 생성될 때 <code>BasicSward</code> 객체와 <code>BasicArmor</code> 객체까지 함께 생성해야한다.</p><p>이런 경우 그냥 <code>Player</code> 객체만 생성하는 상황보다는 <code>객체의 생성 비용이 높다</code>고 할 수 있다. 게다가 캐릭터 생성 시 처음 부여하는 아이템의 종류가 많아질수록 <code>Player</code>의 객체의 생성 비용 또한 계속 높아질 것이다.</p><p>음… 근데 곰곰히 생각해보니 캐릭터가 처음 생성되며 가지고 있는 아이템이 항상 같다는 전제 조건이 있다면 생성 비용이 높은 <code>Player</code>객체를 딱 한번만 생성하고 그 다음부터는 생성된 객체를 복사해서 사용해도 될 것 같다는 생각이 든다.</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 이건 너무 객체 생성 비용이 높으니까...</span></span><br><span class="line">Player evan = <span class="hljs-keyword">new</span> Player();</span><br><span class="line">Player john = <span class="hljs-keyword">new</span> Player();</span><br><span class="line">Player wilson = <span class="hljs-keyword">new</span> Player();</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 이런 방법으로 접근해보는 것은 어떨까?</span></span><br><span class="line">Player player = <span class="hljs-keyword">new</span> Player();</span><br><span class="line">Player evan = player.clone();</span><br><span class="line">Player john = player.clone();</span><br><span class="line">Player wilson = player.clone();</span><br></pre></td></tr></table></figure><p>이런 관점으로 접근하는 것이 바로 프로토타입 패턴이라고 할 수 있다. 프로토타입, 즉 <code>원본 객체</code>가 존재하고 그 객체를 복제해서 새로운 객체를 생성하는 방법인 것이다.</p><p>실제로 자바에서 프로토타입 패턴을 사용할때, 복제 대상이 되는 클래스는 보통 <code>Cloneable</code> 인터페이스를 사용하여 구현한다. Cloneable 인터페이스에는 <code>clone</code> 메소드가 정의되어 있기 때문에, 이 인터페이스를 사용하는 클래스는 반드시 <code>clone</code> 메소드를 오버라이딩해서 구현해야한다.</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//...</span></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Player <span class="hljs-title">clone</span> <span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> (Player)<span class="hljs-keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>clone</code> 메소드를 구현하고나면 이제 <code>Player</code> 객체는 복사 가능한 객체가 된다. 즉, 다른 객체들의 원본 객체가 될 수 있는 기능을 가지게 되었다는 것이다.</p><p>이제부터는 <code>Player</code> 객체를 추가로 생성하고 싶을 때는 기존에 생성되어 있던 객체를 그대로 복사하면 되기 때문에 높은 객체 생성 비용이 드는 것을 피할 수 있다.</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Player evan = <span class="hljs-keyword">new</span> Player();</span><br><span class="line">Player evanClone = evan.clone();</span><br></pre></td></tr></table></figure><p>또한 <code>Player</code> 객체는 복사되어 새로운 메모리 공간을 할당받지만, 깊은 복사를 하지 않는 이상 <code>Player</code>객체가 가지고 있는 <code>BasicSward</code> 객체와 <code>BasicArmor</code> 객체는 새롭게 생성되지 않고 기존에 이 객체들이 할당된 메모리 공간을 참조하기만 한다.</p><p>즉, 잘만 쓴다면 메모리 공간을 아낄 수도 있다는 것이다. 자바스크립트에서 원시 자료형은 <code>Call by value</code>, 그 외 자료형은 <code>Call by reference</code>를 사용하는 것과 동일한 원리이다.</p><p>여기까지 듣고 나서 예상하신 분들도 있겠지만, 그 말인 즉슨 잠깐 정신줄 놓고 코딩하다보면 이런 슬픈 상황도 발생할 수 있다는 뜻이다.</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Player evan = <span class="hljs-keyword">new</span> Player();</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">    Player evanClone = evan.clone();</span><br><span class="line">    evanClone.weapon.attackPoint = <span class="hljs-number">40</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="hljs-string">"에반 무기 공격력 -&gt; "</span> + evan.weapon.attackPoint);</span><br><span class="line">    System.out.println(<span class="hljs-string">"에반 복사본 무기 공격력 -&gt; "</span> + evanClone.weapon.attackPoint);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.err.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">에반 무기 공격력 -&gt; 40</span><br><span class="line">에반 복사본 무기 공격력 -&gt; 40</span><br></pre></td></tr></table></figure><center><br>  <img src="/2019/10/23/js-prototype/overtime_work.jpg" width="400"><br>  <small>디버깅 지옥이 펼쳐진다…</small><br>  <br><br></center><p>정리해보자면 프로토타입 패턴이란, <code>객체를 생성할 때 원본이 되는 객체를 복사해서 생성하는 패턴</code>이라고 할 수 있다.</p><p>물론 자바스크립트의 프로토타입은 단순히 몇 개의 객체가 복제 관계를 가지는 것이 아니라, 자바스크립트 내의 모든 객체 전체가 복제 관계로 얽혀있기 때문에 이것보다는 약간 더 복잡하긴 하지만, 근본적인 원리 자체는 프로토타입 패턴을 따라간다.</p><p>그럼 이제 자바스크립트가 객체를 생성할 때 프로토타입 패턴을 어떤 식으로 사용하고 있는 지 한번 알아보도록 하자.</p><h2 id="자바스크립트의-프로토타입"><a href="#자바스크립트의-프로토타입" class="headerlink" title="자바스크립트의 프로토타입"></a>자바스크립트의 프로토타입</h2><p>앞서 설명했듯이 프로토타입 패턴은 객체를 생성할 때 사용하는 패턴이다. 필자가 위에서 예시로 사용한 언어인 자바는 클래스 기반 프로그래밍을 지원하기 때문에, 특수한 패턴을 사용해야지만 프로토타입이라는 개념을 사용할 수 있다.</p><p>그러나 애초에 프로토타입 기반 프로그래밍을 지원하는 자바스크립트의 경우에는 애초에 모든 객체를 생성할 때 프로토타입을 사용하기 때문에, 객체를 생성하기만 해도 위에서 필자가 설명한 프로토타입 패턴이 적용된다.</p><p>그렇기 때문에 우선 자바스크립트에서 말하는 <code>객체(Object)</code>가 무엇인지, 그리고 그 객체가 생성된다는 것이 무엇을 의미하는 것인지 알아볼 필요가 있다.</p><h3 id="자바스크립트가-객체를-생성하는-방법"><a href="#자바스크립트가-객체를-생성하는-방법" class="headerlink" title="자바스크립트가 객체를 생성하는 방법"></a>자바스크립트가 객체를 생성하는 방법</h3><p>컴퓨터 공학에서의 <code>객체(Object)</code>는 <code>현실의 사물을 프로그램에 반영한 것</code>이다. 즉, 여러 개의 프로퍼티(특징)와 메소드(행위)를 가지고 현실의 사물을 흉내내는 존재인 것이다.</p><p>클래스 기반 언어에서는 클래스를 생성하고 그 클래스를 사용하여 객체를 생성해야하지만, 자바스크립트는 간단한 문법만으로 객체를 생성할 수 있다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> evan = &#123;</span><br><span class="line">  name: <span class="hljs-string">'Evan'</span>,</span><br><span class="line">  age: <span class="hljs-number">29</span>,</span><br><span class="line">  say: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Hi, I am <span class="hljs-subst">$&#123;<span class="hljs-keyword">this</span>.name&#125;</span>!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>이런 방식을 우리는 <code>리터럴(Literal)</code>로 객체를 선언한다고 한다. 리터럴은 소스 코드의 고정된 값을 대표하는 일종의 단축어 같은 개념이기 때문에, 우리는 간단한 문법만으로 객체를 생성했다고 느끼지만 내부적으로는 객체를 생성하는 일련의 매커니즘이 작동하고 있다.</p><p>예를 들어, 다른 언어에서는 이런 리터럴 문법을 사용하여 객체를 생성할 때 내부적으로 <code>클래스</code>를 사용하게된다. 파이썬 같은 경우, 딕셔너리를 리터럴로 선언하고 타입을 찍어보면 <code>dict</code> 클래스가 출력되는 것을 볼 수 있다.</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_dict = &#123;</span><br><span class="line">    <span class="hljs-string">'name'</span>: <span class="hljs-string">'Evan'</span>,</span><br><span class="line">    <span class="hljs-string">'age'</span>: <span class="hljs-number">29</span></span><br><span class="line">&#125;</span><br><span class="line">type(my_dict)</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;dict&apos;&gt;</span><br></pre></td></tr></table></figure><p>우리는 <code>dict({ &#39;name&#39;: &#39;Evan&#39;, &#39;age&#39;: 29 })</code>와 같이 클래스를 명시적으로 사용하지않고 리터럴로 딕셔너리를 생성했지만 내부적으로는 제대로 <code>dict</code> 클래스를 사용해서 객체를 생성했다는 것이다.</p><p>자바 또한 리터럴 문법을 지원하는 <code>배열(Array)</code>을 선언한 후 출력해보면 결국 클래스를 기반으로 배열 객체를 생성한다는 것을 알 수 있다.</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] array = &#123;<span class="hljs-string">"Evan"</span>, <span class="hljs-string">"29"</span>&#125;;</span><br><span class="line">System.out.println(array);</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Ljava.lang.String;@7852e922</span><br></pre></td></tr></table></figure><p>이 말인 즉슨, 다른 언어와 마찬가지로 자바스크립트의 객체도 갑자기 혼자서 뿅 하고 생성되는 것이 아니라 분명히 뭔가를 사용해서 만들어내고 있다는 말이다.</p><p>하지만 자바스크립트에는 클래스라는 개념 자체가 없는데 뭘 사용해서 객체를 만들어내고 있는 것일까?</p><blockquote><p>답은 바로 <code>함수(Function)</code>이다.</p></blockquote><p>자바스크립트에서 객체가 생성되는 원리를 조금 더 파헤쳐보기 위해서 위에서 리터럴로 선언했던 <code>evan</code> 객체를 이번에는 다른 방법으로 선언해보도록 하겠다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> evan = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(&#123;</span><br><span class="line">  name: <span class="hljs-string">'Evan'</span>,</span><br><span class="line">  age: <span class="hljs-number">29</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>왠지 클래스 기반 언어에서 클래스를 사용하여 객체를 생성하는 것과 유사한 문법이 나타났다. 이런 방식을 <code>생성자(Constructor)</code>를 사용하여 객체를 생성한다고 한다.</p><p>클래스 기반 언어라면 <code>Object</code>는 클래스겠지만, 자바스크립트에서는 클래스가 아닌 함수이다.</p><p>즉, 자바스크립트에서의 생성자는 함수가 가지고 있다는 것이다. 저게 진짜 함수인지 알고 싶으니, 브라우저 콘솔 창을 열고 <code>Object</code>를 한번 출력해보도록 하겠다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Object</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ƒ <span class="hljs-built_in">Object</span>() &#123; [native code] &#125;</span><br><span class="line"><span class="hljs-string">"function"</span></span><br></pre></td></tr></table></figure><p>음, 콘솔로 찍어보니 <code>Object</code>는 확실하게 빼박캔트 함수가 맞다.</p><p>필자가 처음 자바스크립트를 사용하기 시작했을 때 받아들이기 어려웠던 부분이 바로 이 부분이었다.</p><p>클래스 기반 프로그래밍에 익숙했던 필자에게 <code>new</code> 키워드와 생성자는 클래스만 가질 수 있는 것이었는데 갑자기 뜬금없이 함수가 나와버리니 받아들이기 힘들었던 것 같다.<small>(머리로는 알겠는데 마음이…)</small></p><p>어쨌든 이제 자바스크립트가 객체를 생성할 때 함수를 사용해서 생성한다는 것을 알게되었다. 지금까지 알아낸 내용을 정리해보자면 다음과 같다.</p><blockquote><ol><li>프로토타입 패턴이란 객체를 생성할 때 원본 객체를 복제하여 생성하는 방법이다.</li><li>자바스크립트는 객체를 생성할 때 프로토타입 패턴을 사용한다.</li><li>자바스크립트는 객체를 생성할 때 함수를 사용한다.</li></ol></blockquote><p>그렇다는 것은 자바스크립트가 함수를 사용하여 객체를 생성할 때 <code>뭔가</code>를 참조하고 복제해서 객체를 생성한다는 말이다. 이제부터 그 <code>뭔가</code>를 알아 볼 시간이다.</p><h3 id="도대체-뭘-복제해서-객체를-만드는-걸까"><a href="#도대체-뭘-복제해서-객체를-만드는-걸까" class="headerlink" title="도대체 뭘 복제해서 객체를 만드는 걸까?"></a>도대체 뭘 복제해서 객체를 만드는 걸까?</h3><p>사실 디자인 패턴으로써의 프로토타입 패턴은 생각보다 그렇게 어렵지 않다. 그저 객체를 생성할 때 원본 객체를 <code>복제</code>해서 생성한다는 개념이기 때문이다.</p><p>마찬가지로 자바스크립트 또한 뭔가를 복제해서 새로운 객체를 생성하고 있다. 그럼 이제 자바스크립트가 도대체 뭘 복제해서 객체를 생성하고 있는 것인지 알아보기 위해 간단한 함수를 하나 선언해보도록 하겠다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span> (<span class="hljs-params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> evan = <span class="hljs-keyword">new</span> User();</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(evan);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> evan);</span><br></pre></td></tr></table></figure><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User &#123; <span class="hljs-attr">__proto__</span>: <span class="hljs-built_in">Object</span> &#125;</span><br><span class="line">object</span><br></pre></td></tr></table></figure><p>위에서 이야기했듯이 자바스크립트는 함수를 사용하여 객체를 생성하기 때문에, 이렇게 클래스를 사용하는 것과 유사한 느낌으로 객체를 생성할 수 있다.</p><p>그렇다면 <code>evan</code> 객체는 무엇으로부터 복제된 것일까? 간단하게 생각하면 <code>User</code> 함수라고 생각해볼수 있겠지만, 사실은 <code>User</code> 함수를 복제한 것이 아니라 <code>User 함수의 프로토타입 객체</code>를 복제한 것이다.</p><center><br>  <img src="/2019/10/23/js-prototype/surprise.jpeg" width="400"><br>  <small>이렇게 갑자기 프로토타입이 나온다고…?</small><br>  <br><br></center><p>뜬금없어서 바로 이해가 안될 수도 있겠지만, 단순하게 생각해보면 쉽다. 만약 객체를 생성하면서 함수를 복제했다면 생성된 객체는 <code>object</code> 타입이 아니라 <code>function</code> 타입이어야 하지 않겠는가?</p><p>하지만 <code>evan</code> 객체는 <code>object</code> 타입을 가지고 있다. 즉, 이 함수 자체가 아니라 다른 객체 타입의 무언가를 복제했다는 것이고, 그 원본 객체가 <code>User 함수의 프로토타입 객체</code>인 것이다.</p><p>필자는 <code>User</code> 함수의 프로토타입을 명시적으로 선언하지 않았지만, 자바스크립트는 함수가 생성될 때 자동으로 그 함수의 <code>프로토타입 객체(Prototype Object)</code>도 함께 생성하고 해당 함수의 <code>prototype</code> 프로퍼티에 연결해둔다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span> (<span class="hljs-params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(User.prototype);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> User.prototype);</span><br></pre></td></tr></table></figure><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="hljs-attr">constructor</span>: f User(), <span class="hljs-attr">__proto__</span>: <span class="hljs-built_in">Object</span> &#125;</span><br><span class="line">object</span><br></pre></td></tr></table></figure><p>분명히 필자는 함수만 선언했는데, <code>User.prototype</code> 프로퍼티에 뭔가 이것저것 가지고 있는 객체 녀석이 1+1으로 붙어나왔다. 함수를 생성하면 무조건 그 함수의 프로토타입 객체도 함께 생성된다는 것이 키포인트다.</p><p>그리고 이 프로토타입 객체는 함수를 사용해서 새로운 객체를 생성할 때 원본 객체 역할을 해줄 객체를 의미한다.</p><p>즉, <code>new User()</code>라는 문법을 사용하여 새로운 객체를 만들게 되면 <code>User</code> 함수 자체가 아니라 <code>User</code> 함수가 생성될 때 함께 생성된 <code>User 함수의 프로토타입 객체</code>를 복제해서 새로운 객체를 만든다는 것이다.</p><center><br>  <img src="/2019/10/23/js-prototype/prototype.png" width="500"><br>  <small>evan 객체야, 내가 아니라 내 프로토타입 객체를 복제하렴</small><br>  <br><br></center><p>이때 <code>User</code> 함수가 생성되며 함께 생성된 User 함수의 프로토타입 객체를 <code>프로토타입 프로퍼티(Prototype Property)</code>라고 한다.</p><p>그럼 이 프로토타입 객체가 가지고 있는 프로퍼티인 <code>constructor</code>와 <code>__proto__</code>는 뭘 의미하는 걸까?</p><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p>함수가 생성되며 함께 생성된 프로토타입 객체는 모두 <code>constructor</code>라는 프로퍼티를 가지고 있다. 그리고 이 프로퍼티에는 이 프로토타입 객체가 생성될 때 선언했던 함수가 들어있다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(User.prototype);</span><br></pre></td></tr></table></figure><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="hljs-keyword">constructor</span>: f User(),</span><br><span class="line">  __proto__: Object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>함수를 선언하면 함수와 함께 해당 함수의 프로토타입 객체도 함께 생성되며 이 둘을 연결하게 된다. 이때 함수는 프로토타입 객체의 <code>constructor</code> 프로퍼티로 연결되고, 프로토타입 객체는 함수의 <code>prototype</code> 프로퍼티로 연결되는 것이다.</p><center><br>  <img src="/2019/10/23/js-prototype/prototype_connection.png" width="500"><br>  <small>함수와 프로토타입 객체는 서로 연결되어있다</small><br>  <br><br></center><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(User.prototype.constructor === User);</span><br></pre></td></tr></table></figure><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-literal">true</span></span><br></pre></td></tr></table></figure><p>이 생성자 프로퍼티는 이 함수를 통해 생성된 객체 입장에서 보았을 때 <code>나를 만들 때 어떤 함수가 호출되었냐?</code>를 의미한다. 만약 이 연결이 없다면 새로 생성된 객체는 자신을 만들 때 어떤 생성자 함수가 호출되었는지 알 수가 없다.</p><p>새롭게 생성된 객체는 자신을 생성할 때 어떤 원본 객체를 복사했는지에 대한 링크는 가지고 있지만 어떤 생성자가 호출되었는지에 대한 링크는 가지고 있지 않기 때문이다.</p><p>하지만 원본 객체의 <code>constuctor</code> 프로퍼티에 생성자 함수가 연결되어있기 때문에 새롭게 만들어진 객체는 자신의 원본 객체에 접근해서 이 프로퍼티를 참조함으로써 자신이 만들어질때 어떤 생성자 함수가 호출되었는지를 알 수 있다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> evan = <span class="hljs-keyword">new</span> User();</span><br><span class="line"><span class="hljs-built_in">console</span>.log(evan.__proto__.constructor === User);</span><br></pre></td></tr></table></figure><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-literal">true</span></span><br></pre></td></tr></table></figure><p>이때 생성된 객체가 자신의 원본 객체에 접근할 수 있는 프로퍼티가 바로 <code>__proto__</code> 프로퍼티이다.</p><h4 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h4><p>방금 생성자를 설명하면서 함수를 통해 새롭게 생성된 객체는 원본 객체와의 연결을 가지고 있다고 했다. 이때 이 연결을 <code>프로토타입 링크(Prototype Link)</code>라고 한다.</p><p><code>Object.prototype</code>을 제외한 자바스크립트 내의 모든 객체는 원본 객체를 기반으로 복사되어 생성되었기 때문에, 자신의 원본 객체로 연결되어있는 프로토타입 링크 또한 모든 객체가 가지고 있다. 이때 이 링크가 담기는 프로퍼티가 <code>__proto__</code> 프로퍼티이다.</p><p><code>Object.prototype.__proto__</code>가 존재하지 않는 이유는 밑에서 후술하도록 하겠다. 우선은 객체들이 자신의 원본 객체로 통하는 프로토타입 링크를 가지고 있다는 사실에만 집중하자.</p><blockquote><p>이 포스팅에서는 이해를 돕기위해 <code>__proto__</code> 프로퍼티를 그대로 사용하고 있다.<br>그러나 해당 프로퍼티는 ECMAScript 2015에서는 표준이었지만 현재는 표준이 아니므로 <code>Object.getPrototypeOf()</code>를 사용하는 것을 추천한다.</p></blockquote><p>즉 <code>User</code> 함수를 사용하여 생성한 객체는 <code>User.prototype</code> 객체를 복사하여 생성된 객체이기 때문에, 이 객체들은 원본인 <code>User.prototype</code> 객체를 자신의 <code>__proto__</code> 프로퍼티에 연결해두는 것이다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span> (<span class="hljs-params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="hljs-keyword">const</span> evan = <span class="hljs-keyword">new</span> User();</span><br><span class="line"><span class="hljs-built_in">console</span>.log(evan.__proto__ === User.prototype);</span><br></pre></td></tr></table></figure><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-literal">true</span></span><br></pre></td></tr></table></figure><p>그렇다면 이 프로토타입 링크를 사용해서 계속 해서 원본 객체를 추적하다보면, 결국은 자바스크립트 내의 모든 객체들이 최종적으로 어떤 원본 객체를 복사해서 생성된 것인지 알 수 있지 않을까?</p><h2 id="프로토타입-체인"><a href="#프로토타입-체인" class="headerlink" title="프로토타입 체인"></a>프로토타입 체인</h2><p>자바스크립트 내의 사용되는 모든 객체들은 전부 이런 프로토타입 기반 방식으로 정의되고 생성된다. 즉, <code>String</code>, <code>Boolean</code>, <code>Array</code>와 같이 우리가 일반적으로 사용하고 있는 빌트인 객체들도 모두 같은 방식을 사용해서 만들었다는 것이다.</p><p>그렇다면 이 객체들은 어떤 프로토타입 객체를 복사해서 만들어진 것일까?</p><p>String, Boolean, Array든 뭐가 됐든 자바스크립트 내에 존재하는 모든 것들은 바로 <code>Object</code> 함수의 프로토타입인 <code>Object.prototype</code>을 시작으로 해서 복제된다.</p><p>위에서 <code>__proto__</code>를 설명하면서 <code>Object.prototype</code> 객체는 프로토타입 링크, 즉 원본 객체로 통하는 링크가 없다고 이야기했었는데, 그 이유는 바로 <code>Object.prototype</code>이 모든 객체들의 조상님이기 때문이다.</p><p>이게 정말인지 확인해보고 싶다면, 아무 객체나 골라잡아서 그 객체의 <code>__proto__</code> 프로퍼티를 통해 쭉쭉 올라가보면 된다.</p><p>일단 만만한 <code>String</code>을 사용해서 조상을 추적해보려고 하는데, <code>String</code> 객체를 생성하는 함수부터 출발할 것인지, <code>String</code> 함수를 통해 생성된 객체부터 출발할 것인지에 따라 조상까지 올라가는 길이 달라진다.</p><p>String <code>함수</code>와 String <code>객체</code>는 당연히 원본이 되는 객체도 다르기 때문이다. 필자는 그 중 String 객체를 생성할 수 있는 String 생성자 함수를 선택했다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> first = <span class="hljs-built_in">String</span>.__proto__;</span><br><span class="line"><span class="hljs-keyword">const</span> second = first.__proto__;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'첫번째 조상 -&gt; '</span>, first.constructor.name);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'두번째 조상 -&gt; '</span>, second.constructor.name);</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">첫 번째 조상 -&gt; Function</span><br><span class="line">두 번째 조상 -&gt; Object</span><br></pre></td></tr></table></figure><p>자바스크립트의 모든 함수는 자신의 원본으로 <code>Function.prototype</code> 객체를 원본으로 가진다. 그리고 Function.prototype은 결국 객체이기 때문에, 당연히 원본으로 <code>Object.prototype</code> 객체를 원본으로 가진다.</p><p>그럼 여기서 한번 더 올라가면 어떻게 될까?</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> third = second.__proto__;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(third.constructor.name);</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught TypeError: Cannot read property &apos;constructor&apos; of null at &lt;anonymous&gt;:1:28</span><br></pre></td></tr></table></figure><p>앗, <code>TypeError</code>가 발생했다. 에러메세지를 보아하니 <code>Object.prototype</code> 객체의 원본 객체인 <code>Object.prototype.__proto__</code>는 <code>null</code>인 모양이다.</p><p>즉, <code>Object</code>의 위로는 더 이상 조상이 없는 것이다. 지금 살펴본 이 관계를 간단한 다이어그램으로 나타내어보면 다음과 같다.</p><center><br>  <img src="/2019/10/23/js-prototype/prototype-chain.png"><br>  <br><br></center><p>뭔가 복잡해보이지만 별 것 없다. String <code>함수</code>의 원본 객체는 <code>Function.prototype</code>이다. 그리고 <code>const a = &#39;evan&#39;</code>과 같이 선언된 String 객체는 자신을 생성한 String 함수의 <code>String.prototype</code>을 원본으로 가질 것이고, <code>String.prototype</code>은 객체이기 때문에 당연히 <code>Object.prototype</code>을 원본으로 가지는 것이다.</p><p>이렇게 프로토타입으로 이루어진 객체들의 관계를 <code>프로토타입 체인(Prototype Chain)</code>이라고 한다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>사실 필자가 프로토타입에 대한 포스팅을 쓰려고 했던 이유는 얼마 전 면접에서 자바스크립트의 프로토타입을 사용하여 <code>Private Static 메소드</code>를 구현하라는 문제를 받았다가 결국 못 풀었기 때문이다.</p><p>자바스크립트의 클로저와 프로토타입을 활용하여 풀어야하는 문제였는데, 필자는 기본기가 부족한 나머지 풀어내지 못했다.</p><p>그래서 원래는 프로토타입을 사용한 다양한 상속 기법들과 클로저를 사용한 멤버의 은닉 등도 함께 소개해보려고 했지만, 늘 그렇듯 분량 조절 실패로 인해 다른 포스팅에서 별도로 다뤄야할 것 같다.</p><center><br>  <img src="/2019/10/23/js-prototype/no_think.jpeg" width="300"><br>  <small>사실 애초에 분량 조절 따위를 생각하고 쓰지 않는다</small><br>  <br><br></center><p>필자처럼 기존의 클래스 기반 객체 생성방식에 익숙한 개발자들에게 자바스크립트의 프로토타입은 꽤나 복잡하게 느껴진다. 디자인 패턴으로써의 프로토타입은 단순히 객체를 복제해서 새로운 객체를 생성한다는 정도의 개념에 그치지만 자바스크립트의 프로토타입 체인은 그것보다 훨씬 더 복잡하게 연결되어있기 때문이다.</p><p>하지만 프로토타입 체인이나 프로토타입을 사용한 각종 상속 기법은 어렵게 느껴질 수 있어도, 프로토타입의 뼈대 자체는 그렇게 어렵지 않다고 생각한다.</p><blockquote><ol><li>객체는 함수를 사용해서 만들어지고, 객체는 함수의 프로토타입 객체를 복제하여 생성된다.</li><li>모든 객체는 자신이 어떤 원본 객체를 복제하여 생성된 것인지에 대한 정보를 가지고 있다.</li></ol></blockquote><p>물론 원본 객체에 대한 정보를 런타임에 동적으로 변경할 수 있는 등 변태같은 짓들이 가능하기도 하고, 이를 사용한 다양한 기법들도 있기는 하지만 기본은 결국 저 두 가지라고 할 수 있을 것 같다. 다음 포스팅에서는 본격적으로 프로토타입을 사용한 상속 기법과 객체의 프로퍼티를 탐색하는 방법인 프로토타입 룩업 등에 대해서 설명하도록 하겠다.</p><p>이상으로 자바스크립트의 프로토타입 훑어보기 포스팅을 마친다.</p>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/10/23/js-prototype/#disqus_thread</comments>
    </item>
    
    <item>
      <title>최소 값과 최대 값을 빠르게 찾을 수 있게 도와주는 힙(Heap)</title>
      <link>https://evan-moon.github.io/2019/10/12/introduction-data-structure-heap/</link>
      <guid>https://evan-moon.github.io/2019/10/12/introduction-data-structure-heap/</guid>
      <pubDate>Sat, 12 Oct 2019 09:51:14 GMT</pubDate>
      <description>
      
        &lt;p&gt;이번 포스팅에서는 대표적인 자료 구조 중 하나인 &lt;code&gt;힙(Heap)&lt;/code&gt;에 대한 설명과 구현을 한번 해보려고 한다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>이번 포스팅에서는 대표적인 자료 구조 중 하나인 <code>힙(Heap)</code>에 대한 설명과 구현을 한번 해보려고 한다.</p><a id="more"></a><p>이전의 포스팅에서 몇 번 언급한 적이 있지만 필자는 지금 백수다. 이제 프라하에서 한 달간의 힐링도 끝났으니 슬슬 면접을 보러 다녀야 하는데, 모두들 알다시피 면접에서는 기초 알고리즘이나 자료 구조에 대한 질문이 들어올 확률이 굉장히 높다. 하지만 필자는 최근 1년 정도 기초 공부를 게을리 했기 때문에 다시 공부를 해야하는 상황이다.</p><p>그래서 일단은 자료 구조부터 다시 살펴볼 생각인데, 그 중 제일 기억이 잘 나지 않는 <code>힙(Heap)</code>부터 한번 부셔볼까 한다.</p><h2 id="힙-Heap-이란"><a href="#힙-Heap-이란" class="headerlink" title="힙(Heap)이란?"></a>힙(Heap)이란?</h2><p>힙은 기본적으로 <code>완전 이진 트리(Complete Binary Tree)</code>를 기본으로 한 자료 구조이며, 부모 노드와 자식 노드 간의 대소관계가 성립하는 자료 구조이다. 그렇기 때문에 힙의 루트 노드는 힙 내의 데이터들 중 <code>가장 큰 값</code>이거나 <code>가장 작은 값</code>이라고 할 수 있다.</p><center><br>  <img src="/2019/10/12/introduction-data-structure-heap/heap.png" width="500"><br>  <small>루트에 최대 값이 오게 되는 Max Heap의 모습</small><br>  <small>생긴 건 완전 이진 트리랑 똑같이 생겼다</small><br>  <br><br></center><p>즉, 힙 내의 가장 큰 값이나 가장 작은 값에 접근하고 싶을 때 비교 연산없이 한번에 접근할 수 있다는 의미이며, 이 접근 연산의 시간 복잡도는 당연히 $O(1)$이다. 이런 힙의 성격 때문에 힙은 여러 개의 데이터 중에서 가장 크거나 작은 값을 빠르게 찾아야 하는 영역에서 유용하게 사용된다.</p><p>사실 단순히 어떤 데이터 뭉치 안에서 최대 값이나 최소 값에 $O(1)$의 시간 복잡도로 접근하고 싶다면 그냥 <code>링크드 리스트(Linked List)</code>나 <code>배열(Array)</code>을 정렬해서 사용해도 무방하긴 하다. 한번 정렬만 해놓으면 그 다음부터는 그냥 헤드에서 값을 쏙쏙 뽑아다 쓰면 되기 때문이다.</p><p>그러나 이렇게 정렬되어 있는 데이터 뭉치에 새로운 데이터를 <code>추가</code>할 때는 전체 데이터 뭉치를 싹 다 뒤져서 다시 최대, 최소 값이 무엇인지 찾아내고 재정렬하는 과정을 거쳐야한다.</p><p>배열과 링크드 리스트과 같은 선형 자료 구조는 이 과정에 $O(n)$의 시간 복잡도가 소요되는 반면, 부모가 자식보다 크거나 작게 정렬된 이진 트리의 경우는 새로운 추가된 노드의 부모 노드들과만 비교해도 정렬 상태를 유지할 수 있기 때문에 $O(\log n)$의 시간 복잡도만 소요된다.</p><p>즉, 정렬하고 싶은 데이터가 많을 수록 더 유리하다는 소리다.</p><center><br>  <img src="/2019/10/12/introduction-data-structure-heap/compares.png" width="500"><br>  <small>전체 데이터를 비교할 필요없이 이 부분만 비교하면 다시 재정렬할 수 있다</small><br>  <br><br></center><p>힙은 완전 이진 트리를 기초로 하기 때문에 구현하는 방법 또한 완전 이진 트리와 흡사하다. 그렇기 때문에 힙을 구현해보기에 앞서 완전 이진 트리의 특징을 먼저 이야기 해보려고 한다.</p><h2 id="완전-이진-트리-Complete-Binary-Tree"><a href="#완전-이진-트리-Complete-Binary-Tree" class="headerlink" title="완전 이진 트리(Complete Binary Tree)"></a>완전 이진 트리(Complete Binary Tree)</h2><p>먼저, 힙의 기본이 되는 완전 이진 트리의 특징을 한번 살펴보자. <code>이진 트리(Binary Tree)</code>란 어떤 하나의 노드가 자식 노드를 최대 2개까지만 가질 수 있는 트리를 말한다.</p><p>그 말인 즉슨, 한 레벨에 최대로 들어설 수 있는 노드의 개수가 정해져있다는 뜻이고, 노드들에게 고유한 인덱스를 부여할 수 있다는 것을 의미한다.</p><center><br>  <img src="/2019/10/12/introduction-data-structure-heap/not_allow_new_node.png" width="500"><br>  <small>부모 노드는 반드시 2개 이하의 자식 노드를 가져야 한다.</small><br>  <br><br></center><p><code>완전 이진 트리(Complete Binary Tree)</code>는 이진 트리의 노드를 생성할 때 트리의 왼쪽부터 차곡차곡 채워 나가는 트리를 의미한다. 이때 완전 이진 트리의 한 레벨이 꽉 차기 전에는 다음 레벨에 노드를 생성할 수 없다. 즉, 마지막 레벨을 제외한 모든 레벨에는 노드가 꽉 차 있어야 한다는 뜻이다.</p><p>트리는 보통 <code>링크드 리스트(Linked List)</code>나 <code>배열(Array)</code>과 같은 선형 자료 구조를 사용하여 구현하는데, 이때 링크드 리스트와 배열의 특징에 따라 장단점이 갈리기 때문에 선택이 필요하다.<small>(링크드 리스트와 배열의 차이에 대한 내용은 이 포스팅의 주제가 아니므로 따로 설명하지는 않겠다.)</small></p><p>일반적으로 트리는 링크드 리스트를 사용하여 구현하지만 완전 이진 트리의 경우에는 배열로 구현하는 것이 더 효율적이다.</p><h3 id="배열이-더-효율적인-이유"><a href="#배열이-더-효율적인-이유" class="headerlink" title="배열이 더 효율적인 이유"></a>배열이 더 효율적인 이유</h3><p>사실 트리를 구현할 때 <code>원소에 한방에 접근이 가능하다</code>는 배열의 최대 장점을 뒤로 미뤄두고서라도 링크드 리스트를 사용하는 이유는, 배열을 사용하여 트리를 구현하면 메모리 고정 할당 방식이라는 배열의 특성 상 불편한 점이 너무 많기 때문이다.</p><p>그러나 완전 이진 트리에서는 이 불편한 점들이 사라지기 때문에 배열의 장점을 오롯이 가져갈 수 있다.</p><h4 id="원하는-노드로의-접근이-쉽다"><a href="#원하는-노드로의-접근이-쉽다" class="headerlink" title="원하는 노드로의 접근이 쉽다"></a>원하는 노드로의 접근이 쉽다</h4><p>이건 배열의 최대 장점인 <code>인덱스만 알면 해당 원소에 바로 접근이 가능</code>하다는 장점을 그대로 살린 것이다. 이진 트리는 각 레벨에 들어설 수 있는 노드의 최대 개수가 정해져 있기 때문에 간단한 수식만으로 특정 노드의 인덱스를 알아내어 $O(1)$의 시간 복잡도로 노드에 접근할 수 있다.</p><p>먼저, 특정 노드를 기반으로 부모나 자식 노드에 접근하고 싶다면 다음과 같이 인덱스를 계산해볼 수 있다.</p><blockquote><p>루트 노드가 0번 인덱스를 가지고, 현재 노드가 $i$번 인덱스를 가지고 있을 때</p><p>[부모 노드] $(i-1) / 2$<br>[왼쪽 자식 노드] $2i+1$<br>[오른쪽 자식 노드] $2i+2$</p></blockquote><p>위와 같이 특정 노드의 인덱스를 기반으로 부모와 자식들의 인덱스를 알아내는 방법도 있지만, 배열로 만든 완전 이진 트리의 진짜 장점은 간단한 수식을 통해서 원하는 레벨, 원하는 순번의 노드로 바로 접근할 수도 있다는 것이다.</p><p>완전 이진 트리의 성질을 이용하면 특정 레벨까지의 최대 노드 개수인 $c$를 간단히 계산할 수 있기 때문에 가능한 일이다.</p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtable><mtr><mtd><mrow><mi>c</mi><mo>=</mo><msup><mn>2</mn><mrow><mi>l</mi><mi>e</mi><mi>v</mi><mi>e</mi><mi>l</mi></mrow></msup><mo>−</mo><mn>1</mn></mrow></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{aligned}c = 2^{level} - 1\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.879554em;"></span><span class="strut bottom" style="height:1.259108em;vertical-align:-0.379554em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist"><span style="top:0.01955399999999996em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle uncramped"><span class="mord mathit">c</span><span class="mrel">=</span><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.413em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.01968em;">l</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></span></span><p><br></p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAllNodeCountByLevel</span> (<span class="hljs-params">level = <span class="hljs-number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>**level - <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(getAllNodeCountByLevel(<span class="hljs-number">3</span>));</span><br></pre></td></tr></table></figure><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">7</span> <span class="hljs-comment">// 3 레벨로 구성된 완전 이진 트리 내 노드의 최대 개수</span></span><br></pre></td></tr></table></figure><p>이 식을 사용하면 $n$번째 레벨의 $m$번째 노드의 인덱스도 간단하게 알아낼 수 있다.</p><p>예를 들어, 완전 이진 트리의 <code>n 레벨에 있는 m번째 노드</code>의 인덱스인 $i$를 구하고 싶다면, 내가 접근하고 싶은 레벨의 바로 위 레벨인 $n - 1$ 레벨까지의 모든 노드의 개수 $c$을 구하고, 거기에 해당 레벨 내에서 내가 $m$번째 노드에 접근하고 싶은지만 더해주면 된다.</p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtable><mtr><mtd><mrow><mi>i</mi><mo>=</mo><mi>c</mi><mo>+</mo><mi>m</mi><mo>−</mo><mn>1</mn></mrow></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{aligned}i = c + m - 1\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8500000000000001em;"></span><span class="strut bottom" style="height:1.2000000000000002em;vertical-align:-0.35000000000000003em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist"><span style="top:-0.010000000000000009em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle uncramped"><span class="mord mathit">i</span><span class="mrel">=</span><span class="mord mathit">c</span><span class="mbin">+</span><span class="mord mathit">m</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></span></span><p><br></p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNodeIndex</span> (<span class="hljs-params">level = <span class="hljs-number">1</span>, count = <span class="hljs-number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> getAllNodeCountByLevel(level - <span class="hljs-number">1</span>) + count - <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(getNodeIndex(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>));</span><br></pre></td></tr></table></figure><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">5</span> <span class="hljs-comment">// 3 레벨의 3 번째로 위치한 노드의 인덱스</span></span><br></pre></td></tr></table></figure><p>마지막에 1을 빼주는 이유는 우리가 구하고 싶은 것이 노드의 순번이 아닌 인덱스이기 때문이다. 배열의 인덱스는 <code>0</code>부터 시작한다는 사실을 잊지 말자.</p><p>이처럼 배열로 구현한 완전 이진 트리는 간단한 계산만으로 원하는 노드에 접근하기가 용이하지만, 링크드 리스트로 구현하게되면 원하는 노드에 바로 접근할 수 없고, 트리를 순회하여 접근해야한다.</p><h4 id="배열의-원소를-뒤로-밀어줘야-할-일이-없다"><a href="#배열의-원소를-뒤로-밀어줘야-할-일이-없다" class="headerlink" title="배열의 원소를 뒤로 밀어줘야 할 일이 없다"></a>배열의 원소를 뒤로 밀어줘야 할 일이 없다</h4><p>배열은 메모리에 연속적인 공간을 할당하여 사용하기 때문에, 배열 중간에 원소를 끼워넣으려면 새로운 메모리 공간을 확보하기 위해 원소를 한 칸씩 뒤로 밀어줘야하는 슬픈 상황이 발생하지만, 링크드 리스트는 그냥 <code>prev</code> 값과 <code>next</code> 값만 변경함으로써 중간에 새로운 원소를 끼워넣기가 편하다.</p><p>그러나 이진 트리의 경우, 자식 노드를 최대 2개까지만 가질 수 있다는 제약이 있기 때문에 높이가 $h$인 트리는 최대 노드 개수가 $2^{h} -1$개로 정해져있다. 즉, 이 크기 만큼만 배열을 메모리에 할당하고 나면 중간에 노드를 새로 삽입하기 위해 배열의 원소를 뒤로 밀어야하는 경우가 발생하지 않는다는 것이다.</p><h4 id="트리가-기울어지지-않는다"><a href="#트리가-기울어지지-않는다" class="headerlink" title="트리가 기울어지지 않는다"></a>트리가 기울어지지 않는다</h4><p>일반적으로 배열로 구현한 트리가 기울어지게 되면 메모리 공간에 심한 낭비가 생기게 되는데, 그 이유는 그림으로 보면 이해하기가 한결 편하다.</p><center><br>  <img src="/2019/10/12/introduction-data-structure-heap/balanced.jpg" width="500"><br></center><p>위 그림은 이상적으로 균형이 잡힌 <code>밸런스드 이진 트리(Balanced Binary Tree)</code>의 모습이다. 만약 이 트리를 배열로 구현한다면 메모리에는 이렇게 값들이 담길 것이다.</p><hr><table><thead><tr><th>Location</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>Value</td><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td><td>F</td></tr></tbody></table><hr><p>배열 중간에 빈 공간이 없이 차곡차곡 메모리에 담겼다. 노드의 인덱스는 트리의 왼쪽부터 순차적으로 부여되기 때문에 자식 노드를 왼쪽부터 생성한다면 메모리에 빈 공간을 만들지 않을 수 있다.</p><p>물론 자식 노드를 생성할 때 왼쪽을 건너 뛰고 오른쪽부터 생성하면 빈 공간이 생기긴 하지만, 더 큰 문제는 트리가 한 쪽으로 크게 기울어지게 되게 되는 편향 트리가 되는 경우이다.</p><center><br>  <img src="/2019/10/12/introduction-data-structure-heap/unbalanced.jpg" width="500"><br></center><hr><table><thead><tr><th>Location</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>Value</td><td>A</td><td>B</td><td>C</td><td>D</td><td>-</td><td>-</td><td>-</td><td>H</td></tr></tbody></table><hr><p>위 그림처럼 한 쪽으로 크게 기운 편향 트리는 중간 인덱스를 건너뛰고 다음 레벨에 노드를 생성한 경우이기 때문에 메모리에 빈 공간이 생길 수 밖에 없다. 그렇기 때문에 메모리 공간이 낭비된다고 하는 것이다. 물론 오른쪽으로 기울었다면 건너뛰어야 하는 인덱스도 더 크기 때문에 메모리 공간의 낭비가 더 심해진다.</p><p>그러나 <code>완전 이진 트리</code>는 노드를 왼쪽부터 차곡차곡 채워나가고, 한 레벨의 노드가 다 채워지기 전까지는 다음 레벨에 노드를 채울 수 없다는 제약들이 걸려있기 때문에 애초에 트리가 기울어질 일 자체가 없으니 메모리에 빈 공간이 생길 일도 없다.</p><p>이런 이유들로 인해 완전 이진 트리는 원소에 바로 접근이 가능한 배열의 장점을 살려서 구현하는 경우가 많고, 완전 이진 트리를 기반으로 하는 <code>힙</code> 또한 마찬가지 이유로 인해 주로 배열로 구현하게된다.</p><h2 id="완전-이진-트리와-힙의-차이"><a href="#완전-이진-트리와-힙의-차이" class="headerlink" title="완전 이진 트리와 힙의 차이"></a>완전 이진 트리와 힙의 차이</h2><p><code>힙(Heap)</code>은 완전 이진 트리를 기초로 하기 때문에 기본적인 노드의 삽입 및 삭제 알고리즘은 일반적인 완전 이진 트리와 동일하다. 노드의 삽입은 반드시 배열의 끝에만 가능하며, 노드를 삭제하고 나면 빈 공간이 남지 않도록 남은 노드들을 다시 당겨서 빈 공간을 채워줘야한다.</p><p>다만 힙은 부모와 자식 노드 간의 대소관계가 성립되어야 한다는 조건이 있기 때문에, 삽입 및 삭제 후 <code>노드를 다시 정렬해주는 기능</code>이 추가로 필요하다.</p><p>또한 힙은 사실 트리 내의 최대 값이나 최소 값을 쉽게 찾고자 하는 자료 구조이기 때문에, 트리 중간에 위치한 노드에 바로 접근할 일도 거의 없다. 항상 <code>Array[0]</code>에 위치한 루트 노드를 뽑아다 쓰면 되기 때문이다. 루트 노드를 뽑아온다는 것은 곧 루트 노드의 삭제를 의미하기 때문에 마찬가지로 힙을 다시 정렬해줘야한다.</p><p>힙은 <code>최대 힙(Max Heap)</code>과 <code>최소 힙(Min Heap)</code>으로 나누어지는데, 최대 힙은 항상 부모의 값이 자식보다 커야하고, 최소 힙은 반대로 부모의 값이 자식보다 작아야 한다. 즉, 최대 힙의 루트는 힙 내에서 <code>가장 큰 값</code>, 최소 힙의 루트는 힙 내에서 <code>가장 작은 값</code>을 의미한다는 것이다.</p><center><br>  <img src="/2019/10/12/introduction-data-structure-heap/min-max-heap.png" width="500"><br>  <br><br></center><p>즉, 힙을 구현한다는 것은 완전 이진 트리를 구현하고, 최대 힙과 최소 힙에 맞는 정렬 기능을 추가하면 된다는 것이다.</p><h2 id="힙을-구현해보자"><a href="#힙을-구현해보자" class="headerlink" title="힙을 구현해보자"></a>힙을 구현해보자</h2><p>일단 최대 힙과 최소 힙의 차이는 사실 정렬할 때 조건 밖에 없으니, 필자는 <code>최대 힙</code>만 구현해보려고 한다. 위에서 이야기 했듯이 완전 이진 트리의 경우는 링크드 리스트를 이용하는 것보다 배열을 이용하는 것이 더 효율적이기 때문에 배열을 이용하여 구현할 것이다.</p><p>일단 작고 귀여운 <code>MaxHeap</code> 클래스를 하나 만들어주자.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxHeap</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.nodes = [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>만약 링크드 리스트로 구현하고자 한다면 <code>Node</code> 클래스를 별도로 선언해서 사용하겠지만 필자가 사용할 자료 구조는 배열이기 때문에 단촐하기 그지 없다. 그럼 이제 힙에 값을 삽입하는 메소드부터 한번 만들어보도록 하자.</p><h3 id="새로운-값의-삽입-버블-업"><a href="#새로운-값의-삽입-버블-업" class="headerlink" title="새로운 값의 삽입. 버블 업!"></a>새로운 값의 삽입. 버블 업!</h3><p>힙에 새로운 값을 삽입할 때는 완전 이진 트리의 규칙대로 무조건 트리의 왼쪽부터 채워나간다. 그 말인 즉슨, 그냥 <code>push</code> 메소드를 사용하여 배열의 꼬리로 값을 하나씩 쑤셔넣어주면 된다는 것이다. 잘 이해가 되지 않는다면 위의 <code>완전 이진 트리</code> 설명 부분을 다시 읽어보도록 하자.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert (value) &#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.nodes.push(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>최대 힙은 항상 부모가 자식보다 큰 값을 가져야한다는 제약이 있으므로, 만약 우리가 힙에 삽입한 노드가 부모 노드보다 큰 값을 가지고 있다면 두 노드의 위치를 바꿔줘야한다.</p><p>그리고 이 작업을 <code>현재 삽입한 노드가 루트까지 올라가거나</code>, <code>부모보다 작은 값을 가지게 되거나</code>, 두 조건 중 하나를 만족할 때까지 반복한다.</p><p>이때 새로 추가한 값이 부모 노드와 스왑되면서 점점 트리의 위로 올라가는 모양새가 거품이 뽀글뽀글 올라오는 모양새랑 비슷하다고 해서 <code>버블 업(Bubble Up)</code>이라고 부른다.</p><center><br>  <img src="/2019/10/12/introduction-data-structure-heap/bubbleup.png" width="500"><br>  <small>부모와 자리를 바꾸면서 트리의 위쪽으로 점점 올라간다</small><br>  <br><br></center><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">insert (value) &#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.nodes.push(value);</span><br><span class="line">  <span class="hljs-keyword">this</span>.bubbleUp();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bubbleUp (index = <span class="hljs-keyword">this</span>.nodes.length - <span class="hljs-number">1</span>) &#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">1</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">const</span> currentNode = <span class="hljs-keyword">this</span>.nodes[index];</span><br><span class="line">  <span class="hljs-keyword">const</span> parentIndex = <span class="hljs-built_in">Math</span>.floor((index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);</span><br><span class="line">  <span class="hljs-keyword">const</span> parentNode = <span class="hljs-keyword">this</span>.nodes[parentIndex];</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (parentNode &gt;= currentNode) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">this</span>.nodes[index] = parentNode;</span><br><span class="line">  <span class="hljs-keyword">this</span>.nodes[parentIndex] = currentNode;</span><br><span class="line">  index = parentIndex;</span><br><span class="line">  <span class="hljs-keyword">this</span>.bubbleUp(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>bubbleUp</code> 메소드는 인자로 받은 인덱스의 노드의 값과 부모 노드의 값을 비교하여, 해당 노드가 부모 노드의 값보다 큰 값을 가지고 있다면 두 노드의 위치를 스왑하는 역할을 한다. 트리의 특성 상 이 작업은 분할 정복이 가능한 부분이므로 재귀 호출로 구현하였다.</p><p>여기까지 작성하고 간단히 테스트를 해보면 힙 내의 가장 큰 값이 배열의 헤드, 즉 트리의 루트에 위치하게 된다는 것을 알 수 있다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> heap = <span class="hljs-keyword">new</span> MaxHeap();</span><br><span class="line">heap.insert(<span class="hljs-number">1</span>);</span><br><span class="line">heap.insert(<span class="hljs-number">3</span>);</span><br><span class="line">heap.insert(<span class="hljs-number">23</span>);</span><br><span class="line">heap.insert(<span class="hljs-number">2</span>);</span><br><span class="line">heap.insert(<span class="hljs-number">10</span>);</span><br><span class="line">heap.insert(<span class="hljs-number">32</span>);</span><br><span class="line">heap.insert(<span class="hljs-number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(heap.nodes);</span><br></pre></td></tr></table></figure><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="hljs-number">32</span>, <span class="hljs-number">10</span>, <span class="hljs-number">23</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span> ]</span><br></pre></td></tr></table></figure><center><br>  <img src="/2019/10/12/introduction-data-structure-heap/max-heap.gif" width="500"><br>  <small>부모보다 큰 값이 추가되면 부모와 자리를 바꾼다</small><br>  <br><br></center><h3 id="루트에서-값을-빼오자-트릭클-다운"><a href="#루트에서-값을-빼오자-트릭클-다운" class="headerlink" title="루트에서 값을 빼오자. 트릭클 다운!"></a>루트에서 값을 빼오자. 트릭클 다운!</h3><p>값의 삽입과 버블 업을 구현해보았으면 이번에는 루트에서 값을 빼오는 메소드를 만들어보자. 즉, 삭제 연산이다. 이 경우 루트 노드를 뽑아버리면 루트 노드의 자리가 비게 되니 힙을 재정렬해서 다시 루트 노드를 채워줘야한다.</p><p>이때 기존 루트 노드의 자식 노드들을 루트 노드로 올리는 것이 아니라 트리의 가장 마지막에 위치한 노드를 가져와서 루트 노드로 삽입하게 되는데, 이는 수정될 힙에서 빈 공간이 생기지 않게 함으로써 연산량을 줄이기 위해서이다.</p><p>바로 루트의 바로 밑에 있는 자식들을 끌어올려서 루트로 사용해버리면 자연스럽게 그 노드가 있던 곳은 공백이 생기게 되고, 그럼 또 다음 레벨에서 어떤 노드를 끌여올려야 할지 비교 연산이 필요하게 되기 때문이다.</p><p>그리고 힙은 반드시 완전 이진 트리의 형태를 유지해야하기 때문에 이 과정에서 트리가 한 쪽으로 기울게 되버리면 또 트리의 균형을 맞춰줘야하는 번거로움도 생길 수 있다.</p><p>그래서 가장 마지막에 위치한 노드를 새로운 루트 노드로 사용하고 자식들과 값을 비교해나가면서 자리를 바꿔나가는데, 이때 새로운 루트 노드가 트리의 아래 쪽으로 점점 이동하는 모양새가 물방울이 떨어지는 모양새랑 비슷하다고 해서 <code>트릭클 다운(Trickle Down)</code>이라고 부른다.<small>(컴퓨터 용어 주제에 왠지 갬성적이다…)</small></p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">extract () &#123;</span><br><span class="line">  <span class="hljs-keyword">const</span> max = <span class="hljs-keyword">this</span>.nodes[<span class="hljs-number">0</span>];</span><br><span class="line">  <span class="hljs-keyword">this</span>.nodes[<span class="hljs-number">0</span>] = <span class="hljs-keyword">this</span>.nodes.pop();</span><br><span class="line">  <span class="hljs-keyword">this</span>.trickleDown();</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trickleDown (index = <span class="hljs-number">0</span>) &#123;</span><br><span class="line">  <span class="hljs-keyword">const</span> leftChildIndex = <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>;</span><br><span class="line">  <span class="hljs-keyword">const</span> rightChildIndex = <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>;</span><br><span class="line">  <span class="hljs-keyword">const</span> length = <span class="hljs-keyword">this</span>.nodes.length;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">let</span> largest = index;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (leftChildIndex &lt;= length &amp;&amp; <span class="hljs-keyword">this</span>.nodes[leftChildIndex] &gt; <span class="hljs-keyword">this</span>.nodes[largest]) &#123;</span><br><span class="line">    largest = leftChildIndex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">if</span> (rightChildIndex &lt;= length &amp;&amp; <span class="hljs-keyword">this</span>.nodes[rightChildIndex] &gt; <span class="hljs-keyword">this</span>.nodes[largest]) &#123;</span><br><span class="line">    largest = rightChildIndex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (largest !== index) &#123;</span><br><span class="line">    [<span class="hljs-keyword">this</span>.nodes[largest], <span class="hljs-keyword">this</span>.nodes[index]] = [<span class="hljs-keyword">this</span>.nodes[index], <span class="hljs-keyword">this</span>.nodes[largest]];</span><br><span class="line">    <span class="hljs-keyword">this</span>.trickleDown(largest);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>트릭클 다운 또한 버블 업과 마찬가지로 재귀 호출을 통한 분할 정복으로 해결할 수 있다.</p><p><code>trickleDown</code> 메소드는 부모 노드와 왼쪽 자식 노드, 오른쪽 자식 노드의 값을 비교한 후 자식 노드가 부모 노드보다 큰 값을 가지고 있다면 부모 노드와 해당 자식 노드의 위치를 변경한다.</p><p>쉽게 말하면 세 개의 노드 중 가장 큰 값을 가지고 있는 놈이 부모 자리를 먹는 것인데, 만약 이 힘싸움에서 밀린 것이 부모 노드라면 자신의 자식이 있던 곳으로 좌천되는 것이라고 보면 된다.</p><center><br>  <img src="/2019/10/12/introduction-data-structure-heap/Arthas_King.jpg" width="400"><br>  <small>썩씌딩하는 꼬라지가 왠지 이 놈을 닮았다</small><br>  <br><br></center><p>만약 이 과정에서 부모 노드와 자식 노드의 위치가 변경되었다면 변경된 부모 노드의 인덱스를 다시 <code>tickleDown</code> 메소드의 인자로 넘겨서 이 과정을 계속 반복한다.</p><p>여기까지 작성했으면 버블 업과 마찬가지로 간단한 테스트를 한번 해보자. 힙에 들어가는 값은 이전에 버블 업에서 사용했던 값과 동일한 값들을 사용했다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> heap = <span class="hljs-keyword">new</span> MaxHeap();</span><br><span class="line">heap.insert(<span class="hljs-number">1</span>);</span><br><span class="line">heap.insert(<span class="hljs-number">3</span>);</span><br><span class="line">heap.insert(<span class="hljs-number">23</span>);</span><br><span class="line">heap.insert(<span class="hljs-number">2</span>);</span><br><span class="line">heap.insert(<span class="hljs-number">10</span>);</span><br><span class="line">heap.insert(<span class="hljs-number">32</span>);</span><br><span class="line">heap.insert(<span class="hljs-number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> length = heap.nodes.length;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'MAX_VALUE = '</span>, heap.extract());</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'HEAP = '</span>, heap.nodes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MAX_VALUE = <span class="hljs-number">32</span></span><br><span class="line">HEAP = [ <span class="hljs-number">23</span>, <span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ]</span><br><span class="line"></span><br><span class="line">MAX_VALUE = <span class="hljs-number">23</span></span><br><span class="line">HEAP = [ <span class="hljs-number">10</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span> ]</span><br><span class="line"></span><br><span class="line">MAX_VALUE = <span class="hljs-number">10</span></span><br><span class="line">HEAP = [ <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span> ]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><center><br>  <img src="/2019/10/12/introduction-data-structure-heap/min-heap.gif" width="500"><br>  <small>트리의 맨 끝에서 노드를 빼와서 루트 노드로 사용한다는 것에 주의하자</small><br>  <br><br></center><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>힙 자체는 단순히 데이터들이 느슨하게 정렬되어있는 완전 이진 트리이지만, 루트에는 항상 힙 내부에 있는 데이터들의 최대 값과 최소 값이 위치한다는 특징 때문에 다양하게 응용하여 사용할 수 있다.</p><p>그 중 대표적인 것은 선형 자료 구조를 정렬할 때 사용하는 방법인데, 이 정렬 알고리즘을 <code>힙 정렬(Heap Sort)</code>라고 한다. 현재 V8의 <code>Array.prototype.sort</code> 메소드는 <code>퀵 정렬(Quick Sort)</code>을 사용하고 있지만, 초반에는 힙을 사용하는 정렬 알고리즘인 힙 정렬을 잠깐 사용하기도 했었다.</p><p>어쨌든 그 동안 잊고 있었던 기초적인 자료 구조를 한번 다시 보니 왠지 기분이 좋다.</p><p>힙은 굉장히 다양한 곳에서 사용되고 있는 자료 구조이니 만큼, 알고 있어서 나쁠 게 없기도 하고 면접 때도 꽤 자주 물어봤던 것 같다. 이제 필자는 회사의 비즈니스 로직과 전혀 관련 없는 백수 개발랭이 신분이 되었으니, 그 동안 소홀했던 기초 이론 부분을 이 기회에 조금 더 자세히 공부해봐야겠다.</p><p>이상으로 최소 값과 최대 값을 빠르게 찾을 수 있게 도와주는 힙(Heap) 포스팅을 마친다.</p>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/10/12/introduction-data-structure-heap/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HTTP/3는 왜 UDP를 선택한 것일까?</title>
      <link>https://evan-moon.github.io/2019/10/08/what-is-http3/</link>
      <guid>https://evan-moon.github.io/2019/10/08/what-is-http3/</guid>
      <pubDate>Mon, 07 Oct 2019 16:57:49 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;code&gt;HTTP/3&lt;/code&gt;는 &lt;code&gt;HTTP(Hypertext Transfer Protocol)&lt;/code&gt;의 세 번째 메이저 버전으로, 기존의 HTTP/1, HTTP/2와는 다르게 UDP 기반의 프로토콜인 &lt;code&gt;QUIC&lt;/code&gt;을 사용하여 통신하는 프로토콜이다. HTTP/3와 기존 HTTP 들과 가장 큰 차이점이라면 TCP가 아닌 UDP 기반의 통신을 한다는 것이다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><code>HTTP/3</code>는 <code>HTTP(Hypertext Transfer Protocol)</code>의 세 번째 메이저 버전으로, 기존의 HTTP/1, HTTP/2와는 다르게 UDP 기반의 프로토콜인 <code>QUIC</code>을 사용하여 통신하는 프로토콜이다. HTTP/3와 기존 HTTP 들과 가장 큰 차이점이라면 TCP가 아닌 UDP 기반의 통신을 한다는 것이다.</p><a id="more"></a><p>필자는 최근에 다른 분들이 공유해주시는 포스팅을 보고 나서 HTTP/3가 나왔다는 것을 처음 알게 되었다. 그 포스팅은 <a href="https://blog.cloudflare.com/http3-the-past-present-and-future/" rel="external nofollow noopener noreferrer" target="_blank">HTTP/3: the past, the present, and the future</a>라는 포스팅이었는데, 솔직히 처음 딱 제목만 보고나서 이런 생각을 했었다.</p><blockquote><p>아니, HTTP/2가 공개된지 4년 정도 밖에 안 지났는데 무슨 HTTP/3가 벌써 나와? 그냥 설계하고 있다는 거 아니야?</p></blockquote><p>그런데 포스팅을 읽어 보니 이미 Google Chrome은 HTTP/3를 지원하는 카나리 빌드도 배포되어 있어서 실제로 사용까지 해볼 수 있는 단계에 도달했다는 사실을 알게 되어 놀랐다. HTTP/1에서 HTTP/2로 가는 데만 해도 대략 15년 정도의 시간이 걸렸는데, 고작 4년 만에 바로 사용해볼 수 있는 정도의 완성도인 다음 메이저 버전이 배포되었다는 것이다.</p><p>게다가 아직 전 세계의 HTTP/2 점유율을 보면 40% 정도 밖에 안된다. 그 정도로 HTTP/2가 나온지도 얼마 되지 않았다는 것이다.</p><center><br>  <img src="/2019/10/08/what-is-http3/ce-http2.png" width="500"><br>  <small>W3Techs.com에서 조사한 2019년 8월 HTTP/2 사용률</small><br>  <br><br></center><p>프로그래밍 언어나 프레임워크같은 친구들은 배포하는 쪽에서 업데이트를 쫙 해버리고 유저들이 업데이트를 하면 그만이지만, 프로토콜은 일종의 규약이기 때문에 소프트웨어 제조사 간 합을 맞추는 기간이 필요하므로 이렇게 단기간 안에 급격한 변화가 자주 발생하지 않을 것이라고 생각했다.</p><p>아무리 요즘 기술의 변화가 빠르다지만, HTTP는 나름 웹의 근간이 되는 프로토콜인데 꼴랑 4년 만에 이런 급격한 변화가 일어났다는 게 놀라울 따름이다.<small>(몇 달 전에 HTTP/2를 처음 도입해본 웹 개발자는 웁니다)</small></p><p>그리고 또 한가지 놀랐던 점은 HTTP/3는 <code>TCP</code>가 아닌 <code>UDP</code>를 사용한다는 것이었다. 뭐 딱히 웹 프로토콜이 무조건 TCP만 사용해야 한다는 법이 있는 건 아니긴 하지만, 학교에서 배울 때도 그렇고 실무에서도 실제로 사용할 때도 그렇고 <code>HTTP는 TCP 위에서 정의된 프로토콜</code>이라는 사실이 너무 당연하게 인식되어 있었기 때문에 UDP를 사용한다는 점이 신기하기도 했고 “왜 멀쩡히 잘 돌아가는 TCP를 냅두고 UDP를 사용하는거지?”라는 의문도 들었다.</p><p>사실 HTTP/3는 정식으로 배포된 프로토콜이라기보다 아직 테스트를 거치고 있는 단계라고 보는 게 맞다. 하지만 위에서 이야기 했듯이 Google Chrome은 이미 HTTP/3를 지원하는 카나리 빌드를 배포한 상태이고, Mozila Firefox도 조만간 Nightly 버전에서 HTTP/3를 지원할 예정이며, cURL에서도 HTTP/3를 실험적 기능으로 제공하고 있는 만큼 가까운 미래 안에 HTTP/3가 메인 프로토콜이 될 가능성이 높은 것도 사실이다.</p><p>만약 Google Chrome에서 HTTP/3 프로토콜을 사용해보고 싶다면 터미널에서 <code>--enable-quic</code>과 <code>--quic-version=h3-23</code> 인자를 사용하여 실행하면 된다.</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ open -a Google\ Chrome --args --<span class="hljs-built_in">enable</span>-quic --quic-version=h3-23</span><br></pre></td></tr></table></figure><center><br>  <img src="/2019/10/08/what-is-http3/http3-demo.png" width="500"><br>  <small><code>http/2+quic/46</code>이라고 되어있는 녀석들이 HTTP/3 프로토콜을 사용한 연결이다</small><br>  <br><br></center><p>필자는 웹 개발자이기 때문에 HTTP가 메이저 업데이트 된다는 사실을 그냥 넘기기는 힘들었고, UDP를 사용한다는 것이 뭘 의미하는지도 궁금하기도 해서 결국 HTTP/3에 대한 조사를 하게 되었다. 그래서 이번 포스팅에서는 필자가 여기저기 쑤셔보면서 알아본 HTTP/3에 대한 내용을 정리해볼까 한다.</p><h2 id="HTTP-3에-대한-간단한-소개"><a href="#HTTP-3에-대한-간단한-소개" class="headerlink" title="HTTP/3에 대한 간단한 소개"></a>HTTP/3에 대한 간단한 소개</h2><p>사실 <code>HTTP/3</code>는 처음에는 <code>HTTP-over-QUIC</code>이라는 이름을 가지고 있었는데, <code>IETF(Internet Engineering Task Force)</code> 내 HTTP 작업 그룹과 QUIC 작업 그룹의 의장인 마크 노팅엄이 이 프로토콜의 이름을 HTTP/3로 변경할 것을 제안했고, 2018년 11월에 이 제안이 통과되어 HTTP-over-QUIC이라는 이름에서 HTTP/3으로 변경되게 되었다.</p><p>즉, HTTP/3는 <code>QUIC</code>이라는 프로토콜 위에서 돌아가는 HTTP인 것이다. QUIC은 <code>Quick UDP Internet Connection</code>의 약자로, 말 그대로 UDP를 사용하여 인터넷 연결을 하는 프로토콜이다.<small>(참고로 발음은 그냥 <code>퀵</code>이라고 한다)</small></p><p>HTTP/3는 QUIC을 사용하고, QUIC은 UDP를 사용하기 때문에 결과적으로 <code>HTTP/3는 UDP를 사용한다</code> 라고 이야기 할 수 있는 것이다.</p><p>그렇다면 QUIC이 도대체 뭐길래 기존의 TCP보다 더 빠른 전송 속도를 가질 수 있다는 것일까? 그 이유를 알려면 먼저 TCP가 왜 느리다고 하는지, UDP를 사용함으로써 어떤 이득을 얻을 수 있는지 부터 알아야 한다.</p><h2 id="TCP가-왜-느리다고-하는-걸까"><a href="#TCP가-왜-느리다고-하는-걸까" class="headerlink" title="TCP가 왜 느리다고 하는 걸까?"></a>TCP가 왜 느리다고 하는 걸까?</h2><p>필자는 학교에서 네트워크 강의를 들을 때 <code>TCP</code>와 <code>UDP</code>의 차이에 대한 내용을 처음 배웠었는데, 교수님이 이건 반드시 시험에 나온다길래 이런 표를 보면서 열심히 외웠던 기억이 난다.</p><table><thead><tr><th></th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>연결 방식</td><td>연결형 서비스</td><td>비연결형 서비스</td></tr><tr><td>패킷 교환</td><td>가상 회선 방식</td><td>데이터그램 방식</td></tr><tr><td>전송 순서 보장</td><td>보장함</td><td>보장하지 않음</td></tr><tr><td>신뢰성</td><td>높음</td><td>낮음</td></tr><tr><td>전송 속도</td><td>느림</td><td>빠름</td></tr></tbody></table><p>위 표를 보면 대략 TCP는 <code>신뢰성이 높고 느리다</code>, UDP는 <code>신뢰성이 낮고 빠르다</code> 정도로 정리가 되는데, 여기서 말하는 신뢰성이란 전송되는 데이터 패킷들의 순서, 패킷 유실 여부 등을 검사하여 송신 측이 보낸 모든 데이터가 수신 측에 온전하게 전달이 될 수 있느냐를 말하는 것이다.</p><p>TCP는 클라이언트와 서버가 서로 신뢰성있는 통신을 할 수 있도록 몇 가지 방법을 사용하게되는데, 이 방법들 또한 결국은 클라이언트와 서버 간의 통신이기 때문에 레이턴시가 발생할 수 밖에 없다. 게다가 이 과정은 TCP라는 프로토콜이 생길 때부터 정의된 <code>표준</code>이므로 무시할 수도 없다.</p><p>그렇다면 레이턴시를 줄이기 위해서는 TCP에서 정의한 기능 외에 다른 부분들을 건드려야 한다는 것인데, 여러모로 제한 사항이 많다. 아무리 회선의 대역폭을 늘린다고 해도 기술이 발전하면서 전송해야하는 데이터의 크기도 점점 커지기 때문에 결국 언젠가는 또 느려질 것이고, 회선의 전송 속도 자체를 높힌다고 해도 결국은 빛의 속도 보다 빠르게 전송할 수 없기 때문에 한계가 있다.</p><p>HTTP/3이 UDP 기반인 QUIC 프로토콜을 사용하는 이유가 바로 이런 제약 조건을 뛰어넘기 위해 프로토콜 자체를 손보는 방법을 택한 것이다. 하지만 TCP는 워낙 오래된 프로토콜이기도 하고 커널까지 내려가는 로우 레벨에서 정의되어 있기 때문에 이걸 뜯어고치는 것도 만만치 않은 대작업이라 UDP를 선택한 것이다.</p><p>그럼 한번 TCP가 신뢰성 있는 통신을 위해 사용하는 방법들이 왜 느리다고 하는지 알아보자.</p><h3 id="3-Way-Handshake"><a href="#3-Way-Handshake" class="headerlink" title="3 Way Handshake"></a>3 Way Handshake</h3><p>TCP는 굉장히 친절한 프로토콜이다. 통신을 시작할 때와 종료할 때 서로 준비가 되어있는지를 반드시 먼저 물어보고 패킷을 전송할 순서를 정하고 나서야 본격적인 통신을 시작하기 때문이다.</p><p>이때 통신을 시작할 때 거치는 과정을 <code>3 Way Handshake</code>, 통신을 마칠 때 거치는 과정을 <code>4 Way Handshake</code>라고 한다. 이 포스팅의 목적은 이 과정을 자세히 다루는 것이 아니므로, TCP를 사용하여 통신을 시작할 때 거치는 과정인 3 Way Handshake가 어떤 원리로 작동하는지만 설명하겠다.</p><center><br>  <img src="/2019/10/08/what-is-http3/3way-handshake.png" width="500"><br>  <small>통신을 시작할 때 3 Way Handshake를 하는 과정</small><br>  <br><br></center><p>위 그림을 보면 클라이언트가 처음 서버와 통신을 하기 위해 TCP 연결을 생성할 때 <code>SYN</code>와 <code>ACK</code>이라는 패킷을 주고 받고 있다. 이 패킷 내부에 들어있는 값들을 사용하여 클라이언트와 서버가 서로 보낸 패킷의 순서와 패킷을 제대로 받았는 지를 확인할 수 있는 것이다.</p><p>그리고 이 과정에는 총 3번의 통신이 필요하다. OSX나 Linux를 사용하고 있는 분이라면 터미널에서 <code>tcpdump</code> 유틸리티를 사용하여 이 과정을 직접 눈으로 확인해볼 수 있다.</p><p>단, <code>tcpdump</code>를 아무 옵션 없이 사용하면 디바이스의 모든 패킷을 감시하고 출력하기 때문에 원하는 정보를 찾기 힘들다. 그래서 필자는 루프백에서 동작하고 있는 블로그 서버와의 통신만 캡쳐해보았다.</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tcpdump host localhost -i lo0</span><br><span class="line">IP localhost.53920 &gt; localhost.terabase: Flags [S], seq 1260460927, win 65535</span><br><span class="line">IP localhost.terabase &gt; localhost.53920: Flags [S.], seq 3009967847, ack 1260460928, win 65535</span><br><span class="line">IP localhost.53920 &gt; localhost.terabase: Flags [.], ack 3009967848, win 6379</span><br></pre></td></tr></table></figure><blockquote><p>보낸 놈 &gt; 받은 놈: Flags [플래그 종류], 헤더의 값들</p></blockquote><p>원래는 이것보다 더 많은 정보가 나오지만, 여기에 전부 기재하기에는 양이 너무 많으니 설명에 필요한 정보만 추려보았다. 이 로그에서 중요한 키워드는 <code>Flag</code>, <code>seq</code>, <code>ack</code> 정도이다. 한번 하나하나 뜯어보도록 하자.</p><p>먼저 <code>localhost.53920</code>은 클라이언트, <code>localhost.terabase</code>는 서버를 의미한다. 각 라인의 첫번째 필드는 <code>보낸 놈 &gt; 받은 놈</code>을 의미하고 있으니, 첫 패킷은 클라이언트가 서버에게, 두 번째 패킷은 서버가 클라이언트에게 보낸 것이라고 할 수 있다. 그리고 각 라인에는 <code>Flag</code>라는 것이 붙어있는데, 플래그는 이 패킷이 어떤 타입의 패킷인지를 알려주는 역할을 한다.</p><table><thead><tr><th>Flag</th><th>이름</th><th>의미</th></tr></thead><tbody><tr><td>S</td><td>SYN</td><td>연결을 생성할 때 클라이언트가 서버에 시퀀스 번호를 보내는 패킷</td></tr><tr><td>S.</td><td>SYN-ACK</td><td>시퀀스 번호를 받은 서버가 ACK 값을 생성하여 클라이언트에게 응답하는 패킷</td></tr><tr><td>.</td><td>ACK</td><td>ACK 값을 사용하여 응답하는 패킷</td></tr></tbody></table><p>이 통신 과정을 거치고 나면 클라이언트와 서버는 신뢰성 있는 TCP 연결을 생성할 수 있고, 이때 총 3회의 통신을 하기 때문에 3 Way Handshake라고 하는 것이다.</p><p>그렇다면 이 과정에서 어떤 일이 벌어지길래 신뢰성 있는 연결을 생성할 수 있다는 것일까? 조금 더 자세히 들여다보면 클라이언트와 서버는 3 Way Handshake를 할 때 대략 이런 과정을 거치고 있다.</p><blockquote><p>1번 라인: 클라이언트가 서버로 시퀀스 번호를 <code>seq</code> 필드에 담아 보냄<br>2번 라인: 서버는 클라이언트가 보내준 시퀀스 번호를 1 증가시켜서 <code>ack</code> 필드에 담아 보냄<br>3번 라인: 클라이언트는 다시 서버로부터 받은 시퀀스 번호를 1 증가시켜서 자신의 <code>ack</code> 필드에 담아 보냄</p></blockquote><p>새로운 TCP 연결을 생성하고자 할 때 클라이언트가 서버에게 랜덤한 시퀀스 번호를 전송함으로써 3 Way Handshake가 시작된다. 이때 생성된 시퀀스 번호는 이후 송신 측이 전송한 패킷을 수신 측이 재조립할때 패킷의 조립 순서를 알려주는 역할을 한다.</p><p>이때 클라이언트와 서버는 상대방이 보내준 <code>seq(시퀀스 번호)</code>를 1 증가 시킨 후 자신의 <code>ack(승인 번호)</code> 필드에 담아서 보내는데, “지금 이 패킷이 니가 전에 보낸 시퀀스 번호의 다음으로 이어지는 패킷이야”라고 말하고 있는 것이다.</p><p>이 3회의 통신이 바로 3 Way Handshake이다. 이 과정을 통해 클라이언트와 서버는 데이터를 주고 받을 준비가 되었다는 것을 서로에게 알려주고 이후 데이터 전송에 필요한 시퀀스 번호를 알 수 있게 된다. 연결을 끊을 때도 마찬가지로 이와 비슷한 과정인 4 Way Handshake를 거치고 나서야 세션을 종료할 수 있으며, 이때는 총 4회의 통신을 통해 연결을 종료한다.</p><p>즉, TCP를 사용하는 이상 본격적인 통신을 시작하기 전에 무조건 저 번거로운 통신 과정을 거쳐야한다는 것이다.</p><p>HTTP/1은 하나의 TCP 연결에 하나의 요청만 처리하고 연결을 끊어버렸기 때문에 매 요청마다 이 번거로운 핸드쉐이크를 거쳐야 했다. 그래서 HTTP/2에서는 핸드쉐이크를 최소화하기 위해서 단일 TCP 연결을 유지하면서 여러 개의 요청을 처리할 수 있도록 변경된 것이다.</p><p>결국 HTTP/1에서 HTTP/2로 넘어갈 때도 핸드쉐이크 과정 자체는 건드리지 않았고 단지 핸드쉐이크가 발생하는 횟수를 최소화함으로써 레이턴시를 줄인 것이다. 이는 TCP를 사용하는 이상 핸드쉐이크가 반드시 필요한 과정이기 때문에 건드리지 못한 것이다. </p><p>그러나 HTTP/3는 UDP를 사용함으로써 이 핸드쉐이크 과정 자체를 날려버리고 다른 방법으로 연결의 신뢰성을 확보함으로써 레이턴시를 줄이는 방법을 택했다.</p><h3 id="HOLB-Head-of-line-Blocking"><a href="#HOLB-Head-of-line-Blocking" class="headerlink" title="HOLB(Head of line Blocking)"></a>HOLB(Head of line Blocking)</h3><p>그 외에도 TCP를 사용하는 기존의 HTTP에는 한 가지 문제가 더 있는데, 바로 <code>HOLB(Head of Line Blocking)</code>이라고 하는 문제이다. 사실 HTTP 레벨에서의 HOLB와 TCP 레벨에서의 HOLB는 다른 의미이기는 하나 결국 어떤 요청에 병목이 생겨서 전체적인 레이턴시가 늘어난다는 맥락으로 본다면 동일하다고 할 수 있다.</p><p>TCP를 사용한 통신에서 패킷은 무조건 정확한 순서대로 처리되어야 한다. 수신 측은 송신 측과 주고받은 시퀀스 번호를 참고하여 패킷을 재조립해야하기 때문이다.</p><p>그래서 통신 중간에 패킷이 손실되면 완전한 데이터로 다시 조립할 수 없기 때문에 절대로 그냥 넘어가지 않는다. 무조건 송신 측은 수신 측이 패킷을 제대로 다 받았다는 것을 확인한 후, 만약 수신 측이 제대로 패킷을 받지 못했으면 해당 패킷을 다시 보내야 한다.</p><p>또한 패킷이 처리되는 순서 또한 정해져있으므로 이전에 받은 패킷을 파싱하기 전까지는 다음 패킷을 처리할 수도 없다. 이렇게 패킷이 중간에 유실되거나 수신 측의 패킷 파싱 속도가 느리다면 통신에 병목이 발생하게 되는 현상을 <code>HOLB</code>라고 부르는 것이다. 이건 TCP 자체의 문제이므로 HTTP/1 뿐만 아니라 HTTP/2도 가지고 있는 문제이다.</p><p>이런 문제들을 해결하기 위해 HTTP/3는 UDP를 기반으로 만들어진 프로토콜인 QUIC 위에서 작동하는 것을 선택한 것이다. 그럼 이제 QUIC가 정확히 어떤 프로토콜인지, UDP를 사용한다는 것이 TCP에 비해서 어떤 장점이 있다는 것인지를 알아보자.</p><h2 id="HTTP-3가-UDP를-사용하는-이유"><a href="#HTTP-3가-UDP를-사용하는-이유" class="headerlink" title="HTTP/3가 UDP를 사용하는 이유"></a>HTTP/3가 UDP를 사용하는 이유</h2><p>HTTP/3는 <code>QUIC</code>을 기반으로 돌아가는 프로토콜이기 때문에 우리가 HTTP/3를 이해하려면 QUIC에 초점을 맞춰야 한다. QUIC은 TCP가 가지고 있는 이런 문제들을 해결하고 레이턴시의 한계를 뛰어넘고자 구글이 개발한 UDP 기반의 프로토콜이다.</p><p>QUIC은 처음부터 TCP의 핸드쉐이크 과정을 최적화하는 것에 초점을 맞추어 설계되었고, UDP를 사용함으로써 이를 실현해낼 수 있었다.</p><center><br>  <img src="/2019/10/08/what-is-http3/quic.png" width="350"><br>  <br><br></center><p>UDP는 User Datagram Protocol이라는 이름에서도 알 수 있듯이 데이터그램 방식을 사용하는 프로토콜이기 때문에 애초에 각각의 패킷 간의 순서가 존재하지 않는 독립적인 패킷을 사용한다. 또한 데이터그램 방식은 패킷의 목적지만 정해져있다면 중간 경로는 어딜 타든 신경쓰지 않기 때문에 종단 간의 연결 설정 또한 하지 않는다. 즉, 핸드쉐이크 과정이 필요없다는 것이다.</p><p>결론적으로 UDP는 TCP가 신뢰성을 확보하기 위해 거치던 많은 과정을 거치지 않기 때문에 속도가 더 빠를 수 밖에 없다는 것인데, 그렇다면 UDP를 사용하게되면 기존의 TCP가 가지던 신뢰성과 패킷의 무결함도 함께 사라지는 걸까?</p><p>아니 그렇지 않다. UDP를 사용하더라도 기존의 TCP가 가지고 있던 기능을 전부 구현할 수 있다. UDP의 진짜 장점은 바로 <code>커스터마이징이 용이하다</code>는 것이기 때문이다.</p><h3 id="UDP는-하얀-도화지-같은-프로토콜이다"><a href="#UDP는-하얀-도화지-같은-프로토콜이다" class="headerlink" title="UDP는 하얀 도화지 같은 프로토콜이다"></a>UDP는 하얀 도화지 같은 프로토콜이다</h3><p>필자는 학교에서 UDP와 TCP의 가장 큰 차이점으로 <code>UDP는 TCP보다 신뢰성이 없는 대신 빠르다</code>라고 배웠었는데, 사실 이 말은 반은 맞고 반은 틀리다.</p><p>왜냐면 애초에 UDP는 데이터 전송을 제외한 그 어떤 기능도 정의되어 있지 않은 프로토콜이기 때문에 프로토콜 자체적으로 신뢰성을 보장하지 않는 것은 맞지만, 다르게 말하자면 데이터 전송 기능을 제외한 아무 기능이 없는 백지 상태의 프로토콜이라고도 할 수 있기 때문이다. TCP가 신뢰성있는 연결과 혼잡 제어 등을 위해 얼마나 많은 기능을 가지고 있는 지는 TCP의 헤더를 보면 대충 각이 나온다.</p><center><br>  <img src="/2019/10/08/what-is-http3/tcp-header.png"><br>  <small>이미 정보들이 뚱뚱하게 들어찬 TCP의 헤더</small><br>  <br><br></center><p>TCP의 경우 워낙 오래 전에 설계되기도 했고, 이런 저런 기능이 워낙 많이 포함된 프로토콜이다보니 이미 헤더가 거의 풀방이다. TCP에 기본적으로 정의되어 있는 기능 외에 다른 추가 기능을 구현하고 싶다면 가장 하단에 있는 <code>옵션(Options)</code> 필드를 사용해야 하는데, 옵션 필드도 무한정 배당 해줄 수는 없으니 최대 크기를 <code>320 bits</code>로 정해놓았다.</p><p>그러나 TCP의 단점을 보완하기 위해 나중에 정의된 <code>MSS(Maximum Segment Size)</code>, <code>WSCALE(Window Scale factor)</code>, <code>SACK(Selective ACK)</code> 등 많은 옵션들이 이미 옵션 필드를 차지하고 있기 때문에 실질적으로 사용자가 커스텀 기능을 구현할 수 있는 자리는 거의 남지도 않았다.</p><p>반면 UDP는 데이터 전송 자체에만 초점을 맞추고 설계되었기 때문에 헤더에 진짜 아무 것도 없다.</p><center><br>  <img src="/2019/10/08/what-is-http3/udp-header.png"><br>  <small>TCP와 비교해보면 확실히 휑한 UDP의 헤더</small><br>  <br><br></center><p>UDP의 헤더에는 출발지와 도착지, 패킷의 길이, 체크섬 밖에 없다. 이때 체크섬은 패킷의 무결성을 확인하기 위해 사용되는데, TCP의 체크섬과는 다르게 UDP의 체크섬은 사용해도 되고 안해도 되는 옵션이다.</p><p>즉, UDP 프로토콜 자체는 TCP보다 신뢰성이 낮기도 하고 흐름 제어도 안되지만, 이후 개발자가 어플리케이션에서 구현을 어떻게 하냐에 따라서 TCP와 비슷한 수준의 기능을 가질 수도 있다는 것이다.</p><p>물론 TCP가 신뢰성을 확보하기위해 이런 저런 기능을 제공해주는 것이 개발자 입장에서는 편하고 좋지만, 한가지 슬픈 점은 이 기능들이 프로토콜 자체에 정의된 <code>필수 과정</code>이라서 개발자가 맘대로 커스터마이징 할 수 없다는 것이다. 결국 여기서 발생하는 레이턴시들을 어떻게 더 줄여볼 시도조차 하기 힘들다.</p><center><br>  <img src="/2019/10/08/what-is-http3/tcp-tls.png" width="400"><br>  <small>TCP에 TLS까지 사용한다면 통신을 시작하기도 전에 이렇게 많은 과정을 거쳐야 한다</small><br>  <br><br></center><p>결국 레이턴시를 줄이려면 프로토콜 외적인 것들을 건드려야 하는데, 위에서 이야기 했듯이 일반적인 개발자가 통신 과정에서 건드릴 수 있는 영역은 한계가 있기 때문에 이 또한 어려운 것이 사실이다.<small>(통신 업계의 큰 손 형님들이 인프라를 깔아주시는 걸 기다리자)</small></p><p>아직 TCP와 UDP의 차이가 잘 와닿지 않는다면 <code>좋은 기능이 다 들어있는 무거운 라이브러리</code>와 <code>필요한 기능만 들어있는 가벼운 라이브러리</code>로 비교해보면 조금 더 이해가 빠를 것 같다.</p><p>예를 들어 JavaScript 진영에서 많이 사용하는 <code>lodash</code>와 같은 라이브러리는 기능은 무궁무진하고 사용자에게 큰 편리함을 주지만, 보통 lodash의 모든 메소드를 다 사용하는 사람은 많지 않을 것이다. 결국 편하긴 하지만 내가 사용하지 않는 기능까지 전부 내 JS 번들에 포함시켜야 한다는 부담이 있다.</p><p>반면 단순한 하나의 기능을 제공하는 라이브러리는 lodash보다 기능은 많지 않아도 내가 원하는 부분만 쏙쏙 골라서 사용할 수 있다는 장점이 있다. 하지만 해당 라이브러리에서 지원하지 않는 기능은 직접 구현해야하는 번거로움이 있을 수도 있다. 이때 lodash와 같은 만능 라이브러리가 TCP, 하나의 기능만 제공하는 작은 라이브러리가 UDP인 것이다.</p><p>이렇듯 구글이 QUIC을 만들 때 UDP를 선택한 이유에는 기존의 TCP를 수정하기가 어려운데다가, 백지 상태나 다름 없는 UDP를 사용함으로써 QUIC의 기능을 확장하기 쉽다고 생각했기 때문이라는 것도 있다.</p><h2 id="HTTP-3가-UDP를-사용함으로써-기존-프로토콜보다-나아진-점"><a href="#HTTP-3가-UDP를-사용함으로써-기존-프로토콜보다-나아진-점" class="headerlink" title="HTTP/3가 UDP를 사용함으로써 기존 프로토콜보다 나아진 점"></a>HTTP/3가 UDP를 사용함으로써 기존 프로토콜보다 나아진 점</h2><p>지금까지 HTTP/3의 뼈대로 사용되는 QUIC이 왜 TCP가 아닌 UDP를 사용했는지 간략하게 알아보았다. 그렇다면 실제로 UDP를 사용함으로써 얻는 이득에는 무엇이 있을까? 진짜로 HTTP/3는 UDP를 사용함으로써 기존의 <code>HTTP+TCP+TLS</code>를 사용했던 방법보다 더 좋아진 것 일까?</p><p>그에 대한 해답은 Chromium Projects의 <a href="https://docs.google.com/document/d/1gY9-YNDNAB1eip-RTPbqphgySwSNSDHLq9D5Bty4FSU/edit" rel="external nofollow noopener noreferrer" target="_blank">QUIC Overview</a>라는 문서에서 찾을 수 있었다. 한번 구글이 이야기하는 QUIC의 장점에 대해서 살펴보자.</p><h3 id="연결-설정-시-레이턴시-감소"><a href="#연결-설정-시-레이턴시-감소" class="headerlink" title="연결 설정 시 레이턴시 감소"></a>연결 설정 시 레이턴시 감소</h3><p>QUIC은 TCP를 사용하지 않기 때문에 통신을 시작할 때 번거로운 3 Way Handshake 과정을 거치지 않아도 된다. 클라이언트가 보낸 요청을 서버가 처리한 후 다시 클라이언트로 응답해주는 사이클을 <code>RTT(Round Trip Time)</code>이라고 하는데, TCP는 연결을 생성하기 위해 기본적으로 <code>1 RTT</code>가 필요하고, 여기에 TLS를 사용한 암호화까지 하려고 한다면 TLS의 자체 핸드쉐이크까지 더해져 총 <code>3 RTT</code>가 필요하다.</p><p>반면 QUIC은 첫 연결 설정에 <code>1 RTT</code>만 소요된다. 클라이언트가 서버에 어떤 신호를 한번 주고, 서버도 거기에 응답하기만 하면 바로 본 통신을 시작할 수 있다는 것이다. 즉, 연결 설정에 소요되는 시간이 반 정도 밖에 안된다.</p><center><br>  <img src="/2019/10/08/what-is-http3/gcp-cloud-cdn-performance.gif" width="500"><br>  <br><br></center><p>어떻게 이게 가능한 걸까? 그 이유는 생각보다 간단하다. 첫번째 핸드쉐이크를 거칠 때, 연결 설정에 필요한 정보와 함께 데이터도 보내버리는 것이다. <code>TCP+TLS</code>는 데이터를 보내기 전에 신뢰성있는 연결과 암호화에 필요한 모든 정보를 교환하고 유효성을 검사한 뒤에 데이터를 교환하지만, QUIC은 묻지도 따지지도 않고 그냥 바로 데이터부터 꽂아버리고 시작한다.</p><p>이 과정에 대해서는 2015년 IEEE Symposium에서 발표된 <code>How Secure and Quick is QUIC?</code>이라는 세션에서 자세히 들어볼 수 있다.</p><center><br>  <div class="video-container"><iframe src="//www.youtube.com/embed/vXgbPZ-1-us?start=206" frameborder="0" allowfullscreen></iframe></div><br>  <small>한 손 주머니에 꽂고 발표하는 모습에서 스웩이 넘친다</small><br>  <br><br></center><p>결국 이 영상에서 말하고자 하는 것은 TCP+TLS는 서로 자신의 세션 키를 주고 받아 암호화된 연결을 성립하는 과정을 거치고 나서야 세션 키와 함께 데이터를 교환할 수 있지만, QUIC은 서로의 세션 키를 교환하기도 전에 데이터를 교환할 수 있기 때문에 연결 설정이 더 빠르다는 것이다.</p><p>단, 클라이언트가 서버로 첫 요청을 보낼 때는 서버의 세션 키를 모르는 상태이기 때문에 목적지인 서버의 Connection ID를 사용하여 생성한 특별한 키인 <code>초기화 키(Initial Key)</code>를 사용하여 통신을 암호화 한다. 이 과정에 대한 자세한 설명은 QUIC 작업 그룹의 <a href="https://quicwg.org/base-drafts/draft-ietf-quic-tls.html#rfc.section.5.2" rel="external nofollow noopener noreferrer" target="_blank">Using TLS to Secure QUIC</a> 문서에서 확인 해볼 수 있다.</p><p>그리고 한번 연결에 성공했다면 서버는 그 설정을 캐싱해놓고 있다가, 다음 연결 때는 캐싱해놓은 설정을 사용하여 바로 연결을 성립시키기 때문에 <code>0 RTT</code>만으로 바로 통신을 시작할 수도 있다. 이런 점들 때문에 QUIC은 기존의 TCP+TLS 방식에 비해 레이턴시를 더 줄일 수 있었던 것이다.</p><p>참고로 이 세션이 발표될 당시에는 <code>TLS 1.3</code>이 나오기 전이라 따로 언급이 되지 않았지만, 지금은 <code>TCP Fast Open</code>과 <code>TLS 1.3</code>을 사용하여 QUIC와 비슷한 과정을 통해 연결을 설정함으로써 TCP를 사용하더라도 동일한 이점을 가져갈 수도 있긴하다.</p><p>그러나 TCP SYN 패킷은 한 패킷당 약 <code>1460 Byte</code>만 전송할 수 있도록 제한하지만 QUIC은 데이터 전체를 첫 번째 라운드 트립에 포함해서 전송할 수 있기 때문에 주고 받아야할 데이터가 큰 경우에는 여전히 QUIC가 유리하다고 할 수 있다.</p><h3 id="패킷-손실-감지에-걸리는-시간-단축"><a href="#패킷-손실-감지에-걸리는-시간-단축" class="headerlink" title="패킷 손실 감지에 걸리는 시간 단축"></a>패킷 손실 감지에 걸리는 시간 단축</h3><p>QUIC도 TCP와 마찬가지로 전송하는 패킷에 대한 흐름 제어를 해야한다. 왜냐면 QUIC든 TCP든 결국 본질적으로는 <code>ARQ</code> 방식을 사용하는 프로토콜이기 때문이다. 통신과정에서 발생한 에러를 어떻게 처리할 것인지를 이야기하는 것인데, ARQ 방식은 에러가 발생하면 재전송을 통해 에러를 복구하는 방식을 말하는 것이다.</p><p>TCP는 여러 ARQ 방식 중에서 <code>Stop and Wait ARQ</code> 방식을 사용하고 있다. 이 방식은 송신 측이 패킷을 보낸 후 타이머를 사용하여 시간을 재고, 일정 시간이 경과해도 수신 측이 적절한 답변을 주지 않는다면 패킷이 손실된 것으로 판단하고 해당 패킷을 다시 보내는 방식이다.</p><p>우선 2017년 구글에서 발표한 <a href="https://datatracker.ietf.org/doc/draft-ietf-quic-recovery/?include_text=1" rel="external nofollow noopener noreferrer" target="_blank">QUIC Loss Detection and Congestion Control</a>에 따르면, QUIC은 기본적으로 TCP와 유사한 방법으로 패킷 손실을 탐지하나, 몇 가지 개선 사항을 추가한 것으로 보인다.</p><p>TCP에서 패킷 손실 감지에 대한 대표적인 문제는 송신 측이 패킷을 수신측으로 보내고 난 후 얼마나 기다려줄 것인가, 즉 타임 아웃을 언제 낼 것인가를 동적으로 계산해야한다는 것이다. 이때 이 시간을 <code>RTO(Retransmission Time Out)</code>라고 하는데, 이때 필요한 데이터가 바로 <code>RTT(Round Trip Time)</code>들의 샘플들이다.</p><p>한번 패킷을 보낸 후 잘 받았다는 응답을 받을 때 걸렸던 시간들을 측정해서 동적으로 타임 아웃을 정하는 것이다. 즉, RTT 샘플을 측정하기 위해서는 반드시 송신 측으로 부터 ACK를 받아야하는데, 정상적인 상황에서는 딱히 문제가 없으나 타임 아웃이 발생해서 패킷 손실이 발생하게 되면 RTT 계산이 애매해진다.</p><blockquote><p>패킷 전송 -&gt; 타임 아웃 -&gt; 패킷 재전송 -&gt; ACK 받음!<br><small>(근데 이거 첫 번째로 보낸 패킷의 ACK야? 두 번째로 보낸 패킷의 ACK야?)</small></p></blockquote><p>이때 이 ACK가 어느 패킷에 대한 응답인지 알기 위해서는 타임스탬프를 패킷에 찍어주는 등 별도의 방법을 또 사용해야하고, 또 이를 위한 패킷 검사도 따로 해줘야 한다. 이를 <code>재전송 모호성(Retransmission Ambiguity)</code>이라고 한다.</p><p>이 문제를 해결하기 위해 QUIC는 헤더에 별도의 패킷 번호 공간을 부여했다. 이 패킷 번호는 패킷의 전송 순서 자체만을 나타내며, 재전송시 동일한 번호가 전송되는 시퀀스 번호와는 다르게 매 전송마다 모노토닉하게 패킷 번호가 증가하기 때문에, 패킷의 전송 순서를 명확하게 파악할 수 있다.</p><p>TCP의 경우 타임스탬프를 사용할 수 있는 상황이라면 타임스탬프를 통해 패킷의 전송 순서를 파악할 수 있지만, 만약 사용할 수 없는 경우 시퀀스 번호에 기반하여 암묵적으로 전송 순서를 추론할 수 밖에 없지만, QUIC는 이런 불필요한 과정을 패킷마다 고유한 패킷 번호를 통해 타파함으로써 패킷 손실 감지에 걸리는 시간을 단축할 수 있었다.</p><p>이 외에도 QUIC는 대략 5가지 정도의 기법을 사용하여 이 패킷 손실 감지에 걸리는 시간을 단축시켰는데, 자세한 내용은 <a href="https://datatracker.ietf.org/doc/draft-ietf-quic-recovery/?include_text=1" rel="external nofollow noopener noreferrer" target="_blank">QUIC Loss Detection and Congestion Control</a>의 <code>3.1 Relevant Differences Between QUIC and TCP</code> 챕터를 한번 읽어보는 것을 추천한다.</p><h3 id="멀티플렉싱을-지원"><a href="#멀티플렉싱을-지원" class="headerlink" title="멀티플렉싱을 지원"></a>멀티플렉싱을 지원</h3><p><code>멀티플렉싱(Multiplexing)</code>은 위에서 TCP의 단점으로 언급했던 <code>HOLB(Head of Line Blocking)</code>을 방지하기 때문에 매우 중요하다. 여러 개의 스트림을 사용하면, 그 중 특정 스트림의 패킷이 손실되었다고 하더라도 해당 스트림에만 영향을 미치고 나머지 스트림은 멀쩡하게 굴릴 수 있기 때문이다.</p><p>참고로 멀티플렉싱은 여러 개의 TCP 연결을 만든다는 의미가 아니라, 단일 연결 안에서 몇 가지 얌생이를 사용하여 여러 개의 데이터를 섞이지 않게 보내는 기법이다. 이때 각각의 데이터의 흐름을 <code>스트림</code>이라고 하는 것이다.</p><p>HTTP/1의 경우는 하나의 TCP 연결에 하나의 스트림만 사용하기 때문에 HOLB 문제에서 벗어날 수 없었다. 또한 한번의 전송이 끝나게 되면 연결이 끊어지기 때문에 다시 연결을 만들기 위해서는 번거로운 핸드쉐이크 과정을 또 겪어야 했다.</p><p>비록 <code>keep-alive</code> 옵션을 통해 어느 정도의 시간 동안 연결을 유지할 수는 있지만 결국 일정 시간 안에 액세스가 없다면 연결이 끊어지게 되는 것은 똑같다.</p><p>그리고 HTTP/2는 하나의 TCP 연결 안에서 여러 개의 스트림을 처리하는 멀티플렉싱 기법을 도입하여 성능을 끌어올린 케이스이다. 이 경우 한번의 TCP 연결로 여러 개의 데이터를 전송할 수 있기 때문에 핸드쉐이크 횟수도 줄어들게 되어 효율적인 데이터 전송을 할 수 있게 된다.</p><center><br>  <img src="/2019/10/08/what-is-http3/multiplexing.svg" width="500"><br>  <small>HTTP/3도 HTTP/2와 같은 멀티플렉싱을 지원한다.</small><br>  <br><br></center><p>QUIC 또한 HTTP/2와 동일하게 멀티플렉싱을 지원하기 때문에, 이런 이점을 그대로 가져가고 있다. 혹여나 하나의 스트림에서 문제가 발생한다고 해도 다른 스트림은 지킬 수 있게 되어 이런 문제에서 자유로울 수 있다.</p><h3 id="클라이언트의-IP가-바뀌어도-연결이-유지됨"><a href="#클라이언트의-IP가-바뀌어도-연결이-유지됨" class="headerlink" title="클라이언트의 IP가 바뀌어도 연결이 유지됨"></a>클라이언트의 IP가 바뀌어도 연결이 유지됨</h3><p>TCP의 경우 소스의 IP 주소와 포트, 연결 대상의 IP 주소와 포트로 연결을 식별하기 때문에 클라이언트의 IP가 바뀌는 상황이 발생하면 연결이 끊어져 버린다. 연결이 끊어졌으니 다시 연결을 생성하기 위해 결국 눈물나는 3 Way Handshake 과정을 다시 거쳐야한다는 것이고, 이 과정에서 다시 레이턴시가 발생한다.</p><p>게다가 요즘에는 모바일로 인터넷을 사용하는 경우가 많기 때문에 Wi-fi에서 셀룰러로 전환되거나 그 반대의 경우, 혹은 다른 Wi-fi로 연결되는 경우와 같이 클라이언트의 IP가 변경되는 일이 굉장히 잦아서 이 문제가 더 눈에 띈다.</p><p>반면 QUIC은 Connection ID를 사용하여 서버와 연결을 생성한다. Connection ID는 랜덤한 값일 뿐, 클라이언트의 IP와는 전혀 무관한 데이터이기 때문에 클라이언트의 IP가 변경되더라도 기존의 연결을 계속 유지할 수 있다. 이는 새로 연결을 생성할 때 거쳐야하는 핸드쉐이크 과정을 생략할 수 있다는 의미이다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>사실 HTTP/3와 QUIC을 제대로 설명하기 위해서는 네트워크에 대한 기본 개념들이 필수적으로 동반되야하기 때문에 이 짧은 포스팅 만으로 세부적인 설명을 하기 힘든 부분이 있었다. 최대한 자세하게 작성해보려고 했지만 생각보다 글이 너무 길어지게 되어서 분량 조절을 조금 하려고 한다.</p><p>이번에 HTTP/3를 공부해보고 여러가지 자료를 찾아보면서 느낀 점은 “뭐가 이렇게 많이 바뀌었어?” 였던 것 같다. 일단 TCP부터 갖다 버렸으니 뭐가 많이 바뀔만 하긴 했지만, HTTP/2를 사용해본지도 몇 달 밖에 되지 않은 필자의 입장에서는 조금 당황스럽기는 했다.<small>(HTTP를 만든다면서 TCP를 갖다 버린 건 아직도 신기하다)</small></p><p>사실 개발자들이 HTTP/2를 사용하든 HTTP/3를 사용하든 한국에서 인터넷을 사용하고 있는 사용자는 별로 큰 차이를 못 느낄 것이다. 한국은 워낙 땅덩이도 작고 통신 인프라도 좋다보니 핸드쉐이크 레이턴시고 나발이고 그냥 인프라로 대충 커버칠 수 있지만, 그래도 상대적으로 통신 인프라가 빈약한 나라의 경우에는 꽤 큰 차이가 느껴질 수도 있을 것 같다.</p><p>필자가 이 포스팅에서는 HTTP/3와 UDP의 장점만을 이야기했지만, 사실 많은 사람들이 TCP를 버리고 UDP로 갈아타는 것에 대해서 걱정하고 있다. 당연히 완벽한 기술이란 없으니 문제도 있을 것이다.</p><p>그러나 기존의 HTTP와 TCP가 가지고 있는 한계를 돌파하기 위한 시도로는 굉장히 좋은 것 같다. 마치 엔비디아의 RTX 시리즈 같은 느낌이랄까.</p><p>이상으로 HTTP/3는 왜 UDP를 선택한 것일까? 포스팅을 마친다.</p><h2 id="참고-링크"><a href="#참고-링크" class="headerlink" title="참고 링크"></a>참고 링크</h2><ul><li><a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/46403.pdf" rel="external nofollow noopener noreferrer" target="_blank">The QUIC Transport Protocol: Design and Internet-Scale Deployment</a></li><li><a href="https://medium.com/codavel-blog/quic-vs-tcp-tls-and-why-quic-is-not-the-next-big-thing-d4ef59143efd" rel="external nofollow noopener noreferrer" target="_blank">QUIC vs TCP+TLS - and why QUIC is not the next big thing</a></li><li><a href="https://blog.cloudflare.com/http3-the-past-present-and-future/" rel="external nofollow noopener noreferrer" target="_blank">HTTP/3: the past, the present, and the future</a></li><li><a href="https://www.saturnsoft.net/network/2019/03/21/quic-http3-1/" rel="external nofollow noopener noreferrer" target="_blank">QUIC과 HTTP/3 - 1.UDP기반 전송 프로토콜의 대두</a></li><li><a href="https://www.chromium.org/quic" rel="external nofollow noopener noreferrer" target="_blank">QUIC, a multiplexed stream transport over UDP</a></li><li><a href="https://quicwg.org/base-drafts/draft-ietf-quic-tls.html#rfc.section.5.2" rel="external nofollow noopener noreferrer" target="_blank">Using TLS to Secure QUIC</a></li><li><a href="https://blog.cloudflare.com/the-road-to-quic/" rel="external nofollow noopener noreferrer" target="_blank">The Road to QUIC</a></li></ul>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/10/08/what-is-http3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>블로그 개설을 망설이고 있는 사람들에게</title>
      <link>https://evan-moon.github.io/2019/09/28/how-do-i-write-postings/</link>
      <guid>https://evan-moon.github.io/2019/09/28/how-do-i-write-postings/</guid>
      <pubDate>Fri, 27 Sep 2019 23:43:03 GMT</pubDate>
      <description>
      
        &lt;p&gt;과거에는 블로그를 운영하는 개발자들이 오히려 손에 꼽을 정도였지만, 최근 많은 개발자들이 블로그를 운영하며 다양한 주제에 대한 자신의 생각이나 특정 기술에 대한 분석을 포스팅으로 기재하고 공유하고 있다. 하지만 필자는 개인적으로 블로그를 운영하는 것이 생각보다 진입 장벽이 높다고 생각하는데, 그건 블로그 세팅과 같은 기술적인 이유 때문이 아니다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>과거에는 블로그를 운영하는 개발자들이 오히려 손에 꼽을 정도였지만, 최근 많은 개발자들이 블로그를 운영하며 다양한 주제에 대한 자신의 생각이나 특정 기술에 대한 분석을 포스팅으로 기재하고 공유하고 있다. 하지만 필자는 개인적으로 블로그를 운영하는 것이 생각보다 진입 장벽이 높다고 생각하는데, 그건 블로그 세팅과 같은 기술적인 이유 때문이 아니다.</p><a id="more"></a><p>블로그 세팅은 velog나 티스토리같은 블로그 전문 서비스를 사용할 수도 있고 깃허브 호스팅과 <code>jekyll</code>이나 <code>hexo</code>같은 정적 사이트 생성기를 사용하여 세팅할 수도 있는데, 사실 뭘 사용하든간에 그런 건 개발자들에게 크게 어려운 문제가 아니다. 회사나 학교에서 맨날 복잡한 문제로 삽질하면서 밥 벌어 먹고 사는 사람들한테 정적 사이트 생성기를 세팅할 때 발생하는 문제를 해결하는 것 정도는 꽤 쉬운 편이라고 생각한다.</p><p>진짜 문제는 블로그를 세팅한 다음부터 발생한다. 이런저런 삽질 끝에 블로그 세팅을 끝내고 나면 이제 글만 쓰면 되는데, 음… 막상 하얗게 비어있는 에디터를 보고 있으면 머리 속도 함께 햐얘지는 기분이 들기 시작하기 때문이다.</p><center><br>  <img src="/2019/09/28/how-do-i-write-postings/blank_page.png" width="500"><br>  <small>뭘 어떻게 쓰기 시작해야 하지…?</small><br>  <br><br></center><p>글쓰기도 프로그래밍과 마찬가지로 꾸준한 연습과 연구가 필요한 영역이다. 필자 같은 경우는 평균적으로 <code>8000~10000</code> 단어 정도의 포스팅을 작성하는데, 이렇게 하나의 주제를 가지고 긴 호흡으로 글을 작성하게 되면 조금만 딴 생각을 해도 금새 주제가 흐트러지기 쉽상이기 때문에 꽤 많은 집중을 요한다.</p><p>사실 필자 같은 경우만 해도 평소에 글쓰기를 그렇게 많이 해볼 기회가 많지 않았다. 물론 최근에 <a href="http://www.yes24.com/Product/Goods/76639545" rel="external nofollow noopener noreferrer" target="_blank">커피 한 잔 마시며 끝내는 VueJS</a>라는 책을 집필하면서 글을 토할 정도로 쓰기는 했지만, 이건 조금 특이한 케이스이기 때문에 제외하고 생각해본다면 아마 대학교 때 과제로 레포트를 썼던 것이 자신의 생각을 길게 적어본 마지막 경험인 것 같다.</p><p>필자가 주변 사람들한테 블로그를 써보라고 권했을 때 많은 분들이 <code>뭘 써야할 지 모르겠다</code>라고 이야기하고는 했는데, 사실 일상 속에서 자기 생각을 글로 표현해볼 기회 자체가 많지 않기 때문에 글을 쓴다는 것에 많은 분들이 어려움을 느끼는 부분이 있는 것 같다.</p><p>그래서 이번 포스팅에서는 블로그 개설을 망설이고 있는 분들이 고민하고 있는 몇 가지 주제에 대해서 이야기를 한번 해보려고 한다.</p><h2 id="어떤-주제로-글을-써야할까"><a href="#어떤-주제로-글을-써야할까" class="headerlink" title="어떤 주제로 글을 써야할까?"></a>어떤 주제로 글을 써야할까?</h2><p>일단 첫번째로 이야기하고 싶은 것은 바로 <code>포스팅의 주제</code>이다. 많은 분들이 첫 포스팅을 작성할 때 어떤 주제를 선정해야하는지 고민하시는데, 사실 주제는 뭐가 됐든 크게 의미없다.</p><p>주제에 대해서 이야기한다고 하면서 주제는 큰 의미가 없다고 하니 이게 무슨 소리인가 싶겠지만, 진짜로 별 의미 없다. 그냥 아무거나 써도 된다는 것이다.</p><p>필자 주변에 있는 분들의 이야기를 들어보면 첫 포스팅의 주제를 정할 때 고민하는 것이 대부분 비슷했다. 내가 알고 있는 지식은 남들도 다 알고 있을 것이라고 하시는 분도 있었고, 내가 알고 있는 지식이 너무 쉽고 간단한 것이라서 섣불리 공유하기가 조금 꺼려진다고 하시는 분도 있었다.</p><p>그런데 이유가 뭐가 됐든 사실 별로 상관이 없는 것이, 일단 블로그 포스팅은 책과 같이 출판하고 나면 수정하기 힘든 컨텐츠가 아니다. 마음에 안들면 나중에 지워버릴 수도 있고, 내용을 수정하는 것도 자유롭다. 그렇기 때문에 나중에 다시 포스팅을 읽어 보았을 때 주제가 이상하다고 느껴지거나 문체가 오글거려서 도저히 못 봐주겠으면 그냥 미련없이 <code>rm</code> 명령어를 때려버리면 그만이다.</p><p>그래서 필자는 <code>어떤 주제를 고르는 것이 좋다</code> 같은 이야기는 하지 않을 것이다. 대신 주제 자체가 왜 그리 중요하지 않은지, 그리고 필자가 실수했던 경험을 토대로 어떤 주제를 피해야하는지에 대한 이야기를 조금 해보려고 한다.</p><h3 id="내가-알고-있는-지식은-생각보다-값지다"><a href="#내가-알고-있는-지식은-생각보다-값지다" class="headerlink" title="내가 알고 있는 지식은 생각보다 값지다"></a>내가 알고 있는 지식은 생각보다 값지다</h3><p>일단 필자가 <code>주제는 별로 중요하지 않다</code>라고 하는 이유 중 하나는 여러분이 블로그 포스팅을 통해 무엇을 적든 간에 분명 누군가에게는 도움이 될 것이기 때문이다.</p><p>의외로 많은 분들이 <code>내가 알고 있는 것은 남들도 알고 있을 것이다</code>라는 마음 때문에 자신이 알고 있는 것을 공개적으로 공유하기를 꺼려한다. 물론 이건 겸손한 마음에서 우러나오는 생각이지만 그래도 여러분이 알고 있는 지식을 공유하는 행위 자체가 생각보다 값지다는 사실을 알아야 한다.</p><p>여러분이 선정한 주제가 이미 해당 분야에서 널리 알려진 지식일지라도 그 지식에 대해서 아직 모르는 사람도 분명 존재한다. 필자는 개인적으로 그 사람이 단 1명일지라도 내 포스팅을 읽고 그 사람에게 도움이 되었다면 잘 쓴거라고 생각한다.</p><p>이렇게 자신의 지식이나 생각을 아무 대가 없이 타인과 공유하는 것에 대해 익숙한 문화가 개발자들의 장점이 아닐까?</p><center><br>  <img src="/2019/09/28/how-do-i-write-postings/open_source.jpeg" width="500"><br>  <small>우리가 좋아하는 오픈소스도 결국은 지식과 기술을 공유하는 것이다</small><br>  <br><br></center><p>사실 지금은 필자가 이렇게 말하고는 있지만, 필자도 본격적으로 블로그에 포스팅을 작성하기 시작했을 때 제일 고민했던 게 이런 문제였다.</p><p>예를 들어 필자가 작성했던 <a href="/2019/06/18/javascript-let-const/" title="JavaScript의 let과 const, 그리고 TDZ">JavaScript의 let과 const, 그리고 TDZ</a> 포스팅 같은 경우도 쓰기 전에 고민을 많이 했었다. 필자가 해당 포스팅을 작성할 당시인 2019년 6월은 이미 JavaScript ES6 버전이 배포된지 지나도 한참 지난 후였기 때문에 이제 와서 이 주제에 대해서 작성하기에는 너무 늦은 게 아닌가라는 생각을 했었다.</p><p>그러나 막상 포스팅을 작성하고나니 생각보다 많은 분들에게서 도움이 되었다는 메세지를 받을 수 있었다. 필자는 이 지식이 별로 중요한 지식이 아니라고 생각했지만 누군가에게는 도움이 되었다는 것이다.</p><p>비록 필자가 해당 포스팅을 작성한 시점은 JavaScript ES6가 배포된 지 3년이 지난 후였지만 그때도 JS를 처음 접하는 사람들은 있을 수밖에 없고, 그 분들에게는 필자의 포스팅이 큰 도움이 된 것이다.</p><p>사람마다 알고 있는 지식과 모르고 있는 지식은 전부 다를 수 밖에 없다. 내가 <code>A</code>나 <code>B</code>를 알고 있다고 해서 다른 사람들도 모두 <code>A</code>나 <code>B</code>를 알고 있는 것이 아니라는 소리다. 개발자들은 모두 각자가 걸어온 길에 따라 각기 다른 기술에 대한 전문성을 보유한 사람들이기 때문에 이런 지식의 공유가 더 가치있는 것이다.</p><p>그러니까 이미 내가 알고 있는 지식을 저평가 하지말고 일단 그 지식에 대한 주제로 포스팅을 한번 작성해보자. 포스팅을 작성하기 위해서는 기존에 알고 있는 지식이라고 할 지라도 다시 정리하는 과정이 필요하기 때문에 스스로도 지식의 깊이를 다질 수 있는 좋은 기회가 된다.</p><h3 id="처음부터-너무-어려운-주제는-피하자"><a href="#처음부터-너무-어려운-주제는-피하자" class="headerlink" title="처음부터 너무 어려운 주제는 피하자"></a>처음부터 너무 어려운 주제는 피하자</h3><p>이건 필자가 처음 블로그를 작성할 때 실수했던 것이다. 사실 필자가 본격적으로 블로그에 포스팅을 기재하기 시작한 것은 2019년 6월, 즉 약 3개월 전이지만 처음 포스팅을 작성하기 시작한 것은 2017년 쯤이다. 그 당시에는 포스팅을 상당히 뜸하게 올렸는데, 그 이유는 바로 <code>주제 선정에 대해 눈이 너무 높아서</code> 였다.</p><p>당시 필자가 생각하기에는 이미 많은 개발자들이 블로그를 운영하고 있기 때문에 너무 일반적인 주제로 포스팅을 작성하면 별로 눈에 띄지도 않을 것이고 PR에도 별로 도움이 안될 것이라고 생각했었다.</p><p>그래서 필자는 포스팅 주제를 선택할 때 남들이 많이 선택하지 않은 주제나 최신 기술, 난이도가 어느 정도 있다고 생각하는 것들 위주로 선택했는데, 지금 생각해보면 이거 그냥 <code>허세</code>다. 포스팅만 어려운 주제로 쓴다고 해서 내가 진짜로 가치있는 사람이 되는 것이 아니기 때문이다.</p><center><br>  <img src="/2019/09/28/how-do-i-write-postings/bluffing.jpg" width="500"><br>  <small>뭔가 있어보이는 포스팅을 쓰고 싶었다</small><br>  <br><br></center><p>문제는 남들이 어렵다고 생각할 정도인 주제는 당연히 필자한테도 어렵다는 것이다. 알다시피 기술 포스팅을 작성하기 위해서는 그 주제에 대해서 단순한 이해 정도가 아니라 남들에게 쉽게 설명할 수 있을 정도의 이해도가 필요하기 때문에 일반적으로 투자하는 공부 시간보다 더 많은 시간을 투자해서 공부하게된다.</p><p>어떻게 보면 포스팅을 작성하기 위해 어려운 주제에 대한 공부를 강제로 하게되니 좋다고 생각할 수도 있지만, 이렇게 되면 포스팅을 하나 작성하는데 투자해야하는 시간이 거의 몇 주 단위가 될 수도 있다.</p><p>필자는 스스로도 많은 공부가 필요한 주제들로만 포스팅을 작성하려고 했기 때문에 하나의 포스팅을 작성하기 위해서 많은 연구가 필요했다. 그 결과 포스팅을 하나 작성하는데 걸리는 시간이 점점 늘어나기 시작하면서 포스팅 작성에 대한 의욕 또한 점차 떨어지게 되어, 결국 꾸준한 포스팅 업로드를 하지 못하게 되었다.</p><p>블로그를 운영하면서 중요한 것은 주제의 난이도가 아니라 양질의 포스팅을 꾸준히 생산하는 습관을 들이는 것이다. 물론 컴포트존을 벗어나고자 하는 목적으로 가끔씩 본인의 수준보다 약간 더 어려운 수준의 주제를 선정하고 공부를 하는 것은 좋지만, 필자처럼 모든 포스팅을 그런 식으로 작성하려고 하면 꾸준히 포스팅을 작성하는 것이 점점 힘에 부칠 수 밖에 없다.</p><p>여러분이 이미 알고 있는 분야의 지식은 상대적으로 모르는 분야의 지식에 비해 쉬운 것이라고 느껴질 지 모르지만, 분명 그 지식도 다른 사람들에게는 도움이 될 수 있는 가치있는 지식이다. 그 지식이 비록 단순한 변수 선언에 대한 내용일지라도 그 변수 선언에 대한 지식이 없는 누군가에게는 큰 도움이 될 것이다.</p><p>그러니 필자처럼 <code>이건 너무 단순한 내용인데?</code>라는 생각으로 어려운 주제의 포스팅을 고집하다가 제 풀에 지쳐 나가떨어지는 것보다는, 우선 내가 이미 알고있는 분야에 대해서 정리하는 포스팅을 작성해보는 것이 좋다고 생각한다.</p><h2 id="기술-서적이-아닌-책도-많이-읽어보자"><a href="#기술-서적이-아닌-책도-많이-읽어보자" class="headerlink" title="기술 서적이 아닌 책도 많이 읽어보자"></a>기술 서적이 아닌 책도 많이 읽어보자</h2><p>블로그 포스팅을 작성할 때 물론 주제도 중요하지만 일단 포스팅이라는 행위 자체가 기본적으로 <code>글을 쓰는 것</code>이라는 사실을 잊어서는 안된다. 아무리 주제가 좋더라도 그 주제를 몰입력있게 풀어나갈 수 있는 능력이 없다면 사람들은 읽지 않는다.</p><p><code>TIL(Today I Learned)</code>처럼 본인의 기록용으로 짧은 포스팅을 남기는 경우에는 딱히 글쓰기 스킬의 중요성이 부각되지는 않지만 자신의 생각을 표현하거나 특정 기술에 대해서 깊히 파헤치는 등 어느 정도 컨텐츠성을 가지고 있는 포스팅의 경우는 저자의 글쓰기 스킬이 많이 중요해진다.</p><p>글쓰기 스킬의 향상이라는 주제에서 제일 많이 언급되는 내용 중 하나는 아마 <code>독서의 중요성</code>일 것이다. 사실 개발자들은 평소에 책을 많이 읽는 편이기는 하다. 그러나 대부분 기술과 관련된 서적 위주의 독서를 하기 때문에 문어체 특유의 어휘력을 기르기에는 별로 도움이 안되는 것이 사실이다.</p><p>애초에 이런 책들은 특정 기술의 사용법 같은 명확한 사실 전달에 초점을 맞추기 때문에 문체의 유려함은 중요한 포인트가 아니다. 필자도 VueJS 관련 서적을 집필할 때 딱히 문체는 신경쓰지 않았던 것 같다. 기술 서적을 집필해 보신 분들은 공감하시겠지만, 이런 책을 집필할 때는 문체보다 첨부된 코드의 오류를 검수하거나 확실한 정보를 전달하고 있는지 검증하는데만 해도 정신이 없다.</p><p>반면 에세이나 소설 같은 장르는 자신의 생각이나 상상 속의 이야기를 긴 호흡으로 풀어나가야 하는 장르이다보니 다양한 접속사의 활용이나, 간결하고 논리적인 문장의 구조, 명확한 주제의 제시 등 독자가 이야기의 흐름을 놓치지 않도록 하는 여러가지 방법들이 많이 사용될 수 밖에 없다.</p><p>이러한 방법들을 체득하기위해 따로 공부를 할 수도 있겠지만, 우리는 전공자도 아니고 프로 작가가 될 것도 아니므로 독서를 통해 자연스럽게 체득하는 방법을 추천하는 것이다. 요리도 많이 먹어본 사람이 잘하는 것처럼 글쓰기도 많이 읽어본 사람이 잘하기 마련이다.</p><p>필자가 그런 방법들을 이 포스팅에서 모두 소개하기에는 지식도 짧고, 포스팅 분량도 길어질 것이므로 그 중에서 가장 기초라고 생각하는 <code>문어체</code>에 대한 이야기를 조금 해보려한다.</p><h3 id="문어체에-익숙해져야-한다"><a href="#문어체에-익숙해져야-한다" class="headerlink" title="문어체에 익숙해져야 한다"></a>문어체에 익숙해져야 한다</h3><p>우리가 평소 말할 때 사용하는 <code>구어체</code>와 글을 쓸 때 사용하는 <code>문어체</code>는 각기 다른 특성을 가지고 있다. 구어체의 경우에는 화자의 생각을 실시간으로 표현하는 방식이기 때문에 어순이 변경되거나 필요한 표현이 생략되는 등 문법에 크게 구애 받지 않는다.</p><blockquote><p>야, 저번에 했던 그 게임 또 할까? 그 뭐였더라? 오버워치…가 아니고 배틀그라운드였다!</p></blockquote><p>참고로 구어체의 이런 특성은 한국어에만 국한되는 것은 아니고, 영어 같은 다른 언어들 또한 동일하다.</p><p>구어체는 애초에 완벽한 문장을 만드는 것이 목적이 아니라 <code>커뮤니케이션</code> 자체에 초점을 맞춘 용법이기 때문에 한국어든 영어든 간에 문법은 딱히 중요하지 않다. 우리가 평소에 말할 때 딱히 문장의 구조를 생각하고 말하지 않는 것처럼 말이다.</p><p>또한 위의 예시를 보면 알 수 있듯이 실시간으로 자신의 생각을 표현하는 구어체에서는 앞에서 말한 내용을 수정하는 경우 또한 자주 발생한다. 그렇기 때문에 글을  구어체로 작성하게 되면 문장이 명료하게 완성되지 않고 문체가 산만해질 수 있으며 독자가 글을 읽어나가는 흐름이 끊기게 된다.</p><p>물론 글의 장르에 따라 이런 구어체를 글쓰기에 활용하는 경우도 있지만, 그건 대화를 하는 상황을 묘사하는 등 현실감을 불어넣기 위한 일종의 스킬이라 블로그 포스팅같은 컨텐츠에서는 많이 쓰이지 않는 방법이다.</p><p>이런 이유로 블로그 포스팅과 같이 정보성을 띄고 있는 글은 하나의 문장을 깔끔하게 완성하는 문어체로 글을 작성하는 것이 좋다. 긴 글의 흐름을 끊기지 않게 이어나가기 위해서는 깔끔하고 논리적인 문장의 구사와 다양한 접속사의 활용과 같은 스킬들을 사용해야 하는데, 구어체에는 이런 요소들이 문어체에 비해 상대적으로 약하거나 없기 때문이다.</p><p>하지만 문제는 문어체가 우리가 일상 속에서 잘 사용하지 않는 용법이기 때문에 익숙하지 않다는 것이다. 문어체에 익숙해지는 여러가지 방법이 있겠지만 그 중 필자가 추천했던 것은 기술 서적이 아닌 책, 그 중에서도 저자의 생각을 표현하는 주제를 가진 책을 많이 읽어보는 것이었다. 예를 들면 <code>에세이</code> 같은 것들 말이다.</p><p>단, 필자가 말하는 에세이는 짤막한 감성 글귀들이 송송 박혀있는 그런 책을 말하는 게 아니다. 필자가 말하는 에세이는 서론에서는 주제를 제시하고 본론에서는 그 주제에 대한 실증적인 방법을 제시하며 결론에서는 그에 따른 자신의 의견을 제시하는, 명확하게 구조화 되어있는 에세이를 말하는 것이다.<small>(외국 학교나 기업에 들어갈 때 요구되는 그 에세이다)</small></p><center><br>  <img src="/2019/09/28/how-do-i-write-postings/book.jpeg" width="500"><br>  <small>빌 게이츠나 버락 오바마가 추천하는 책으로도 유명한 팩트풀니스</small><br>  <small>장르 분류는 인문학으로 되어있지만 이런 주제도 크게 보면 에세이라고 할 수 있다</small><br>  <br><br></center><p>개발자들은 주로 튜토리얼, 기술 분석, Dev Log와 같은 주제의 포스팅을 많이 작성한다. 이런 기술적인 포스팅에 왠 저자의 생각이냐고 반문할 수도 있겠지만, 결국은 포스팅의 주제가 <code>남들에게 공유하고 싶은 무언가</code>라면 그 포스팅에는 기본적으로 그 주제에 대한 저자의 의견, 정리 또는 생각이 어느 정도 묻어있을 수 밖에 없다.</p><p>또한 개발자들이 작성하는 포스팅들은 논리적이고 실증적인 방법으로 주제를 풀어나가는 경우가 많기 때문에 저런 에세이를 추천하는 것이다. 이렇게 자신이 작성할 블로그 포스팅과 유사한 스타일의 글을 많이 읽다보면 점점 문어체에서 사용하는 문법과 단어들, 주제를 풀어나가는 구성 등에 대해서 익숙해지기 때문에 자신의 글쓰기에도 많은 도움이 된다.</p><p>정 뭐부터 읽어봐야할지 모르겠다면 필자가 위에 올려놓은 <code>팩트풀니스</code>부터 한번 읽어보자. 사람마다 취향이 다르니 재미있을 것이라고는 할 수 없겠지만, 자신의 생각을 논리로 풀어나간다는 것이 어떤 전개로 이루어지는지는 알 수 있을 것이다.</p><h2 id="피드백을-두려워-하지-말자"><a href="#피드백을-두려워-하지-말자" class="headerlink" title="피드백을 두려워 하지 말자"></a>피드백을 두려워 하지 말자</h2><p>아무래도 블로그라는 것이 불특정 다수에게 노출되는 컨텐츠다 보니 다른 사람들이 주는 피드백에 대한 두려움이 있을 수 있다. 간단하게 말하자면 욕먹는 것에 대한 두려움이랄까. 잘못된 내용을 전파했다가 피드백을 받는 경우도 있고, 자신의 생각을 기재했다가 나와 생각이 다른 사람들이 그 생각에 대한 피드백을 주는 경우도 있다.</p><p>일단 피드백을 받는 것을 두려워 해서는 안된다는 이야기를 먼저 하고 싶다. 피드백은 단순히 내 생각에 반대하는 의견, 나를 까는 의견이 아니라 나를 제 3자의 눈으로 바라본 냉정한 평가이기 때문이다.</p><p>필자도 물론 포스팅을 배포하고 공유하다보면 피드백을 받게 되는데, 뭐 가끔씩 공격적으로 이야기하시는 분들도 있긴 하지만 결국 뭐가 됐든 그 분들은 필자의 포스팅을 읽어보고 거기에 대한 자신의 생각을 표현했을 뿐이니 딱히 기분 나쁘거나 한 것은 없다.</p><p>그리고 그런 피드백은 대부분 필자의 포스팅에 뭔가 오류가 있었다거나, 필자의 생각과 다른 부분을 말씀해주시는 것이니 <code>음, 그렇군</code>하고 그냥 받아들이면 그만이다. 특히 잘못된 정보에 대한 피드백을 주시는 경우는 오히려 가만히 앉아서 오류를 파악하고 고칠 수 있으니 개이득아닌가.</p><center><br>  <img src="/2019/09/28/how-do-i-write-postings/feedback.png" width="500"><br>  <small>최근 동기/비동기 포스팅에 대해 OKKY의 하마님께서 주신 피드백</small><br>  <small>지금까지 필자가 받은 피드백 중 가장 상세한 피드백을 주셔서 굉장히 감사했다<br>  <br><br></small></center><p>하지만 사람 마음이라는 것이 뭔가 지적받는 것에 대해서 한없이 무뎌질 수는 없는 법이다. 당연히 두렵기도 하고 부끄럽기도 하고 때로는 기분 나쁘기도 할 수 있다.</p><p>솔직히 말하자면 필자도 포스팅을 공유할 때마다 마음 한켠으로는 <code>비난 받고 싶지 않다</code>라는 마음이 든다. 개인적으로 정답이 명확한 기술 관련 포스팅을 작성할 때보다 지금 이 주제와 같이 필자의 생각을 표현하는 포스팅을 공유할 때가 더 그렇다.</p><p>기술 포스팅같은 경우는 주로 필자가 잘못된 정보를 기재했을 경우에 피드백이 들어오기 때문에 잘못된 정보를 기재했음을 인정하고 고치면 되지만, 이렇게 자신의 생각을 표현하는 주제처럼 주관성을 가지고 있는 포스팅의 경우에는 필자와 다른 생각을 가지신 분들이 가끔 공격적인 피드백을 주시는 경우도 있기 때문이다.</p><p>하지만 필자가 읽어 보았을 때 <code>좀 심한데...?</code>라는 생각이 들 정도로 거친 피드백을 주신 분은 지금까지 단 한 분밖에 없었고, 이 정도로 공격적인 피드백은 그냥 무시하면 그만이다. 개인적으로 그 피드백에 담긴 생각과는 별개로 타인에게 전달하는 말의 가치를 잘 모르는 사람과는 별로 생각을 나누고 싶지 않다.<small>(비판과 비난은 다르다는 것을 명심하자)</small></p><p>아마도 이렇게 밑도 끝도 없이 비난하는 케이스가 사람들이 두려워 하는 <code>욕먹기 싫다</code>의 원인일 것 같은데, 생각보다 세상에 그렇게 이상한 사람들이 많지는 않다. 대부분은 여러분의 포스팅을 읽고 뭔가 아쉬운 마음에, 더 발전했으면 하는 좋은 마음으로 피드백을 주시는 분들이다.</p><p>오히려 그런 피드백들을 통해 다양한 사람들의 다양한 생각을 들어볼 수도 있을 뿐더러 피드백을 토대로 자신이 성장할 수 있는 좋은 기회이기도 하니까 너무 피드백을 두려워하지 않았으면 한다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>필자가 글쓰기에 대한 포스팅을 작성한 이유는 많은 개발자들이 자신의 생각을 공유하는 생태계가 더욱 활성화되었으면 하는 마음에서 비롯되었다. 자신의 생각이나 지식을 공유하는 것이 얼마나 가치있는 행위인지는 매일 구글이나 스택오버플로우를 사용하면서 느끼고 있을 것이다.</p><p>그리고 이런 공유 행위는 오픈소스 활동이나 블로그 포스팅, 발표 등 다양한 방법으로 이루어지고 있지만, 그 중에서도 글쓰기는 자신의 생각을 남들에게 보여줄 수 있는 가장 기초적인 수단 중 하나이다. 글쓰기를 잘하기 위해서는 기본적으로 올바른 문장 구성을 위한 어휘력과 논리력이 뒷받침되어야 하므로 글쓰기를 통해 커뮤니케이션에 대한 기본적인 소양을 기를 수 있다고 볼 수도 있다.</p><p>이렇게 불특정 다수에게 자신의 생각을 공유하는 행위가 두려울 수도 있지만, 필자가 위에서 이야기했듯이 피드백을 두려워하지 않았으면 한다. 그런 피드백을 통해 나 자신도 조금씩 성장할 수 있는 것이고, 다른 사람의 생각을 다양하게 들어볼 수도 있는 좋은 기회이기 때문에 딱히 두려워할 이유가 없다.</p><p>거듭 이야기하지만 <code>욕 먹는다</code>라고 표현할 수 있을 정도로 모욕적인 맹비난을 쏟아붓는 사람은 생각보다 많지 않고, 만약에라도 그런 비난을 받는다면 그냥 해당 메세지를 삭제하고 없었던 일로 생각하면 된다. 원래 이상한 사람과 술 취한 사람과는 아예 안 엮이는 게 스트레스 덜 받는 방법이다.</p><p>피드백을 주시는 대부분의 사람들은 포스팅을 읽고 뭔가 아쉬운 마음에서, 좋은 마음으로 주시는 것이기 때문에 자신의 생각을 공유하는 것을 주저하지 않았으면 한다.</p><p>그리고 블로그에 당장 뭐부터 써야할 지 모르겠다면, 일단 내가 알고있는 것이 무엇인지부터 한번 차근차근 정리해보자. 장담하건데 본인이 생각하는 것보다 많은 주제들이 나올 것이다. 그리고 위에서는 이야기하지 않았지만 진짜 아무리 생각해도 도저히 쓸 주제가 없다면 재밌게 읽었던 외국 포스팅을 번역해보는 것도 좋은 방법이다.<small>(생각보다 이런 포스팅은 인기도 많다)</small></p><p>이상으로 블로그 개설을 망설이고 있는 사람들에게 포스팅을 마친다.</p>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/09/28/how-do-i-write-postings/#disqus_thread</comments>
    </item>
    
    <item>
      <title>내가 겪었던 번아웃, 그리고 극복했던 경험</title>
      <link>https://evan-moon.github.io/2019/09/23/how-to-overcome-burnout/</link>
      <guid>https://evan-moon.github.io/2019/09/23/how-to-overcome-burnout/</guid>
      <pubDate>Sun, 22 Sep 2019 23:03:54 GMT</pubDate>
      <description>
      
        &lt;p&gt;필자는 작년인 2018년, &lt;code&gt;번아웃(Burn-out)&lt;/code&gt;이라 불리는 탈진 증상을 한 차례 격하게 겪은 적이 있다. 번아웃은 2019년 5월 &lt;code&gt;WHO(세계보건기구)&lt;/code&gt;에서도 ICD-11에 정식으로 등록할 만큼 관심을 가지고 있는 증상 중 하나이다. WHO는 번아웃이 의학적인 질병에는 포함되지 않지만 직업 관련 증상 중 하나라고 이야기하고 있다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>필자는 작년인 2018년, <code>번아웃(Burn-out)</code>이라 불리는 탈진 증상을 한 차례 격하게 겪은 적이 있다. 번아웃은 2019년 5월 <code>WHO(세계보건기구)</code>에서도 ICD-11에 정식으로 등록할 만큼 관심을 가지고 있는 증상 중 하나이다. WHO는 번아웃이 의학적인 질병에는 포함되지 않지만 직업 관련 증상 중 하나라고 이야기하고 있다.</p><a id="more"></a><p>흔히 번아웃은 <code>나 자신이 다 타버리고 더 태울 것이 없어 재만 남은 상태</code>에 비유되고는 한다. 필자 또한 처음 번아웃을 경험했을때 이런 비슷한 느낌을 받았었다. 사실 이런 경험은 필자 뿐만 아니라 많은 사람들이 이미 겪고 있는 경험이라 일상 속에서도 이제 번아웃이라는 단어를 자주 들을 수 있는 시대인 것 같다.</p><p>무엇보다 필자가 번아웃을 경험했을때 힘들었던 것은, 이 증상이 어느 날 갑자기 예고없이 찾아왔기 때문이다. 어제까지만 해도 개발하는 것을 즐기던 내가 하루 아침에 변해버리는 경험은 꽤나 당혹스러웠다.</p><p>물론 진짜로 하루 아침에 번아웃이 생길리는 없으니, 필자도 모르게 조금씩 쌓여왔던 요소들이 어떤 작은 사건 하나로 터져버린 것일테다. 평소에 <code>이 정도는 직장인으로써 당연한거지</code>, <code>회사에 개발 리소스가 부족하니 어쩔 수 없어</code>, <code>주말에라도 공부를 안하면 도태될거야</code> 라고 생각하면서 매일 야근하고 자신을 채찍질했던 것들이 조금씩 쌓여가면서 더 이상 견딜 수 없게 되었을 때 한번에 큰 폭탄이 되어 돌아왔던 것이다.</p><p>그래서 이번 포스팅에서는 필자가 번아웃을 경험하며 느꼈던 점과 어떻게 대처했었는지에 대한 회고를 한번 해보려고 한다.</p><h2 id="갑자기-찾아온-번아웃"><a href="#갑자기-찾아온-번아웃" class="headerlink" title="갑자기 찾아온 번아웃"></a>갑자기 찾아온 번아웃</h2><p>필자는 번아웃이 어느 날 갑자기 찾아왔다고 이야기 했다. 물론 조금씩 쌓여왔던 스트레스와 부담감들이 쌓여온 결과였겠지만, 필자는 그런 스트레스들을 당연한 것으로 생각하고 받아들이고 있었기 때문에 당황스러운 것은 마찬가지였다.</p><p>처음 필자가 처음 개발에 재미를 붙히게 된 이유는, 그냥 뭔가를 만든다는 것이 너무 재미있었고 내 아이디어를 코딩을 통해 실현할 수 있다는 것이 너무 신기했기 때문이었다. 그래서 친구들과 루비콘이라는 팀도 만들어서 이것저것 만들어보고는 했었는데, 이 당시 팀원들과 평일, 주말 가리지 않고 매일 모여서 함께 아이디어를 논의하고 새로운 것을 만들어보는 재미에 흠뻑 빠져있었다.</p><p>그 후 대학을 졸업하고 개발자로 회사에서 일을 할 때도 몇년 정도 이런 생활 패턴을 유지했었는데, 회사 생활을 오래 하면서 조금씩 생활 패턴이 흐트러지기 시작했다.</p><p>밤 11시까지 야근을 하는 경우가 부지기수였지만 그래도 <code>그냥 자기에는 오늘 하루가 아깝다</code>는 생각에 매일 새벽 2~3시까지 코딩을 하고 주말에는 평일에 못한 만큼 더 많이 공부를 해둬야 한다는 생각에 아침부터 저녁까지 코딩만 했다.</p><p>그러던 어느 날, 사무실에서 평소처럼 코딩을 하고 있었는데 갑자기 문득 이런 생각이 들었다.</p><center><br>  <img src="/2019/09/23/how-to-overcome-burnout/no-jam.jpg" width="500"><br>  <small>재미없네…</small><br>  <br><br></center><p>결국 코딩이라는 것에 권태기가 온 셈이다. 처음에는 맨날 <code>Vue</code>만 하니까 권태기가 온 것이라고 생각하고 <code>React Native</code>를 사용하고 있는 모바일 챕터로 넘어가서 일을 하기도 했었지만, 결국 새로운 프레임워크와 개발 환경이 주는 즐거움은 처음 일주일 정도만 지속됐고 그 이후 해당 기술들이 익숙해지면 권태감이 느껴지는 것은 똑같았다.</p><p>분명 내가 좋아서 시작한 일이었는데 갑자기 재미없어지는 경험은 필자도 처음 겪는 일이었기 때문에, 처음에는 어떻게 대처해야할 지 감도 못 잡았었다. 분명 필자는 내일도 일을 똑같이 해야하고, 필자의 생산성이 떨어지면 다른 팀원들에게 피해가 갈 수도 있는 상황이기에 난감하기도 했다.</p><p>게다가 필자가 이런 생각을 하고 있다는 것을 다른 팀원들이 알게 되면 괜히 팀원들도 분위기에 흔들릴까봐 팀에는 말도 하지 못하고 혼자만 꽁꽁 싸매고 있었다. 가끔 주변 지인들에게 이런 상황에 대해서 이야기하기도 했었는데, 대부분 돌아오는 대답은 <code>직장인이 다 그런거지 뭐</code> 또는 <code>좀 쉬어라</code> 였던 걸로 기억한다.</p><p>필자는 회사에 다니고 있었기 때문에 마냥 쉴 수는 없었다. 그리고 주말에 아무리 푹 쉰다고 해도 평일이 되면 다시 권태감이 찾아왔다. 그래서 필자는 그냥 직장인이 다 그런거라고 생각하면서 어느 정도 포기하고 지내고 있었다.</p><p>그러나 필자가 잘못 생각했던 것은 여기서 번아웃 증상이 더 심화될 것이라고 생각하지 못한 것이었다. 제대로 대처를 하지 않으니 권태감은 점점 심해졌고, 결국 필자는 개발팀 리더에게 <code>회사를 그만두고 싶다</code>라고 말하기에 이르렀다.</p><p>이때 필자의 감정은 매일 같은 업무에 지친 권태감과 이런 감정 상태로 일을 하면서 팀원들에게 피해를 주고 있다는 죄책감, 코딩이 싫어진 나 자신에 대한 실망감 등 꽤나 복합적인 감정이었다.</p><p>필자는 원래 성격도 급한 편인데다가 늘 자기 자신을 채찍질하며 쫒기듯이 살아왔던 사람이었기 때문에 이 번아웃에 대한 결론도 <code>생각보다 빨리 안 낫네? 그럼 팀원들한테 더 피해주느니 그냥 퇴사하는게 좋겠다</code>라고 성급한 결론을 내려버린 것이다.</p><p>하지만 당시 팀 리더는 필자에게 번아웃은 개인의 문제가 아니라 팀의 문제라고 말해주었고, 힘든 게 있으면 팀원들한테 언제든지 말하라는 말도 해주며 필자에게 용기를 북돋아 주었다. 사실 이 한마디가 필자에게는 굉장히 컸던 것 같다. 당시 팀 리더가 필자에게 해줬던 이 한마디가 필자에게 약간이지만 여유를 가져다 줬었다.</p><p>이때부터 개발보다는 나 자신에 대한 생각을 하게 되면서 지금까지 잊고 지냈던 것들에 대해 다시 깨닿게 되는 계기가 되었다.</p><h2 id="개발자가-되기-전에는-없었던-경험"><a href="#개발자가-되기-전에는-없었던-경험" class="headerlink" title="개발자가 되기 전에는 없었던 경험"></a>개발자가 되기 전에는 없었던 경험</h2><p>번아웃을 극복하고자 본격적으로 나 자신에 대한 생각을 하게된 다음 가장 의아했던 것은 개발자가 되기 전에는 이런 경험을 해본 적이 한번도 없다는 것이다.</p><p>개발자가 되기 전에는 학생이었으니까 당연하다고 생각할 수도 있겠지만, 필자는 <code>2004</code>년부터 <code>2011</code>년까지 프로팀에서 활동하는 비보이였기 때문에 어떻게 보면 학생임과 동시에 직업도 가지고 있었다고 할 수 있다.</p><center><br>  <img src="/2019/09/23/how-to-overcome-burnout/dart.jpg" width="500"><br>  <small>거의 10년 전 추억이 되버린 배틀</small><br>  <br><br></center><p>그리고 알고 있을지는 모르겠지만 대한민국 비보이들의 하루 연습량은 직장인들이 사무실에서 근무하는 시간과는 비교할 데가 못된다.</p><p>필자의 경우 기본적으로 평일에는 학교를 마치면 바로 연습실로 가서 밤 10시까지 매일 6시간 정도 연습을 했고, 주말이나 방학에는 오전 9시부터 밤 10시까지 매일 13시간 정도 연습을 했었다. 물론 공연이나 배틀이 잡히면 연습량을 늘려야 하기 때문에 밤새 새벽 연습을 하고 학교를 가는 경우도 있었다.</p><p>솔직히 육체적으로나 정신적으로나 힘든 건 그때가 더 힘들었는데도 불구하고 이상하게도 필자는 비보잉을 할 때 번아웃을 겪어본 경험이 없었지만 개발을 할 때는 번아웃을 겪고 있는 것이다.</p><p>직장 상사보다 더 직설적인 말로 갈구는 형들도 있었고, 심지어 연습을 제대로 안한다고 맞기도 했으며, 에어트랙이라는 기술을 연습할 때는 두 바퀴를 못해서 1년 동안 매일 5시간 넘게 이 기술만 연습했던 적도 있었다.</p><center><br>  <img src="/2019/09/23/how-to-overcome-burnout/airtrack.gif" width="500"><br>  <small>애증의 에어트랙, 결국 두 바퀴를 못 만들고 군대를 갔다</small><br>  <br><br></center><p>그래서 필자가 번아웃을 경험하면서 고민했던 것은 <code>왜 그때는 안그랬고, 지금은 번아웃이 온 것인가?</code>였다. 필자는 비보이로 활동할 당시에 매일 강도 높은 연습을 했고, 돈도 많이 못 벌었기 때문에 육체적으로나 정신적으로나 더 힘든 시기라고 생각했는데 그럼에도 불구하고 번아웃을 경험하지 않았다면 분명히 뭔가 이유가 있어서라고 생각했기 때문이다.</p><h2 id="내가-스스로-만들어낸-채찍"><a href="#내가-스스로-만들어낸-채찍" class="headerlink" title="내가 스스로 만들어낸 채찍"></a>내가 스스로 만들어낸 채찍</h2><p>필자가 생각했을 때, 비보이였던 당시와 개발자인 현재 필자의 마음에 차이가 있다면 <code>내가 좋아서 하는 것 자체로 만족하지 못하고 있다</code>는 것이였다.</p><p>분명 비보잉을 할 때는 춤 자체를 즐기고 있었다. 배틀에서 우승하지 못해도 상관없었으며, 누군가에게 인정받지 않아도 상관없었다. 이 마인드는 처음 춤을 시작했을 때도, 7년 동안 춤을 추고 난 다음에도 바뀌지 않았었다. 그리고 비록 군대갔다와서 생각이 바뀌긴 했지만 한창 프로 팀으로 활동할 당시에는 돈도 딱히 중요하지 않았던 것 같다.</p><p>하지만 개발자인 필자는 처음 개발을 시작할 때와는 다르게 여러가지를 신경쓰고 있었다. 남들에게 인정받는 실력을 가지고 싶다던가, 연봉이라던가, 좋은 회사에 들어가고 싶다던가 하는 것들 말이다. 이런 욕구들이 건강하게 작용하면 발전의 원동력이 되겠지만 필자는 조금 과했던 것 같다.</p><p>오랜 기간 생각 끝에 필자가 내린 결론은 <code>내가 나를 너무 채찍질하고 있구나</code>였다. 외부에서는 필자에게 어떤 압력도 주지 않았다. 남들에게 인정받고 싶다는 것, 돈을 많이 버는 것, 좋은 회사에 들어가고 싶다는 것들은 모두 필자가 만들어낸 채찍이었던 것이다.</p><h3 id="회사-업무는-회사-업무일-뿐"><a href="#회사-업무는-회사-업무일-뿐" class="headerlink" title="회사 업무는 회사 업무일 뿐"></a>회사 업무는 회사 업무일 뿐</h3><p>필자가 개발 뿐만 아니라 다른 것을 공부할 때도 가장 좋아했던 것은 바로 모르는 것을 이해하게 되었을 때 느끼는 카타르시스였다. 이런 카타르시스를 느끼면서 뭔가 내가 더 나은 사람이 되어가고 있다는 성취감이랄까, 내가 더 쓸만한 사람이 되었다는 안도감이랄까, 그런 것들을 느끼기 위해 계속 새로운 지식을 찾아서 헤매였던 것 같다.</p><p>물론 신입 때는 회사에서 하는 모든 것들이 새로웠기 때문에 일만 해도 이런 카타르시스를 느낄 수 있었지만 점점 연차가 쌓일 수록 이런 느낌은 점점 무뎌졌고, 결국은 퇴근 후 따로 공부를 하면서 이 욕구를 충족시켜 나갔다. 그러나 퇴근 후에 매일 새벽 2~3시까지 공부를 하는 것이 점점 힘에 부치기 시작했다.</p><center><br>  <img src="/2019/09/23/how-to-overcome-burnout/workout.jpg" width="400"><br>  <small>29살인 지금, 슬슬 이 짤이 공감되기 시작했다</small><br>  <br><br></center><p>오랜 기간 쌓여온 피로 누적인지, 운동 부족인지, 아니면 그냥 나이를 먹어서인지는 모르겠지만 어쨌든 언제부턴가 집에 가면 그냥 기절하는 생활이 반복되었다. 그래서 필자는 회사 외적인 시간을 내는 것이 힘드니 최대한 회사에서 일을 하면서 새로운 것들을 배워나가야한다는 일종의 강박 관념을 가지게 되었다.</p><p>그래서 회사에서 일을 하는 것과 내 실력이 느는 것을 같은 선상에 놓고 생각했던 것이다. 회사에서 일을 하면 무조건 내 실력도 함께 늘어야 한다는 그 생각 때문에, 연차가 쌓여가며 더 이상 회사에서 하는 일상적인 코딩으로는 실력이 늘지 않는다는 사실을 느끼게 되자 권태감이 찾아왔다고 생각한다.</p><p>하지만 이 생각이 잘못 되었다는 것을 깨닿는 데는 그리 오랜 시간이 걸리지 않았다. 애초에 회사는 내 전문 지식을 사용하기위해 나와 계약한 클라이언트 아닌가? 회사에서 뭔가 하나를 하더라도 반드시 배워가야할 이유는 없는 것이다. 그래서 필자는 이때부터 마음 속으로 한가지 기준을 세웠다.</p><blockquote><p>회사는 내가 갈고 닦은 지식을 써먹는 곳이지 새로운 지식을 탐구하는 학교가 아니다. 돈 받는 만큼 제대로 하자.</p></blockquote><p>이 변화로 인해 필자는 <code>돈 받는 만큼만 하자</code>라는 마인드를 가지게 되었는데, 어찌 보면 계산적이고 차가운 마인드일수도 있지만 어찌 보면 자신이 받는 연봉에 대한 책임감을 가지게 되는 마인드이기도 하다.</p><p>당연히 야근도 할 수 있고 능동적으로 새로운 아이디어를 제시하기도 하지만 그건 어디까지나 필자가 돈을 받음으로써 회사에 제공해야 하는 전문성의 일종이고, 자발적인 의사인 것이다. <code>난 직장인이니까</code>라는 마인드때문에 하기 싫은데 하는 것이 아니란 얘기다.</p><p>이렇게 생각을 바꾸고 나니 회사 업무를 할 때 <code>이 업무는 나한테 별 도움이 안되는데</code>라는 마음이 <code>내가 가진 기술로 최선의 결과를 만들어내보자</code>는 마음으로 바뀌게 되었다. 이러한 생각의 변화가 필자의 부담도 덜어냄과 동시에 한층 더 개발자로써 프로페셔널한 마인드를 가지게 되었다고 생각한다.</p><h3 id="실력에-대한-강박관념을-버리다"><a href="#실력에-대한-강박관념을-버리다" class="headerlink" title="실력에 대한 강박관념을 버리다"></a>실력에 대한 강박관념을 버리다</h3><p>그리고 필자가 또 한가지 다짐했던 것은, 매일 <code>코딩하지 않기</code> 였다. 남들은 1일 1커밋하자고 하는 이 판국에 무슨 소리인가 싶겠지만, 필자는 1일 1커밋이 아니라 1일 10커밋을 4년 넘게 해오다가 이 사단이 난 것이므로 어느 정도 코딩과 거리를 두는 것이 더 좋다고 생각했다.</p><p>이렇게 매일 코딩을 하는 습관은 대학생때부터 시작된 것인데, 처음에는 코딩이 너무 재밌고 좋아서 자연스럽게 매일 한 것이지만 어느 순간부터 반 정도는 습관처럼, 반 정도는 공부에 대한 강박관념으로 이어왔던 것 같다.</p><p>주변의 개발자들을 보면 워낙 뛰어나신 분들이 많기에, 그 모습에 더 압박을 느꼈던 것 같기도 하다. 그래서 새로운 기술이나 패러다임에 대한 공부를 게을리 하게되면 결국 이 시장에서 도태되고 말 것이라고 생각했기 때문에 계속 기술 포스팅도 읽어보고 새로운 기술로 프로젝트를 만들고 했었다.</p><p>사실 아무리 필자가 매일 공부를 하더라도 기술마다 러닝커브가 존재하기 때문에 모든 기술을 따라가는 것은 당연히 불가능하다. A라는 기술이 새로 나와서 그 기술을 공부하다가 어느 정도 이해가 될 때 쯤에는 새로운 패러다임을 가진 B라는 기술이 나오는 것이 IT업계의 현실이니 말이다. 결국 필자는 불가능한 목표에 압박을 느끼고 목을 메고 있던 것이다.</p><p>그러나 곰곰히 생각해보니 필자는 다른 장점이 많은 사람이었다. 예전부터 워낙 이것저것 해왔다 보니까 <code>WebGL</code>이나 <code>천체물리학</code>, <code>사운드 엔지니어링</code> 등 일반적인 웹 개발자들은 잘 모르고 관심도 없는 분야에 대한 어느 정도 지식이 있었기 때문이다.<small>(일종의 잡캐라고 할 수 있다)</small></p><center><br>  <img src="/2019/09/23/how-to-overcome-burnout/my-projects.png"><br>  <small>열심히 홍보한 결과, 간혹 스타를 찍어주시는 고마운 분들도 있다</small><br>  <br><br></center><p>물론 일반적인 어플리케이션을 개발할 때는 딱히 쓸모없는 지식들이기는 하지만 간혹 이런 기술이 필요한 분야에서 사람을 구할 때 한번씩 기웃거려 볼 수라도 있기는 하다.<small>(그리고 워낙 비주류 전문 지식이라 돈도 많이 준다)</small></p><p>필자는 이런 부분들이 다른 개발자들과 차별화되는 필자만의 무기가 아닐까라는 생각을 했었다. 결국은 처음 개발을 시작할 때 가졌던 마음이 정답이었던 것이다. 실력 향상 같은 것은 신경쓰지말고 그냥 내가 공부하고 싶은 것을 공부하고 만들고 싶은 것을 만들자는 마음 말이다.</p><p>지금도 실력이라는 것은 그냥 내가 만들고 싶은 것을 만들다보면 자연스럽게 따라오는 것이라고 생각한다. 애초에 누가 실력이 좋고 나쁘고를 따지는 기준 자체도 굉장히 주관적이고 애매하기 때문에 그냥 그런 거 신경쓰지 않고 하고 싶은대로 하면서 살기로 했다.</p><h3 id="연봉-그렇게-중요하지-않다"><a href="#연봉-그렇게-중요하지-않다" class="headerlink" title="연봉? 그렇게 중요하지 않다"></a>연봉? 그렇게 중요하지 않다</h3><p>필자는 처음 개발자로 취업을 할 때 <code>30살이 되면 연봉을 n원 정도는 받아야지</code>하는 식의 일종의 기준이 있었다. 사실 30살이라는 나이는 그렇게 많은 나이는 아니지만 10대 이후 처음으로 나이의 앞 자리가 바뀌는 만큼 뭔가 이루고 싶었던 것 같다.<small>(지금 생각해보면 그게 뭔 의미가 있나 싶긴하다)</small></p><p>그리고 필자는 내가 사회로부터 인정받은 결과가 숫자로 나타나는 것이 연봉이라고 생각했기 때문에 더 연봉에 집착했던 것도 있다.</p><p>하지만 문제는 필자가 노련한 협상가가 아니라는 것이다. 연봉이라는 것은 기본적으로 협상을 통해 이루어지는 경우가 많은데, 이 협상이라는 것이 단순히 말을 잘해서 되는 것이 아니라 조직 내에서 지속적인 자기 어필과 홍보, 팀원들의 평가, 개발 실력 등 많은 요소들이 맞물렸을 때 비로소 연봉 협상 테이블에서 유리한 위치를 점할 수 있게 된다.</p><p>게다가 연봉이라는 숫자가 완성되기까지는 변수가 너무 많다. 첫 직장이 어떤 곳이였는지, 그 곳에서 나의 실력을 어느 정도로 평가해주었는지, 게다가 어느 정도는 운빨도 따라줘야한다.</p><p>나를 제외한 회사 내의 모든 프론트엔드 개발자가 그만 둬서 내가 이 회사의 유일한 프론트엔드 개발자가 되는 상황처럼 연봉 협상에 유리한 상황 같은 것 말이다.</p><p>하지만 사회 생활 경험이 많지도 않은 필자가 이런 것들을 알 리가 없었고, 당연히 필자가 세운 무리한 목표와는 점점 멀어질 수 밖에 없었다. 지금 생각해보면 당연한 것인데 당시에는 목표에서 멀어진다는 불안감에 조바심을 냈었다.</p><p>사실 필자의 연봉은 그런 조바심을 가질 만큼 적지도 않고, 많지도 않다. 뭐 돈에 대한 기준은 사람마다 다르겠지만 그냥 29살 청년이 혼자 먹고 살 수 있을 만큼의 돈을 벌고 있다고 생각한다.</p><p>하지만 사람 마음이라는 것이 참 간사한 것이, 내가 먹고 살기에는 충분한 연봉을 받고 있다는 사실을 알고 있더라도 나보다 더 많은 연봉을 받는 사람을 보면 부러움이 샘솟기 마련이다. 돈이 가진 마력이란 참 무섭다.</p><p>그런 이유로 필자는 연봉이 진짜 그렇게 중요한 것인가에 대해서도 다시 생각해보게 되었는데, 필자가 이때 내린 결론은 얼마를 받든 <code>어차피 부질없다</code>는 것이었다. 필자가 친구들에게 이런 얘기를 하면 무슨 스님이냐고 하는 친구들도 간혹 있는데, 이건 필자가 무슨 깨달음을 얻어서 내린 결론이 아니고 단지 계산기를 조금 두드려 보았을 뿐이다.</p><p>필자의 첫 취업 이후 수입과 매달 지출, 그리고 지금까지 필자의 평균 연봉 인상률까지 적용해서 10년 뒤를 생각해보면 음, 딱히 답이 없다. 40대 쯤 되었을 때 3억 모으면 잘 모은 느낌이랄까. 어떤 분은 3억이 어디냐고 하시겠지만 필자는 2억 모으나 3억 모으나 어차피 인생의 큰 틀은 바뀌지 않는다고 생각했다.</p><p>솔직히 필자 같은 일반인은 로또라도 당첨되거나 주식이나 코인이 대박나지 않는 이상, 그냥 능력 껏 먹고살 만큼만 벌고 나머지는 결국 대출로 영혼까지 끌어모아서 집 사고 차 사고 하면서 남들처럼 그렇게 살 수 밖에 없다는 것이다. 조금은 냉정한 생각일 수도 있지만 그냥 필자가 계산기 두들겨 봤을 때 나오는 월급쟁이의 현실은 이 정도인 것 같다.</p><center><br>  <img src="/2019/09/23/how-to-overcome-burnout/bitcoin.jpg" width="500"><br>  <small>필자 같은 일반인은 어차피 저걸 잡아탈 용기도 운도 없다</small><br>  <br><br></center><p>여기까지 생각이 닿고 다니까 고작 연봉 몇 백만원 인상에 일희일비 하는 것이 부질없다고 생각이 들게 되었다. 그래서 지금 필자는 연봉이 오르던 말던 딱히 신경쓰지 않는 편이다. 물론 당연히 돈은 많을 수록 좋으니까 오르면 좋기는 하지만 딱히 안 올라도 조바심 내지 않고 <code>언젠가 오르겠지 뭐</code> 하는 느낌이다. </p><p>게다가 연봉 올라서 기쁜 기분이래봤자 어차피 몇 달 지나면 금방 또 그 액수에 익숙해져서 무뎌지기 마련이다.</p><p>근데 참 웃긴 것이 이렇게 마음 먹는다고 돈이 안 벌리는 것도 아니더라. 연차가 쌓이며 연봉도 오르기는 올랐고, 책도 하나 출판했고, 블로그에서도 수익이 조금씩 나고 있으니 오히려 예전보다 점점 더 잘 벌고 있다고 할 수 있다. 그래서 딱히 돈에 집착하든 하지않든 그냥 자기 할 일만 잘하고 있으면 돈은 자연스럽게 따라오는 것이 아닌가하는 생각이 든다.</p><p>이처럼 기존에 필자 스스로 채찍질하고 있던 것들에 대해 다시 한번 생각해보게 되면서 개발에 대한 중압감을 많이 덜게 되었던 것 같다.</p><h3 id="코딩-외에-다른-취미를-가져보자"><a href="#코딩-외에-다른-취미를-가져보자" class="headerlink" title="코딩 외에 다른 취미를 가져보자"></a>코딩 외에 다른 취미를 가져보자</h3><p>그리고 필자가 또 한가지 중요하게 생각한 것은 <code>내가 어떤 사람인지</code>를 다시 한번 생각해보는 것이였다. 개발자로 열심히 달려온 지난 4년 동안 필자는 취미나 문화 생활 같은 것은 거의 하지 않을 정도로 코딩에 빠져있었다. 즉, 일상이나 취미 등 모든 것이 코딩과 귀결되는 생활을 하고 있었다는 것이다.</p><p>필자가 번아웃이 온 이유에는 물론 중압감과 스트레스도 한 몫 단단히 했겠지만, 내가 원래 어떤 사람인지를 놓쳐서라고도 생각했다. 이건 사실 필자가 딱히 개발자라서가 아니라 그냥 하루하루 업무에 치여사는 직장인이라 그런 것 같기도 하다.</p><p>어쨌든 번아웃을 경험하면서 필자는 위에서 언급한 <code>매일 코딩하지 않기</code>를 실천하면서 남는 시간에 <code>코딩 말고 내가 좋아하는 것을 해보자</code>라는 생각을 가지게 되었다. 사실 이렇게 블로그에 글을 쓰는 것도 어떻게 보면 취미의 일환이라고 볼 수 있겠지만 대표적인 건 아무래도 음악 정도인 것 같다.</p><p>사실 필자는 비보잉 외에도 어릴 때부터 꾸준히 음악을 공부했었다. 슬프게도 천재들의 재능을 보고 쫄아서 포기하긴 했지만 나름 작곡 입시도 준비했었고, 연예 기획사에서 사운드 엔지니어로 일하기도 했을 정도로 음악을 좋아하는 편이다.</p><center><br>  <img src="/2019/09/23/how-to-overcome-burnout/sound-engineer.jpg" width="450"><br>  <small>나름 행복했던 프로페셔널 베짱이 시절</small><br>  <br><br></center><p>그러나 개발자로 일을 하기 시작하면서 평일이고 주말이고 밤낮없이 매일 코딩만 하다보니, 자연스럽게 음악과도 멀어지게 되었다. 음악을 듣는 것은 매일 일상 속에서 하고 있었지만, 예전처럼 곡을 분석하거나, 악기를 연습하거나, 화성학을 공부하거나 하는 일은 우선 순위에서 밀려서 점점 하지 않게 되었다.</p><p>그래서 필자가 번아웃을 극복하고자 마음먹고 집에 와서 가장 먼저 한 것이 바로 집에 있는 피아노를 청소하는 것이였다. 그 이후로도 필자는 꾸준히 피아노나 기타도 치고 보컬 레슨도 받고 화성학도 공부하면서 취미로 음악을 하고 있다.<small>(그 결과 회사에서 별명이 베짱이가 되었다)</small></p><p>음악은 나이 먹어도 즐길 수 있는 평생 취미이기 때문에 여러분도 살면서 악기 하나 정도는 배워보는 것을 추천한다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>필자가 번아웃을 경험하기 전에 위에서 언급했던 것들을 실천하지 못했던 이유는 도태되고 싶지 않다는 <code>불안감</code>, 그리고 실력으로 인정받는 개발자가 되고 싶다는 <code>압박감</code> 때문이었다. 매일 코딩하고 공부하기도 하루는 짧으니까 취미 생활이나 여유는 사치라고 생각했었다.</p><p>하지만 결국 이런 채찍들은 결국 필자에게로 다시 돌아와 번아웃이라는 결과를 안겨주었다. 필자는 스스로를 채찍질함으로써 짧은 시간안에 빠른 성장을 이룰 수 있었지만 지금 생각해보면 그게 결국 무슨 의미가 있었나 싶다.</p><p>지금의 필자는 트렌드에 별로 관심도 없고 그냥 필요하거나 궁금하면 그때 공부하자는 마인드이기 때문에 새로운 기술을 습득하는 속도가 남들보다 확실히 느려졌기 때문이다. 요즘 겁나 핫한 <code>쿠버네티스(Kubernetes)</code>도 사람들 쓰기 시작한 지 한참 뒤에 친구가 말해줘서 알았다.</p><p>하지만 적어도 예전보다는 나름 행복하게 개발을 하고 있다고 말할 수는 있을 것 같다.</p><p>애초에 필자가 개발을 시작한 이유는 단지 재미있어서였기 때문에, 지금의 필자가 개발자로 살아가면서 가장 중요하게 여기는 가치도 <code>재미</code>이기 때문이다. 필자가 중요하게 생각하는 개발의 가치는 뛰어난 멘토가 만들어주는 것도 아니고 좋은 회사가 만들어주는 것도 아니기 때문에 더 이상 주위 환경에 신경쓰지 않는다.</p><p>그리고 사실 지금 필자는 한국과 외주 계약을 체결하고 체코 프라하에서 지내면서 나름 디지털 노마드 체험을 하고 있는 중인데, 한 달이라는 공백기와 백수에게는 꽤 부담되는 금전적 비용을 감수하고 이런 큰 결심을 내리게 된 것도 이때의 경험이 도움이 되었던 것 같다.</p><center><br>  <img src="/2019/09/23/how-to-overcome-burnout/locco.jpg" width="500"><br>  <small>카페랑 코워킹 스페이스가 함께 운영되는 꿀 카페</small><br>  <small>프라하에서 디지털 노마딩 하실 분들께 추천한다.</small><br>  <br><br></center><p>솔직히 프라하로 오기 전에 이런 것들에 대한 걱정을 안했다면 거짓말이겠지만, 어차피 백수된 마당에 눈치볼 것도 없으니 그냥 질러버렸다. 그리고 3주 정도 여기서 살아보니 음, 걱정했던 것과 다르게 딱히 문제는 없는 것 같다.</p><p>사실 필자가 회사를 그만 두고 나서 몇몇 분들이 면접 제의를 해주셨는데, 퇴사하고 2주 뒤에 바로 프라하로 출발해야해서 아쉽게 다음을 기약했었다. 그래서 필자는 솔직히 한달 동안 유럽에 있는 동안 이런 제안들이 흐지부지 해질 것이라고 생각하고 별로 기대를 안하고 있었다.</p><p>하지만 감사하게도 그 중 몇몇 분들과 꾸준히 연락을 주고 받고 있고, 한국에서 외주를 받아왔기 때문에 적당히 수입도 유지되고 있다. 그리고 결정적으로 생각보다 체코에서 체감하는 물가가 그리 비싸지도 않아서 지출이 별로 없다. 뭐 여행다니는 것도 아니고 기껏 해야 동네 산책이나 하는 정도라서 그런 걸 수도.</p><p>과거의 필자였다면 한달 동안 유럽행이라는 결정을 내릴 수 있었을까? 아마 그렇게 하지 못했을 것 같다. 한 달이라는 공백기동안 뒤쳐진다고 생각했을테니까.</p><p>번아웃을 겪으며 힘들기도 했지만 그 과정 속에서 불필요한 것들을 내려놓으면서 오히려 예전보다 더 건강하게 개발자로써의 삶을 살고 있는 것 같다. 코딩은 예전처럼 다시 즐거운 일이 되었으며, 나의 장점을 다시 생각해보면서 예전보다 자신감도 생겼고, 지금처럼 외국에서 한달 동안 살아보는 재미난 경험도 할 수 있으니 말이다.</p><p>이상으로 내가 겪었던 번아웃, 그리고 극복했던 경험 포스팅을 마친다.</p>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/09/23/how-to-overcome-burnout/#disqus_thread</comments>
    </item>
    
    <item>
      <title>동기(Synchronous)는 정확히 무엇을 의미하는걸까?</title>
      <link>https://evan-moon.github.io/2019/09/19/sync-async-blocking-non-blocking/</link>
      <guid>https://evan-moon.github.io/2019/09/19/sync-async-blocking-non-blocking/</guid>
      <pubDate>Wed, 18 Sep 2019 23:54:09 GMT</pubDate>
      <description>
      
        &lt;p&gt;이번 포스팅에서는 I/O와 네트워크 등 전반적으로 다양한 모델에서 사용하는 개념인 &lt;code&gt;동기(Synchronous)&lt;/code&gt;가 정확히 무엇을 의미하는 것인지, 그리고 동기 방식과 비동기 방식의 차이에 대해서 한번 이야기 해보려고 한다. 그리고 이 두 가지 개념과 많이 혼동되는 개념인 &lt;code&gt;블록킹(Blocking)&lt;/code&gt;과 &lt;code&gt;논블록킹(Non-Blocking)&lt;/code&gt;에 대해서도 간단하게 짚고 넘어갈 예정이다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>이번 포스팅에서는 I/O와 네트워크 등 전반적으로 다양한 모델에서 사용하는 개념인 <code>동기(Synchronous)</code>가 정확히 무엇을 의미하는 것인지, 그리고 동기 방식과 비동기 방식의 차이에 대해서 한번 이야기 해보려고 한다. 그리고 이 두 가지 개념과 많이 혼동되는 개념인 <code>블록킹(Blocking)</code>과 <code>논블록킹(Non-Blocking)</code>에 대해서도 간단하게 짚고 넘어갈 예정이다.</p><a id="more"></a><p>본격적인 포스팅에 들어가기에 앞서 한가지 확실하게 이야기하고 싶은 것은 동기와 비동기는 <code>프로세스의 수행 순서 보장에 대한 매커니즘</code>이고 블록킹과 논블록킹은 <code>프로세스의 유휴 상태에 대한 개념</code>으로 완전한 별개의 개념이라는 것이다.</p><p>아무래도 <code>동기와 블록킹</code>, <code>비동기와 논블록킹</code>의 작동 매커니즘이 더 직관적이기 때문에 많은 사람들이 이 개념들을 같은 것 혹은 비슷한 것으로 오해하고 있는데, 방금 이야기 했듯이 이 두가지 개념은 서로 전혀 다른 곳에 초점을 맞춘 개념들이므로 서로 직접적인 관련은 거의 없다고 봐도 된다. 단지 조합하여 사용되는 것 뿐이다.</p><center><br>  <img src="/2019/09/19/sync-async-blocking-non-blocking/4elements.gif" width="500"><br>  <small>출처 - Boost application performance using asynchronous I/O, IBM</small><br>  <br><br></center><p>이미 많은 능력자 분들이 이 주제에 대해서 잘 정리해놓은 포스팅들이 있지만, 대부분 이 개념들을 묶어서 함께 다루고 있기 때문에 이 개념들을 처음 접하거나 컴퓨터 공학에 대해 잘 모르는 사람은 이 개념들이 서로 뭔가 연관이 있는 것으로 오해하기 쉽다. 하지만 많은 포스팅에서 이 주제들을 묶어서 다루는 이유는 단지 이 개념들을 구현한 구현체에서 이 두 가지 개념이 함께 사용되고 있기 때문에 이 개념을 분리해서 따로 설명하는 것이 더 어렵기 때문이다.</p><p>그래서 필자도 어쩔 수 없이 이 개념들을 함께 설명하기는 하지만, 직관적인 개념인 <code>블록킹 &amp; 논블록킹</code>보다는 좀 더 추상적인 개념인 <code>동기 &amp; 비동기</code>에 초점을 맞춰서 진행할 것이다.</p><h2 id="동기는-정확히-뭘-뜻하는-걸까"><a href="#동기는-정확히-뭘-뜻하는-걸까" class="headerlink" title="동기는 정확히 뭘 뜻하는 걸까?"></a>동기는 정확히 뭘 뜻하는 걸까?</h2><p>동기에 관련된 포스팅들을 읽어보면 사람마다 동기라는 단어를 해석한 결과가 가지각색이다. 어떤 사람은 <code>동시에 발생하는 것</code>, 어떤 사람은 <code>특정한 클럭을 정해 통신하는 것</code>, 어떤 사람은 <code>상태를 동일하게 만드는 것</code> 등 동기라는 단어의 쓰임새가 다양한 만큼 다양한 해석들이 존재한다. 도대체 뭐가 맞는 건지 알기가 힘들다.</p><p>필자 또한 처음 동기라는 개념을 배울 때 동기라는 단어와 매커니즘이 잘 와닿지 않아서 혼란스러웠었다. 뭐 <code>블록킹</code> 같은 단어는 농구같이 일상에서 접할 수 있는 스포츠에서도 사용하고 있는데다가 <code>뭔가를 막는다</code>라는 뜻이 바로 와닿기 때문에 조금 이해하기 쉬운 편이지만 동기는 아니다.</p><p>일상에서 주로 접하는 동기의 쓰임새 중 대표적인 예는 <code>동기화(Synchronization)</code>정도가 있을 것 같다. 아이폰에 음악을 넣을 때 아이튠즈에서 사용하는 동기화 기능 같은 것 말이다. 이때 동기화라는 행위는 <code>서로 다른 상태를 같은 것으로 만드는 것</code>을 의미한다.</p><center><br>  <img src="/2019/09/19/sync-async-blocking-non-blocking/itunes.png" width="500"><br>  <small>동기화 한번 잘못해서 아이폰에 있는 음악이 다 날아가는 경험은 다들 한번쯤 있지 않을까</small><br>  <br><br></center><p>하지만 컴퓨터 공학에서는 대부분 동기를 <code>동시에 발생하는 것</code>이라고만 설명하고 있기 때문에 느낌이 조금 다르다. 물론 <code>데이터베이스 동기화</code>와 같이 동일한 의미로 사용되는 경우도 있지만, 많은 포스팅이 I/O나 네트워크에 대한 내용을 다루고 있기 때문에 전자의 의미로 해석되는 경우가 많다.</p><p>동기와 비동기라는 단어 중 비동기는 <code>동기가 아니다</code>라는 의미이기 때문에 우리는 <code>동기</code>가 정확히 무엇을 말하는 것인지에 초점을 맞춰서 생각해봐야한다. 그래서 필자는 <code>동기</code>라는 단어가 정확히 무엇을 의미하는지부터 한번 이야기해보려고 한다.</p><p>왜 동기는 이렇게 다양한 해석을 가지는 것일까?</p><h3 id="단어의-뉘앙스를-파악해야한다"><a href="#단어의-뉘앙스를-파악해야한다" class="headerlink" title="단어의 뉘앙스를 파악해야한다"></a>단어의 뉘앙스를 파악해야한다</h3><p>고등학교 때 언어 영역이나 외국어 영역을 공부할 때 <code>지문 안에 답이 있다</code>라는 말을 들어본 적이 있을 것이다. 공학이나 과학 분야에서 사용되는 용어는 주로 영어에서 파생되었고, 이를 한국어로 번역하는 과정에서 오히려 뜻을 알기가 어려운 단어로 번역되는 경우가 있기 때문에 원본인 영어 단어의 뜻을 제대로 파악하는 것이 중요하다.</p><p>갑자기 분위기가 외국어 영역이 된 것 같지만, 필자는 개인적으로 이런 과정 또한 중요하다고 생각한다. 이 과정을 통해 왜 동기라는 단어가 상황에 따라 다른 의미를 가질 수 있는지 알 수 있기 때문이다.</p><center><br>  <img src="/2019/09/19/sync-async-blocking-non-blocking/memorize.jpg" width="350"><br>  <small>암기하지말고 이해하자</small><br>  <br><br></center><p>먼저 <code>동기(同期)</code>라는 단어의 한자를 보면 <code>같을 동(同)</code>, <code>기약할 기(期)</code>를 사용하고 있으며, 일반적으로 우리가 입사 동기, 군대 동기 등을 이야기 할 때 쓰는 동기와 같은 단어다. 이 단어의 한자만 보면 <code>같은 기간</code> 또는 <code>같은 주기</code>라는 뜻이다. 역시 우리가 일반적으로 사용하는 동기화의 의미랑은 조금 다른 것 같다.</p><p>우리가 아이폰과 아이튠즈를 동기화하는 것이 이 두 대상의 기간이나 주기를 같게 맞추는 것은 아니지 않은가? 게다가 일반적으로 한국어에서 <code>~화</code>라고 함은 앞에 붙은 단어의 의미를 그대로 가져가는 경우가 많아서 더 헷갈린다.</p><p>하지만 사실 우리가 동기의 번역으로 많이 사용하는 <code>Synchronous</code>는 살짝 다른 뉘앙스를 가지고 있다.</p><blockquote><p><strong>synchronous</strong> <small>[adjective]</small><br>: happening, existing, or arising at precisely the same time</p><footer><strong>Webster</strong><cite><a href="https://www.merriam-webster.com/dictionary/synchronous" rel="external nofollow noopener noreferrer" target="_blank">www.merriam-webster.com/dictionary/synchronous</a></cite></footer></blockquote><p>자, 일단 Synchronous는 동기와 다르게 형용사다. 그래서 사실 한국어로 정확히 번역하면 <code>동기적인</code>과 같은 뜻이 되어야 하지만, 한국어로 형용사를 단독으로 사용하는 경우는 별로 없기 때문에 그냥 편의상 명사로 번역하는 것 같다. 그러나 이런 과정에서 한국어 단어와 영어 단어의 뉘앙스가 달라지는 경우가 발생한다.</p><p>그리고 의미를 보면 <code>정확히 같은 시간에 발생, 존재하는 것</code>이라고 한다. 그리고 이 단어는 형용사이기 때문에 <code>무엇</code>이 정확하게 같은 시간에 발생하는지는 적혀있지 않다. 그럼 이제 동기화를 의미하는 명사인 <code>Synchronization</code>의 사전적 의미를 한번 살펴보자.</p><blockquote><p><strong>synchronization</strong><br>: the state of being synchronous</p><footer><strong>Webster</strong><cite><a href="https://www.merriam-webster.com/dictionary/synchronization" rel="external nofollow noopener noreferrer" target="_blank">www.merriam-webster.com/dictionary/synchronization</a></cite></footer></blockquote><p>Synchronization은 <code>Synchronous한 상태</code>라고 한다. 즉, 동기와 동기화는 근본적으로 같은 뜻이라는 말이다. 같은 단어를 공유하는 이 두 단어가 한국어로 변형되며 다른 뜻이 되는 것은 영어를 한국어로 번역하는 과정에서 영어 특유의 뉘앙스를 제대로 표현하기가 어렵기 때문에 발생하는 문제이다.</p><p>게다가 이 단어들의 원형인 <code>Synchro</code>는 단어 자체가 뜻을 의미하는 변태적인 단어이기 때문에 한국어로 번역하기도 쉽지 않다.<small>(한국어로 치면 “애매하다”같은 느낌이다. 이런건 반대로 영어로 번역하기 쉽지 않다.)</small></p><p>Synchronize, Synchronization, Synchronous 등 <code>Synchro</code>를 공유하는 이 단어들이 공통적으로 가지는 뉘앙스는 바로 <code>동시에 똑같이 진행되는 느낌</code>이다. 그것이 상태이든 동작이든 사건이든 동시에 똑같이 진행되는 느낌을 말하는 것이다.</p><center><br>  <img src="/2019/09/19/sync-async-blocking-non-blocking/synchronized-swimming.jpg" width="500"><br>  <small>대표적인 싱크로의 예</small><br>  <br><br></center><p>즉, 아이폰과 아이튠즈의 상태를 동일하게 만드는 것은 <code>작업이 끝남과 동시에 아이폰과 아이튠즈가 같은 상태</code>가 되므로 Synchronous한 상태가 된 것이고, 일반적으로 컴퓨터 공학에서 이야기하는 동기의 해석인 <code>동시에 발생하는 사건</code> 또한 Synchronous한 사건이라고 할 수 있는 것이다.</p><p>심지어 이 단어들의 어원인 <code>Syn-</code>은 단순히 <code>Together</code>라는 의미를 내포하는 단어이기 때문에 이런 상황에서도 사용할 수 있다.</p><blockquote><p>He and I are <strong>out of sync</strong> in everything<br>그와 나는 모든 면에서 <strong>맞지 않는다</strong></p></blockquote><p>이렇게 한국어로 직역하기 어려운 단어는 뉘앙스를 통해서 뜻을 이해하는 편이 더 좋다. 교수님들이나 과학자들이 한국어로 말하는 중간에 영어 단어를 섞어가면서 사용하는 것은 이런 이유도 있다고 생각한다. 사실 한국어의 <code>동기</code>라는 의미에만 초점을 맞추면 <code>Synchro</code>에서 변형된 단어들 간의 공통점을 연상하기가 쉽지 않다.</p><p>다시 정리하자면, <code>Synchro-</code>를 사용하는 단어들은 모두 <code>동시에 똑같이 진행되는 느낌</code>의 뉘앙스를 가지는 단어이다. 결국 우리가 상태의 통일을 의미하는 동기화든 컴퓨터 공학에서 말하는 동시에 발생한 사건이든 모두 같은 뉘앙스를 가지고 있다는 것이다.</p><h2 id="컴퓨터-공학에서의-동기"><a href="#컴퓨터-공학에서의-동기" class="headerlink" title="컴퓨터 공학에서의 동기"></a>컴퓨터 공학에서의 동기</h2><p>많은 포스팅에서 동기의 의미를 설명할 때 <code>현재 작업의 요청과 응답이 동시에 발생하는 것</code>으로 설명하고 있지만, 필자는 이 <code>동시</code>라는 단어가 가지는 의미와 다르게 요청과 응답 사이에는 일정한 시간이 존재할 수 밖에 없기 때문에 뭔가 모순이 느껴진다고 생각했다.</p><p>사실 <code>동시</code>라는 단어는 <code>동시다발적</code>에서의 용법과 같이 반드시 찰나의 순간만을 의미하는 것이 아니기 때문에 이렇게 설명할 수도 있긴 하지만, 일반적인 <code>동시</code>라는 단어의 용법을 생각해보면 직관적이지 않다고 생각한다.</p><p>그래서 필자는 동시에 발생하는 것은 현재 작업의 요청과 응답이 아니라 <code>현재 작업의 응답과 다음 작업의 요청</code>이라고 설명하는 게 더 맞지 않나 싶다.<small>(애초에 Synchronous는 형용사라 주어가 없다)</small></p><center><br>  <img src="/2019/09/19/sync-async-blocking-non-blocking/sync.jpg" width="500"><br>  <small>동기 방식은 현재 작업의 응답과 다음 작업의 요청의 타이밍을 맞추는 방식이다</small><br>  <br><br></center><p>즉, 현재 작업의 응답이 발생함과 동시에 다음 작업을 요청한다는 것은 작업이 <code>어떠한 순서를 가지고 진행된다는 것</code>을 의미한다. 그리고 이 응답이라는 것도 사실 귀에 붙히면 귀걸이고 코에 붙히면 코걸이로, 네트워크 모델에서는 서버의 응답일 수도 있고 I/O 모델에서는 프로세스 제어권의 반납일 수도 있다.</p><p>그럼 먼저 우리가 가장 흔하게 접할 수 있는 동기 방식의 예를 한번 보자.</p><h3 id="동기-방식-블록킹-방식"><a href="#동기-방식-블록킹-방식" class="headerlink" title="동기 방식 + 블록킹 방식"></a>동기 방식 + 블록킹 방식</h3><p>우리가 가장 흔하게 접하는 동기 방식의 예는 바로 <code>동기 &amp; 블록킹</code> 방식이다. 동기 방식이기 때문에 작업의 흐름도 순차적으로 진행되는 것이 보장되고, 블록킹 방식이기 때문에 어떠한 작업이 진행 중일 때는 다른 작업을 동시에 진행할 수가 없다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">employee</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">101</span>; i++) &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`직원: 인형 눈알 붙히기 <span class="hljs-subst">$&#123;i&#125;</span>번 수행`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">boss</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'사장: 출근'</span>);</span><br><span class="line">  employee();</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'사장: 퇴근'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boss();</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">사장: 출근</span><br><span class="line">직원: 인형 눈알 붙히기 1번 수행</span><br><span class="line">직원: 인형 눈알 붙히기 2번 수행</span><br><span class="line">...</span><br><span class="line">직원: 인형 눈알 붙히기 100번 수행</span><br><span class="line">사장: 퇴근</span><br></pre></td></tr></table></figure><p>이 코드를 보면 우리는 자연스럽게 이 작업들이 순서를 가지고 진행될 것이라는 것을 알 수 있다. 내부적으로는 하나의 콜 스택에 작업을 넣고 <code>Last In First Out</code>으로 진행되기 때문이라는 것을 알고 있지만, 여기서는 그런 내부 로직보다는 그냥 작업이 순서대로 진행된다는 것이라는 것에만 집중하자.</p><center><br>  <img src="/2019/09/19/sync-async-blocking-non-blocking/sync-block.jpg"><br>  <small>모든 인형의 눈알을 다 붙히기 전까지 퇴근은 없다</small><br>  <br><br></center><p>상위 프로세스인 <code>boss</code> 함수는 출근 작업을 수행한 뒤 하위 프로세스인 <code>employee</code> 함수에게 인형 눈알 붙히기 작업을 요청하고 있고, 이 인형 눈알 붙히기 작업이 완료되고나서야 <code>boss</code> 함수는 퇴근 작업을 수행한다.</p><p>쉽게 말해서 작업을 시킨 놈인 상위 프로세스는 작업을 하는 놈인 하위 프로세스가 종료될 때까지 절대 퇴근할 수 없다는 것이다. 이 예제와 같이 동기 방식과 블록킹 방식을 함께 사용하는 매커니즘은 일반적으로 사람들이 <code>동기</code> 방식이라고 하면 가장 먼저 떠올리는 방식이고 직관적으로 이해하기도 쉬운 편이다.</p><p>그렇다면 이 예제와 같이 동기적인 작업의 흐름을 유지하면서 <code>employee</code> 함수가 인형의 눈알을 붙히는 동안 <code>boss</code> 함수가 다른 일을 할 수도 있을까?</p><h3 id="동기-방식-논블록킹-방식"><a href="#동기-방식-논블록킹-방식" class="headerlink" title="동기 방식 + 논블록킹 방식"></a>동기 방식 + 논블록킹 방식</h3><p>물론 할 수 있다. 뭐가 어찌됐건 <code>동기</code>라는 것은 작업들이 순차적인 흐름을 가지고 있다는 것을 의미하기 때문에 이 전제만 지켜진다면 나머지는 어떻게 지지고 볶든 간에 동기 방식이라는 것은 변하지 않기 때문이다. 그래서 <code>동기 === 블록킹</code>이라고 말할 수 없는 것이다.</p><p>JavaScript의 제너레이터를 사용하면 작업의 순서를 지키면서도 상위 프로세스가 다른 작업을 하도록 만들 수 있다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">employee</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">101</span>; i++) &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`직원: 인형 눈알 붙히기 <span class="hljs-subst">$&#123;i&#125;</span>번 수행`</span>);</span><br><span class="line">    <span class="hljs-keyword">yield</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">boss</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'사장: 출근'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">const</span> generator = employee();</span><br><span class="line">  <span class="hljs-keyword">let</span> result = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">while</span> (!result.done) &#123;</span><br><span class="line">    result = generator.next();</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`사장: 유튜브 시청...`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'사장: 퇴근'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boss();</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">사장: 출근</span><br><span class="line">직원: 인형 깔알 붙히기 1번 수행</span><br><span class="line">사장: 유튜브 시청...</span><br><span class="line">직원: 인형 눈알 붙히기 2번 수행</span><br><span class="line">사장: 유튜브 시청...</span><br><span class="line">...</span><br><span class="line">직원: 인형 눈알 붙히기 100번 수행</span><br><span class="line">사장: 유튜브 시청...</span><br><span class="line">사장: 퇴근</span><br></pre></td></tr></table></figure><p>이 예제를 보면 상위 프로세스인 <code>boss</code> 함수는 출근한 후 하위 프로세스인 <code>employee</code>를 호출하여 인형 눈알 붙히기 작업을 시키고 주기적으로 이 작업이 끝났는지를 검사하고 있다.</p><p>그리고 아직 작업이 끝나지 않았다면 자신 또한 열심히 <code>유튜브 시청</code>을 수행하는 것을 볼 수 있다. 이 코드는 분명히 동기적인 흐름을 가지고 진행하고 있지만 <code>boss</code> 함수 또한 중간중간 자신의 작업을 수행하고 있으므로 블록킹이 아니라 <code>논블록킹</code> 방식을 사용하고 있는 것이다.</p><center><br>  <img src="/2019/09/19/sync-async-blocking-non-blocking/sync-non-block.jpg"><br>  <small>니가 일하는 동안 난 짬짬히 유튜브를 보겠다</small><br>  <br><br></center><p>이 예제에서도 동기 &amp; 블록킹 방식과 마찬가지로 <code>boss</code> 함수는 <code>employee</code> 함수의 작업이 끝나기 전까지는 절대 퇴근할 수 없다. 작업의 순서가 지켜지고 있는 것이다. 즉, <code>동기</code> 방식이라는 것은 작업의 순차적인 흐름만 지켜진다면 <code>블록킹</code>이든 <code>논블록킹</code>이든 아무 상관이 없다고 할 수 있다.</p><h2 id="컴퓨터-공학에서의-비동기"><a href="#컴퓨터-공학에서의-비동기" class="headerlink" title="컴퓨터 공학에서의 비동기"></a>컴퓨터 공학에서의 비동기</h2><p>필자는 동기 방식을 <code>현재 작업의 응답과 다음 작업의 요청의 타이밍이 일치하는 것</code>이라고 이야기 했다. <code>비동기</code> 방식은 말 그대로 동기 방식이 아니라는 의미이기 때문에 반대로 생각하면 된다. 즉, <code>현재 작업의 응답과 다음 작업의 요청의 타이밍이 일치하지 않아도 되는 것</code>이다.</p><center><br>  <img src="/2019/09/19/sync-async-blocking-non-blocking/async.jpg" width="500"><br>  <small>작업을 지시하고나면 그 작업이 언제 끝나는 지는 신경쓰지않는다.</small><br>  <br><br></center><p>동기 방식은 상위 프로세스가 하위 프로세스에게 작업을 지시할 때 작업의 종료 시점을 알고 있어야한다. 하위 프로세스의 작업이 완료되어 결과물을 뱉어내든 혹은 작업이 아직 진행 중이든 작업의 종료 시점은 항상 작업을 시킨 놈인 상위 프로세스가 신경쓰고있다.</p><p>하지만 비동기 방식은 다르다. 상위 프로세스는 작업을 일단 지시했으면 그 다음부터는 작업이 진행 중이든 종료가 되었든 신경쓰지않는다. 동기 방식을 설명했을 때와 마찬가지로 이때 상위 프로세스가 자신의 작업을 할 수 있냐 없냐는 별개의 문제이다.</p><p>또한 상위 프로세스가 하위 프로세스의 작업 종료 여부를 신경쓰지 않기 때문에 작업의 종료가 순차적으로 이루어지는 것을 보장하지 않는다. 그럼 먼저, 우리에게 익숙한 방식인 <code>비동기 &amp; 논블로킹</code> 방식부터 한번 살펴보자.</p><h3 id="비동기-방식-논블로킹-방식"><a href="#비동기-방식-논블로킹-방식" class="headerlink" title="비동기 방식 + 논블로킹 방식"></a>비동기 방식 + 논블로킹 방식</h3><p>비동기 방식과 논블로킹 방식을 조합한 방법은 우리에게 굉장히 익숙한 방식이다. 비동기 방식이기 때문에 상위 프로세스는 하위 프로세스의 작업 완료 여부를 따로 신경쓰지 않는다. 이후 하위 프로세스의 작업이 종료되면 스스로 상위 프로세스에게 보고를 하든 아니면 다른 프로세스에게 일을 맡기든 할 것이다.</p><p>그리고 논블로킹 방식이기 때문에 상위 프로세스는 하위 프로세스에게 일을 맡기고 자신의 작업을 계속 수행할 수도 있다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">employee</span> (<span class="hljs-params">maxDollCount = <span class="hljs-number">1</span>, callback</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">let</span> dollCount = <span class="hljs-number">0</span>;</span><br><span class="line">  <span class="hljs-keyword">const</span> interval = setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (dollCount &gt; maxDollCount) &#123;</span><br><span class="line">      callback();</span><br><span class="line">      clearInterval(interval);</span><br><span class="line">    &#125;</span><br><span class="line">    dollCount++;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`직원: 인형 눈알 붙히기 <span class="hljs-subst">$&#123;dollCount&#125;</span>번 수행`</span>);</span><br><span class="line">  &#125;, <span class="hljs-number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">boss</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'사장: 출근'</span>);</span><br><span class="line">  employee(<span class="hljs-number">100</span>, () =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'직원: 눈알 결산 보고'</span>));</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'사장: 퇴근'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boss();</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">사장: 출근</span><br><span class="line">사장: 퇴근</span><br><span class="line">직원: 인형 눈알 붙히기 1번 수행</span><br><span class="line">직원: 인형 눈알 붙히기 2번 수행</span><br><span class="line">...</span><br><span class="line">직원: 인형 눈알 붙히기 100번 수행</span><br><span class="line">직원: 눈알 결산 보고</span><br></pre></td></tr></table></figure><p>이 예제를 보면 <code>boss</code> 함수는 <code>employee</code> 함수에게 인형 눈알 <code>100</code>개를 붙히라고 지시한 후 자신은 바로 퇴근해버렸다. 상위 프로세스인 <code>boss</code> 함수는 <code>employee</code> 함수의 작업이 언제 끝나는지는 관심이 없으며 작업의 완료 신호는 콜백으로 넘겨진 <code>눈알 결산 보고</code> 작업이 대신 받아서 처리하고 있다.</p><center><br>  <img src="/2019/09/19/sync-async-blocking-non-blocking/async-non-block.jpg"><br>  <small>사장님은 작업만 지시하고 바로 퇴근하신다</small><br>  <br><br></center><p><code>비동기 &amp; 논블로킹</code> 방식은 여러 개의 작업을 동시에 처리할 수 있는 부분에서 효율적이라고 할 수 있지만, 너무 복잡하게 얽힌 비동기 처리 때문에 개발자가 어플리케이션의 흐름을 읽기 어려워지는 등의 문제가 있을 수 있다. JavaScript에서 <code>Promise</code>나 <code>async/await</code>와 같은 문법을 사용하는 이유도 이런 비동기 처리의 흐름을 좀 더 명확하게 인지하고자 하는 노력인 것이다.</p><p>또한 NodeJS의 이벤트 루프와 같이 비동기 방식도 내부 구현을 뜯어보면 동기적인 패턴이 포함되어있기 때문에 남발하게되면 어딘가에 병목이 생길 수도 있다.</p><h3 id="비동기-방식-블로킹-방식"><a href="#비동기-방식-블로킹-방식" class="headerlink" title="비동기 방식 + 블로킹 방식"></a>비동기 방식 + 블로킹 방식</h3><p>그럼 이제 마지막으로, 평소에 접하기 힘든 개념인 <code>비동기 &amp; 블로킹</code>을 살펴보자. 이 방식은 일반적인 어플리케이션 레이어에서는 자주 사용되지 않고 Linux와 Unix 운영체제의 I/O 다중화 모델 정도의 저레벨에서 사용되고 있다. 그래서 지금까지 예제로 사용하던 사장님과 직원은 이제 그만 퇴근시켜주고 설명을 진행할 것이다.</p><p>일단 이 개념은 얼핏 들으면 비효율적이기만 할 수도 있다. 비동기 방식의 장점은 하위 프로세스의 작업이 끝나는 것을 기다리지 않음으로써 <code>여러 개의 작업을 동시에 처리</code>할 수 있다는 것인데, 프로세스가 블록킹되어버려서 유휴 상태에 빠진다면 아무 것도 처리할 수 없기 때문이다.</p><p>하지만 이 개념이 나오게 된 이유는 다음과 같다.</p><blockquote><ol><li>동기 &amp; 블록킹 I/O의 경우 직관적이나, 여러 개의 I/O를 동시에 처리할 수 없다.</li><li>논블록킹 I/O는 프로세스들의 작업을 컨트롤하는 것이 까다롭다.<small>(대부분 이런 저레벨 프로그램은 C로 짠다. JS나 Python 같은 걸 생각하면 안된다.)</small></li><li>그렇다고 동기 &amp; 블록킹 I/O와 멀티 프로세싱이나 쓰레딩을 결합해서 쓰자니 자원 문제도 있고 프로세스/쓰레드 간 통신이나 동기화가 빡셈</li></ol></blockquote><p>그래서 나온 개념이 바로 <code>그럼 그냥 프로세스를 블록킹해놓고 비동기로 여러 개의 I/O를 다중화해서 받아버리는 놈을 만들면 어때?</code>인 것이다. 즉, 직관적인 코드의 흐름을 유지하면서도 작업을 동시에 처리하겠다는 것이다.</p><p>참고로 이 내용은 IBM에서 2006년에 작성한 <a href="https://developer.ibm.com/articles/l-async/" rel="external nofollow noopener noreferrer" target="_blank">Boost application performance using asynchronous I/O</a>이라는 포스팅에도 소개되어 있다.</p><center><br>  <img src="/2019/09/19/sync-async-blocking-non-blocking/async-block.gif" width="500"><br>  <small>비동기 + 블록 방식의 워크 플로우</small><br>  <br><br></center><p>위 그림을 보면 중간에 <code>select()</code>라는 함수가 있는데, 이 친구가 바로 프로세스를 블록킹함과 동시에 여러 개의 I/O를 받아서 처리하는 역할을 한다. 이 함수는 C언어의 API로 제공되고 있으며, 그냥 <code>include &lt;sys/select.h&gt;</code>와 같이 헤더를 가져와서 쓰면 된다.</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">select</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, </span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>이때 <code>nfds</code>는 감시할 파일의 개수를, <code>fd_set</code> 구조체들은 각각 읽을 데이터, 쓰여진 데이터, 예외처리가 발생한 것을 감시할 파일 목록이다. 이때 <code>fd...</code>는 <code>File Descriptor</code>의 약자이며, 파일을 감시하고 있다가 해당 I/O가 발생하면 자신이 가지고 있는 비트 배열 구조체의 해당 값을 <code>1</code>로 변경한다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]</span><br><span class="line"><span class="hljs-comment">// 파일 목록 중 3번째 파일에 변경사항이 있다면 FD의 비트 배열 구조체가 변경된다</span></span><br></pre></td></tr></table></figure><p>그리고 timeval 구조체인 <code>timeout</code> 인자는 감시할 시간을 의미한다. 즉, 이 <code>timeout</code> 인자에 넘겨준 시간 동안 상위 프로세스를 블록킹하면서 자신이 넘겨받은 파일 목록을 계속 감시하고 있는 것이다. 그리고 감시하고 있는 동안 파일에 읽기, 쓰기, 예외가 발생하면 <code>select</code> 함수가 종료될 때 자신이 감시하던 있는 파일들 중 해당 변경사항이 발생한, 즉 처리해야할 파일의 개수를 반환한다.</p><p>대충 이 정도가 <code>비동기 &amp; 블록</code> 방식의 대표적인 예인 <code>select</code> 함수가 작동하는 방식이다. 정리하자면 일정 시간동안 프로세스를 멈춰놓고 자신이 감시하고 있는 파일들에서 I/O가 발생하는지를 감시하는 것이다. 그리고 일정 시간이 지나면 함수가 종료되며 그동안 감시했던 파일들의 I/O 결과를 반환하고 프로세스의 블록킹이 풀린다.</p><p>이 방식은 블록킹 방식으로 진행되기 때문에 개발자에게도 직관적으로 다가오고, 비동기 방식이기 때문에 여러 개의 I/O를 동시에 감시하며 처리할 수 있다. 하지만 성능이 그렇게 좋은 편은 아니므로 IBM에서는 높은 성능이 필요한 어플리케이션에서는 되도록 쓰지 말라고 한다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>필자는 대학교 때 네트워크 과목을 수강하며 <code>동기</code>에 대한 개념을 처음 배웠었는데, 사실 그때는 굉장히 단편적인 내용만을 알고 있었다. 단순히 두 디바이스간의 클럭과 일정 크기의 프레임을 맞추어 통신하는 것이 동기식 통신이라는 것 정도?</p><p>하지만 개발자로 일을 하면서 공부를 더 하다보니까 동기식 I/O, 동기식 프로그래밍 등 동기에 대한 다른 개념들을 계속 해서 접하게 되었는데, 서문에서 이야기했듯이 누구는 동기라는 단어가 <code>동시에 발생하는 것</code>이라고 하고 누구는 <code>특정한 클럭을 맞춰서 통신하는 것</code>, 또 누구는 <code>이전 작업이 끝날 때까지 기다리는 것</code>이라고 하는 등 해석이 다 달라서 더 혼란스러웠다.</p><center><br>  <img src="/2019/09/19/sync-async-blocking-non-blocking/dont-know.jpg" width="300"><br>  <small>아니 왜 말하는 게 다 달라…?</small><br>  <br><br></center><p>그래서 이번 포스팅을 작성하면서 <code>Synchronous</code>라는 단어가 정확히 어떤 상태를 의미하는 것인지부터 다시 공부했었는데, 확실히 단어의 뉘앙스를 이해하고나니 왜 이렇게 다른 해석들이 나오게 되었는지 약간은 이해가 가는 것 같다. 단어 자체가 뜻을 의미하는 단어다보니 이건 그냥 해석하기 나름인것 같기도 하다.</p><p>어쨌든 다른 건 다 차치하고서라도 Synchronous라는 단어가 <code>동시에 똑같이 진행되는 느낌</code>이라는 뉘앙스를 알게 된 것이 이번 포스팅의 최대 수확이 아닐까라는 생각을 해본다.</p><p>이상으로 동기(Synchronous)는 정확히 무엇을 의미하는걸까? 포스팅을 마친다.</p>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/09/19/sync-async-blocking-non-blocking/#disqus_thread</comments>
    </item>
    
    <item>
      <title>비전공 개발자가 전공자보다 정말 불리할까?</title>
      <link>https://evan-moon.github.io/2019/09/09/major-is-not-important/</link>
      <guid>https://evan-moon.github.io/2019/09/09/major-is-not-important/</guid>
      <pubDate>Sun, 08 Sep 2019 23:20:39 GMT</pubDate>
      <description>
      
        &lt;p&gt;이번 포스팅에서는 많은 분들이 질문해주신 &lt;code&gt;컴퓨터 공학을 전공하지 않은 개발자가 과연 전공자에 비해 불리한가&lt;/code&gt;에 대해서 한번 이야기해보려고 한다.&lt;/p&gt;
&lt;p&gt;어떻게 보면 예민한 주제일수도 있지만 주변에 이와 같은 질문을 주시는 분들도 꽤 있는데다가, 심지어 컴퓨터 공학을 전공하지 않았다는 이유로 자기 자신을 낮게 평가하시는 분도 계셨다. 필자는 이런 것들이 어떤 특정 개인에게 국한된 것이 아니라고 생각되어 이에 대한 필자의 생각을 조심스럽게 한번 적어보려고 한다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>이번 포스팅에서는 많은 분들이 질문해주신 <code>컴퓨터 공학을 전공하지 않은 개발자가 과연 전공자에 비해 불리한가</code>에 대해서 한번 이야기해보려고 한다.</p><p>어떻게 보면 예민한 주제일수도 있지만 주변에 이와 같은 질문을 주시는 분들도 꽤 있는데다가, 심지어 컴퓨터 공학을 전공하지 않았다는 이유로 자기 자신을 낮게 평가하시는 분도 계셨다. 필자는 이런 것들이 어떤 특정 개인에게 국한된 것이 아니라고 생각되어 이에 대한 필자의 생각을 조심스럽게 한번 적어보려고 한다.</p><a id="more"></a><blockquote><p>이 포스팅은 비전공 개발자가 많은 분야인 백엔드, 프론트엔드, 모바일 앱 개발자 등에 대해서 이야기할 예정이다. 어플리케이션 레이어보다 더 로우한 레이어에서 개발을 하는 분야는 애초에 비전공자가 들어가기 힘든 분야이기 때문이다.</p></blockquote><p>필자는 지난 1년 간 꽤 많은 사람의 면접을 진행했었는데, 그 중에는 컴퓨터 공학 전공자도 있었고 IT와 전혀 관련없는 전공을 가지신 분도 있었으며, 대학교를 갓 졸업한 신입부터 경력이 10년 넘은 시니어 개발자까지 다양한 사람들이 있었다.</p><p>일단 결론부터 말하자면 경력은 경우에 따라 고려되는 경우가 있겠지만, 사실 전공 자체는 <code>컴퓨터 공학 전공</code>이든 <code>파리 뒷다리 분해학 전공</code>이든 그게 그렇게 중요한 건 아니라고 생각한다. 다만 컴퓨터 공학을 전공한 사람이 전공하지 않은 사람에 비해서 여러모로 유리한 점이 있다는 것 또한 사실이기에, 컴퓨터 공학 전공이라는 타이틀 자체가 어떤 이점을 가지고 있는 지는 한번쯤 생각해봄직 하다.</p><p>또한 본인이 컴퓨터 관련 학과를 졸업하지 않았다면, 막연한 두려움을 가지기 보다는 <code>내가 전공자와 어떤 차이가 있는지</code>를 명확하게 인지하고 그에 따른 공부를 하면 그만이다. 대학교에서 가르치는 과목이라고 해서 독학하지 못할 것도 없기 때문이다. 그리고 컴퓨터 공학을 전공 했다고 해서 전공자들이 무슨 넘사벽 계층도 아니고, 공부하면 충분히 앞지를 수 있다.</p><p>참고로 필자는 인서울 4년제 대학교를 나오지도 않았으며, 컴퓨터 공학 전공도 아니다. 필자는 학점은행제인 동국대학교 전산원에서 멀티미디어 공학을 전공했지만 전공 선택 과목으로 대부분 컴퓨터 공학과의 과목을 선택해서 수강했기 때문에 전공과 비전공의 애매한 경계에 걸쳐있는 <code>혼종</code>이라고 할 수 있다.<small>(원래 멀티미디어과 커리큘럼 자체가 잡캐 양성소다)</small></p><p>그래서 필자는 혼종의 입장에서 컴퓨터 공학을 전공하신 분들의 고민도 들어보고 비전공이신 분들의 고민도 들어볼 수 있었는데, 이에 대한 몇가지 생각을 이번 포스팅에서 한번 적어보려고 한다.</p><h2 id="회사에서는-전공보다-실력을-본다"><a href="#회사에서는-전공보다-실력을-본다" class="headerlink" title="회사에서는 전공보다 실력을 본다"></a>회사에서는 전공보다 실력을 본다</h2><p>사실 모두 알다시피 개발자와 같은 전문기술직은 학력보다는 실력이 최우선으로 우대된다. 게다가 개발자들의 실력은 천차만별이라 좋은 대학교의 컴퓨터 공학과를 졸업한 10년차 개발자라고 해도 프로그래밍 실력은 형편 없을 수도 있고, 반대로 대학을 안가고 고등학교만 졸업한 신입 개발자라고 해도 엄청난 실력을 가진 개발자일 수도 있는 게 이 쪽 세계의 특징이다.</p><p>하지만 많은 사람들이 대학을 가라고 하는 데는 다 이유가 있다. <code>대학을 가서 더 깊은 공부를 해라</code> 뭐 이런 이유도 있겠지만 사실은 좀 더 현실적인 이유 때문에 추천을 하는 것이다.</p><p>이 이유를 알기 위해서 우리는 입사 지원자가 아니라 채용 담당자의 입장에서 생각해볼 필요가 있다.</p><h3 id="엄마가-대학을-가라고-했던-이유"><a href="#엄마가-대학을-가라고-했던-이유" class="headerlink" title="엄마가 대학을 가라고 했던 이유"></a>엄마가 대학을 가라고 했던 이유</h3><p>사실 필자도 대한민국에서 살면서 그 놈의 지긋지긋한 인서울 대학에 대한 집착을 많이 겪어본 터라, 학력주의사회에 대한 어느 정도 염증을 가지고 있는 사람이다. 하지만 사람들이 학력이나 전공이 중요하다고 말할 수 밖에 없는 이유는 따로 있다. 바로 채용 담당자가 나의 이력서만 보고 얻을 수 있는 정보는 굉장히 단편적이기 때문이다.</p><center><br>  <img src="/2019/09/09/major-is-not-important/resume-sample.png" width="300"><br>  <small>이력서에 적혀있는 정보는 단편적이고 진위 여부도 알기 힘들다</small><br>  <br><br></center><p>자, 우리가 새로운 개발자를 뽑는 채용 업무를 맡았다고 생각해보자. 참고로 작은 기업에서는 이 업무를 해당 업무를 하는 실무자에게 맡기기도 하기 때문에 여러분의 경력과 상관없이 상황에 따라서 언제든지 맡을 수 있는 업무이다.</p><p>우리는 이제 채용 담당자로써 하루에도 수십 통 또는 수백 통 씩 쏟아지는 입사지원자들의 이력서를 살펴보고 이 중에서 2차 기술 면접을 진행할 사람을 필터링 해야한다. 이력서에 적힌 정보는 여러 가지가 있겠지만 지원자의 <code>경력</code>과 <code>기술 스펙</code> 정도가 제일 핵심 정보가 될 것이다.<small>(성별과 얼굴을 보시는 분은 없을거라 믿는다)</small></p><p>어쨌든 입사 지원자의 이력서를 보고 우리가 알고 싶은 것은 <code>이 사람이 회사가 요구하는 최소한의 실력을 만족하는 사람인지</code>에 대한 것이다. 조금 더 냉정하게 말하자면, 면접관으로 들어갈 팀원들의 리소스를 투자하면서 이 지원자를 더 자세히 알아보고 싶은 가치가 있는 것인지 고민하는 것이다.</p><p>그리고 이 단계에서 이력서라는 몇 장의 종이 쪼가리만 보고 이 사람의 <code>가치관</code>이나 <code>성격</code> 같은 것을 알기는 힘들기 때문에 일반적으로 <code>기술 스펙</code>을 중점으로 확인하게된다.</p><p>지원자가 시니어일 경우는 경력을 보고 이 분이 지금까지 어떤 길을 걸어왔는지 대략 유추해볼 수 있지만, 신입이나 주니어의 경우는 경력이라고 할게 거의 없기 때문에 경력에서는 실력에 대한 정보를 거의 얻을 수 없는 경우가 많다.<small>(물론 신입이라도 가끔 눈에 확 띄는 굇수 분들이 있긴 하다)</small></p><p>그렇다면 다음으로 볼 수 있는 것이 이력서에 첨부된 <code>블로그</code>나 <code>깃허브</code>인데, 이 마저도 없는 경우에는 무엇을 보고 이 사람의 실력을 유추해볼 수 있을까?</p><p>이런 상황에서는 사실 학교와 전공을 볼 수 밖에 없다. 이 지원자의 실력을 판가름할 수 있는 정보가 더 이상 없기 때문이다. 물론 이후 기술 면접을 진행하면 좀 더 상세히 알 수 있겠지만, 기술 면접 자체도 기존 팀원들의 리소스를 어느 정도 잡아먹는 일이기 때문에 무작정 모든 지원자의 기술 면접을 진행할 수도 없는 노릇이다.</p><p>그래서 사람들이 <code>학력</code> 또는 <code>전공</code>도 나름 중요하다고 하는 것이다. 즉, 내가 아무것도 가지고 있지 않은 상황에서 최소한의 보험이라고 할 수 있다.</p><h3 id="내-실력을-증명하는-것이-중요하다"><a href="#내-실력을-증명하는-것이-중요하다" class="headerlink" title="내 실력을 증명하는 것이 중요하다"></a>내 실력을 증명하는 것이 중요하다</h3><p>우리가 방금 위에서 예시로 보았던 상황을 다시 되짚어보면 회사에게 중요한 것은 <code>이 사람이 회사에 입사해서 일을 할 수 있는 최소한의 실력이 되는가</code>이지, 학교나 전공 자체가 아니다. 고졸이든 인서울대학 컴공을 졸업했든 부트캠프를 수료했든 실력이 좋은 개발자는 어디서든 모셔가기 마련이다.</p><p>자, 만약 다음과 같은 두 사람이 있다면 회사는 어떤 사람을 선택할까?</p><blockquote><ol><li>SKY 컴퓨터 공학과를 졸업했지만 깃허브도 없고 어떤 프로젝트를 진행했었는지도 알 수가 없다.</li><li>고졸이지만 오픈 소스인 유명 프레임워크의 핵심 컨트리뷰터이다.</li></ol></blockquote><p>조금 극단적인 예시긴 하지만 아무래도 2번 개발자가 선택될 확률이 더 높을 것이다. 결과적으로 회사가 원하는 개발자는 <code>일을 잘하는 개발자</code>이지 단순히 좋은 학교의 컴퓨터 공학과를 졸업한 개발자는 아니기 때문이다.</p><p>당연히 학벌 이외에 실력을 검증할만한 요소가 없는 1번 개발자보다는 오픈 소스에 컨트리뷰팅을 함으로써 실력이 어느 정도 검증된 2번 개발자를 선택하는 것이 회사 입장에서도 리스크가 적다. 그러나 만약 2번 개발자의 실력을 유추할 수 있는 무언가가 없었다면 그때는 1번 개발자가 선택될 확률이 높다.</p><p>즉, 내 실력을 증명할 수만 있다면 학력이나 전공은 뒤집을 수 있다는 것인데, 이때 회사가 원하는 실력이 어떤 것인지 파악하는 것이 중요하다. 어떤 회사는 특정 프레임워크에 해박한 사람을 원할 수도 있고, 어떤 회사는 프레임워크는 그냥 와서 공부하면 되지만 탄탄한 기초 지식이 있어야한다고 하는 등 회사마다 또는 그 회사가 처한 상황마다 원하는 인재의 기술 스펙은 달라질 수 있기 때문이다.</p><p>결과적으로 우리는 전공 여부나 학벌과 관계없이 이 스펙만 맞춰주면 되는 것이다. 근데 회사에서 원하는 기술 스펙과 실력만 맞춰도 취업에 지장이 없다면, 컴퓨터 공학 전공자가 비전공자에 비해서 유리한 점은 없는걸까?</p><p>아니, 솔직히 말해서 그렇지는 않다. <code>실력만 있다면 전공 여부는 중요하지않다</code>라는 말이 <code>비전공자가 더 유리하다</code>라는 말은 아니기 때문이다.</p><h2 id="전공자가-비전공자에-비해-유리한-점"><a href="#전공자가-비전공자에-비해-유리한-점" class="headerlink" title="전공자가 비전공자에 비해 유리한 점"></a>전공자가 비전공자에 비해 유리한 점</h2><p>컴퓨터 공학을 전공한 사람은 어쨌든 간에 4년 정도 전문적인 커리큘럼을 통해 컴퓨터에 대한 공부를 꾸준하게 해온 사람이다. 그래도 4년 동안 교육을 받은 사람들인데 비전공자와 아무런 차이가 없다면 거짓말일 것이다. 하지만 전공자와 비전공자 간의 차이는 <code>프로그래밍 실력</code> 자체는 아니다.</p><p>요즘에는 짧은 기간 안에 부트캠프를 수료하신 분들도 최신 트렌드 기술을 사용하여 어플리케이션을 훌륭하게 만들어 내시는 분들이 많기 때문이다. 그렇다면 회사가 컴퓨터 공학을 전공한 사람에게 기대하는 것은 무엇일까?</p><h3 id="지피지기면-백전백승이다"><a href="#지피지기면-백전백승이다" class="headerlink" title="지피지기면 백전백승이다"></a>지피지기면 백전백승이다</h3><p>참고로 필자가 지금 이 이야기를 하는 이유는 전공자가 이런 면에서 더 유리하기 때문에 이 부분은 그냥 포기하라는 의미로 하는 말이 아니다.</p><p>포스팅의 서두에서 한번 이야기 했지만, 내가 비전공 개발자라면 전공자들에 비해서 어떤 점이 부족한지 알고 있어야 그 점을 보완할 수 있다. 그래야 공부의 방향도 잡을 수 있고 나만의 강점을 만들 수도 있기 때문에 우선 필자가 생각했을 때 컴퓨터 공학 전공자가 가지는 장점에 대해서 한번 이야기 해보려고 한다.</p><h3 id="컴퓨터-공학과는-코딩을-배우는-곳이-아니다"><a href="#컴퓨터-공학과는-코딩을-배우는-곳이-아니다" class="headerlink" title="컴퓨터 공학과는 코딩을 배우는 곳이 아니다"></a>컴퓨터 공학과는 코딩을 배우는 곳이 아니다</h3><p>솔직히 말해서 둘 다 신입인 경우에는 전공이든 비전공이든 프로그래밍을 하는 실력 자체에는 큰 차이가 없다고 생각한다. 물론 이 기준은 일반적으로 어플리케이션 레이어에서 비즈니스 어플리케이션을 개발하는 개발자를 이야기하는 것이다. 애초에 이보다 더 로우한 레이어의 분야는 비전공자가 들어갈 틈 자체가 넓지 않다.</p><p>여기서 많은 분들이 오해하시는 부분이 있는데, 컴퓨터 공학을 전공했으면 당연히 프로그래밍도 비전공자보다 잘할 것이라고 생각하는 것이다. 하지만 컴퓨터 공학도가 학교에서 배우는 것은 <code>함수형 프로그래밍</code>이나 <code>Git을 사용한 버전 관리</code>나 <code>Flux 패턴</code> 같은 것이 아니다. 어디까지나 컴퓨터 공학도가 궁극적으로 추구하는 것은 프로그래밍보다 더 근본적인 컴퓨터 시스템의 원리와 구조적인 사고를 하는 방법이다.</p><p>가령 OS 과목을 수강하게 되면 배우는 것 중에서 <code>프로세스 스케줄링(Process Scheduling)</code>라는 것이 있다. 프로세스 스케줄링은 단일 프로세서 시스템에서 여러 개의 프로세스를 어떤 방식으로 실행해야 효율적으로 프로세스를 처리할 수 있을 지에 대한 이론과 알고리즘을 의미한다. 이때 <code>SJF</code>, <code>FCFS</code>, <code>RR</code> 등 여러가지 알고리즘을 배우게 되는데, 사실 왠만큼 로우 레벨로 내려가지 않는 이상 일반적인 어플리케이션을 만들 때 이런 개념을 활용해야 경우는 드물다.</p><p>필자도 위 개념을 학교에서 배웠기 때문에 알고는 있었지만 실제로 사용해본 적은 한번도 없고, 대신 Node.js의 이벤트 루프를 이해할 때 약간의 도움은 되었던 것 같다.</p><p>컴퓨터 공학과에서 배우는 학문은 이런 느낌이다. 즉, 컴퓨터 공학과를 졸업했다고 해서 바로 비즈니스 어플리케이션을 잘 만드는 것은 약간 거리가 있다는 것이다. 비즈니스 어플리케이션을 잘 만드려면 <code>MVC</code>, <code>MVVM</code>, <code>Flux</code>와 같은 상태 관리 방법이나, 디자인 패턴, 적절한 개발 방법론 등 여러가지 요소가 필요한데 이런 건 학교에서 따로 알려주지 않는다.</p><p>심지어 면접보러가서 <code>Git</code>이라는 걸 처음 알았다는 사람도 있었다. 그래서 컴퓨터 공학을 전공한 사람들도 졸업 후 다시 학원에 들어가서 배우는 경우도 왕왕 있다.</p><p>컴퓨터 공학을 전공한 사람이 비전공인 사람보다 프로그래밍 실력 자체가 그렇게 월등하게 높지 않다면, 전공자가 비전공자에 비해 유리한 점은 도대체 무엇일까?</p><h3 id="기초-지식이-탄탄할-확률이-높다"><a href="#기초-지식이-탄탄할-확률이-높다" class="headerlink" title="기초 지식이 탄탄할 확률이 높다"></a>기초 지식이 탄탄할 확률이 높다</h3><p>바로 컴퓨터에 대한 <code>기초 지식</code>을 보유한 사람의 비중이 높다는 것이다. 이때 필자가 말하는 기초 지식은 <code>자료구조</code>, <code>알고리즘</code>, <code>네트워크</code>, <code>수학</code>, <code>암호학</code> 등 컴퓨터 관련 기술의 근본을 이루는 지식을 말하는 것이다. 사실 이런 지식이 중요하다고 하는 사람도 있고 아닌 사람도 있지만, 필자는 초반에는 몰라도 경력이 쌓이면 쌓일 수록 이런 지식들이 빛을 발한다고 생각한다.</p><p>사실 요즘에는 워낙 좋은 프레임워크들도 많은데다가 대부분의 기술들이 사용하기 쉽게 추상화되어 있기 때문에 기초 지식을 모르더라도 프로그램을 만드는 데는 큰 지장이 없다. 하지만 이런 최신 트렌드는 2~3년 만에 패러다임이 완전히 바뀌기도 하는 등 굉장히 빨리 변화하기 때문에 이렇게 쏟아져 나오는 기술을 빠르게 따라갈 수 있는 개발자가 시장에서 양질의 경쟁력을 가질 수 밖에 없다.</p><p>이런 새로운 기술들은 얼핏 보면 굉장히 혁신적이고 새로운 개념인 것 같지만, 대부분의 경우 기존에 존재하던 개념을 기반으로 발전한 것들이 많다. 그렇다는 얘기는 결국 기반 기술 자체는 크게 변하지 않는다는 것이다.</p><p>예를 들어 <code>HTTP/1.1</code>에서 <code>HTTP/2</code>로 바뀐 것은 얼핏 보면 많은 기능이 추가되었기 때문에 기존과 전혀 다른 새로운 무언가라고 생각할 수 있지만, 결국은 기존의 HTTP 프로토콜에서 이미 사용하고 있던 TCP 커넥션을 좀 더 효율적으로 사용할 수 있게 바뀐 것이다. 이때 기반 기술에 대한 키워드는 <code>TCP</code>가 될 것이다.</p><p><code>Docker</code> 또한 기존에 이미 존재하던 VM 등이 사용하던 가상화 기법이 너무 무거우니까 가상머신마다 각각 Guest OS 레이어를 올리는 것이 아니라 어플리케이션 구동에 필요한 부분만 떼어내서 공통으로 사용할 레이어로 올리고 그 위에 프로세스 레이어만 분리하자는 개념에서 출발한 것이다. 이때 기반 기술에 대한 키워드는 <code>가상화</code>, <code>레이어에 대한 개념</code> 정도가 될 것이다.</p><center><br>  <img src="/2019/09/09/major-is-not-important/dockervsvm.jpg" width="500"><br>  <small>기존의 가상화 기법과 Docker의 차이는 결국은 이 <code>레이어</code>를 어떻게 쌓느냐이다</small><br>  <br><br></center><p>즉, 이렇게 완전히 새로운 패러다임인 것 같은 기술도 그 밑바닥에는 기존의 기반 기술들이 자리잡고있다. 그렇기 때문에 이런 기반 지식들을 어느 정도 알고 있는 사람은 기반 지식을 모르는 사람보다 새로운 기술이 나왔을 때 학습 곡선을 상대적으로 완만하게 그려나갈 수 있다는 것이다.</p><p>그러나 이러한 기반 지식이 없다면 새로운 기술이 나올 때마다 해당 프레임워크의 사용법만을 공부하거나, 다른 개발자들이 이미 정리해놓은 정보들을 통해 학습할 수 밖에 없다. 이런 학습 방식은 <code>이해</code>라기 보다는 <code>암기</code>에 가깝기 때문에 몇 달 뒤에 비슷한 기술이 또 출시되면 같은 루프를 반복하며 학습해야한다.</p><p>즉, 컴퓨터 관련 학과를 졸업한 사람은 4년 동안 학교 생활을 어떻게 했던 간에 이런 기초 지식을 학교에서 대부분 배우긴 했다는 것이고, 대체로 이런 기반 지식을 활용해 새로운 기술에 높은 적응력을 보일 가능성이 높다. 이런 이유로 많은 개발자들이 이런 적응력과 잠재력을 컴퓨터 관련 학과를 졸업한 신입이나 주니어에게 기대하게 되는 것이다.</p><h2 id="내-실력을-키우고-어필하자"><a href="#내-실력을-키우고-어필하자" class="headerlink" title="내 실력을 키우고 어필하자"></a>내 실력을 키우고 어필하자</h2><p>4년 동안 학교에서 구르면서 기초 지식을 좋든 싫든 강제로라도 배워서 나온 전공자에 비해서 비전공자는 학원이나 부트캠프를 통해 짧은 기간동안만 프로그래밍을 배운 경우가 많기 때문에 전공자에 비해 상대적으로 기초에 대한 지식이 적을 수 밖에 없다.</p><p>이는 학원이라는 교육 기관의 특성 상 짧은 기간 안에 수강생을 <code>프로그래밍이 가능한 인재</code>로 만들어 내기 위해 발생한 어쩔 수 없는 결과이다. 학원의 경우 대부분 <code>6개월</code>에서 <code>9개월</code> 정도의 학습 기간을 가지는데, 사실 이렇게 짧은 기간 안에 컴퓨터에 대한 기초 이론부터 가르쳐서 취업을 시킨다는 건 거의 불가능한 미션이기 때문이다.</p><p>물론 부트캠프를 수료하신 몇몇 분들의 이야기를 들어보면 비록 짧은 기간이지만 그 기간 내내 오전 8시부터 밤 10시까지 프로젝트를 진행하는 소름돋는 스케줄을 소화해낸다고 한다.<small>(다들 열정이 대단하시다)</small></p><p>하지만 아무래도 전공자와 비교 했을 때 절대적인 학습 시간의 차이는 있을 수 밖에 없고, 학원에서 가르치는 것은 <code>코딩</code> 또는 <code>특정 프레임워크의 사용법</code>이지 컴퓨터의 기초 개념이 아니기 때문에 연차가 쌓일 수록 이런 기초 지식의 부재로 인해 새로운 지식을 학습하는 것에 부담을 느끼고 경쟁에서 밀리는 경우가 왕왕 보인다.</p><p>그러나 실제로 취업하고 있는 수많은 비전공 출신 개발자 분들을 보면 컴퓨터 공학을 전공하지 않은 개발자들이 시장에서 경쟁력을 가지고 있다는 것 또한 분명히 사실이다. </p><p>위에서 이야기했듯이 개발자라는 직업은 결국 실력이 깡패기 때문에 <code>내 실력을 얼마나 잘 어필할 수 있냐</code>가 중요한 포인트다. 필자도 일단 이력서에는 <code>멀티미디어 공학</code>이라고 찍혀있기 때문에, 면접을 볼 때 비록 컴퓨터 공학을 전공하지는 않았지만 필자만의 장점이 있다는 점을 어필하고는 한다.</p><h3 id="블로그와-깃허브는-중요하다"><a href="#블로그와-깃허브는-중요하다" class="headerlink" title="블로그와 깃허브는 중요하다"></a>블로그와 깃허브는 중요하다</h3><p><code>블로그</code>는 채용 담당자 입장에서 굉장히 도움이 많이 되는 정보이다. 이 사람이 평소에 생각하는 것과 관심있는 기술, 공부하는 방법, 문제를 해결했던 경험 등을 정제된 형태의 데이터로 한 눈에 볼 수 있는 창구이기 때문이다.</p><p>비전공 개발자는 이력서를 통해 채용 담당자에게 내 실력을 인증할 수 있는 데이터가 전공자에 비해 상대적으로 부족하기 때문에 이렇게 적극적으로 자신의 실력과 프로그래밍에 대한 관심을 어필할 수 있는 수단을 사용하는 것이 좋다.</p><p>또한 많은 기업들이 <code>내가 알고 있는 지식을 남에게 공유하는 행위</code>에 대해서 긍정적으로 생각하고 있기 때문에 블로그를 꾸준히 작성하면 분명히 도움이 된다. 도저히 뭘 써야할 지 감이 안온다면 자신이 재밌게 읽었던 외국 포스팅의 번역부터 시작해보자. 필자 같은 경우는 크게 두가지 주제를 가지고 글을 쓰는 편인데, 하나는 지금 이 포스팅처럼 그냥 필자의 생각을 적는 것이고, 다른 하나는 기술 관련 포스팅이다.</p><p>특히 기술 관련 글을 작성할 때는 잘못된 지식을 전하지 않으려는 두려움 때문에라도 강제로 엄청난 리서칭을 하게 될 수 밖에 없고, 그 리서치 결과를 글로 정리하는 과정에서 다시 한번 정제되기 때문에 그냥 읽기만 하는 것보다 오히려 더 공부가 되고 기억에도 오래 남는 경향이 있다.</p><p>또한 이렇게 자신의 생각을 글로 정리해서 적는 행위 자체는 논리력 향상에 굉장히 많은 도움을 준다고 한다. 말로 하면 어느 정도 논법이 맞지 않아도 들어줄만 하지만 이렇게 글을 작성할 때 논법과 주제가 흐려지기 시작하면 그냥 딱 봐도 굉장히 어색한 글이 되버리기 때문이다. 개발자에게 논리력이 얼마나 중요한 요소인지는 굳이 말하지 않아도 다들 알고있으리라 생각한다.</p><p>그리고 <code>깃허브</code>는 두 번 말하면 입 아플 정도로 엄청 중요하다. 하지만 잔디를 꾸준히 심지않는 빈 계정과 다름 없는 상태에서는 별로 임팩트가 없기 때문에 사이드 프로젝트를 하던 오픈 소스에 기여를 하던 꾸준히 커밋을 하는 것을 추천한다. 솔직히 어떤 사람의 깃허브 계정을 봤을 때 진한 초록색 잔디가 가득 심어져 있다면 <code>오 대박 쩌는걸</code>이라는 감탄사가 나올 수 밖에 없다.</p><center><br>  <img src="/2019/09/09/major-is-not-important/commit-graph.png" width="500"><br>  <small>필자의 깃허브 잔디. 빡빡하진 않지만 적어도 <code>얘가 뭔가를 하고 있구나</code> 정도는 알 수 있다</small><br>  <br><br></center><p>게다가 깃허브 레파지토리를 살펴보거나 어떤 프로젝트에 스타를 찍었는지를 보면 최근 어떤 기술에 관심을 가지고 있는 지도 알 수 있다. 하지만 무엇보다 제일 큰 장점은 이 사람이 작성한 코드를 직접 볼 수 있다는 것에 있다. 코딩을 시작한지 얼마 안된 사람일수록 자신의 코드를 공개된 장소에 오픈한다는 것을 부끄럽다고 생각할 수 있지만, 생각보다 남들이 여러분의 코드를 그렇게까지 자세히 분석하고 점수 매기지는 않으니까 그냥 작은 걸 만들더라도 왠만하면 Public으로 깃허브에 올리자.</p><center><br>  <img src="/2019/09/09/major-is-not-important/pinned.png" width="500"><br>  <small>깃허브 레파지토리를 보면 어떤 기술에 관심이 있는지 대략 알 수 있다</small><br>  <br><br></center><p>최근에는 코드스테이츠와 같은 부트캠프에서도 수강생들에게 블로그나 깃허브 계정을 생성하는 것을 추천하고 있는 걸로 봐서 취업에 이런 것들이 도움이 된다는 사실을 수강생들에게도 알려주고 있는 것 같다.</p><h3 id="나만의-전문성을-확보하자"><a href="#나만의-전문성을-확보하자" class="headerlink" title="나만의 전문성을 확보하자"></a>나만의 전문성을 확보하자</h3><p>개발자는 현실의 다양한 문제를 컴퓨터를 통해 해결하는 사람들이다. 이때 <code>현실의 문제</code>란 어떤 단일 카테고리의 문제가 아니라 굉장히 다양한 카테고리의 문제라는 것을 잊어서는 안된다. 소프트웨어는 의료, 금융, 예술 등 다양한 분야에서 사용되고 있고, 결국 그 소프트웨어도 개발자가 만드는 것이다.</p><p>이때 이런 다양한 분야의 문제를 해결하기 위해서는 컴퓨터 관련 지식 뿐만 아니라 다른 분야의 지식도 함께 요구될 수 밖에 없다. 자신이 만드는 프로그램이 어떤 일을 하는지도 모르면서 좋은 프로그램을 만들 수는 없지 않을까?</p><p>비전공 개발자는 자신의 원래 전문 분야가 있는 사람들이 많기 때문에 이 점을 잘 살려보면 자신만의 특별한 무기가 될 수도 있다고 생각한다. 어쨌든 개발자로 일을 하고 있다는 것은 개발에도 어느 정도 전문성을 가지고 있다는 것이기 때문에, 자신의 원래 전문 분야가 있던 사람은 전문 분야가 최소 2개 이상이라는 것이기 때문이다.</p><p>만약 <code>더존</code>과 같은 회계관리 프로그램을 만드려면 개발자도 어느 정도 회계에 대한 지식이 있어야 하고, <code>Logic Pro X</code>와 같은 오디오 편집 프로그램을 만드려면 개발자도 오디오와 음악에 대한 지식이 있어야 하기 때문이다. 그러나 4년 동안 컴퓨터 공학만을 공부한 사람의 경우에는 따로 찾아서 공부하지 않는 이상 다른 분야의 지식을 습득하기 쉽지 않기 때문에 다른 전공을 공부하고 개발자가 된 사람은 이 점에서 나름 강점을 가지고 있다.</p><center><br>  <img src="/2019/09/09/major-is-not-important/logic-pro-x.jpg" width="500"><br>  <small>오디오와 음악에 대한 지식이 없다면 Logic Pro X와 같은 프로그램은 만들 수 없다</small><br>  <br><br></center><p>필자 같은 경우는 예전에 연예 기획사에서 사운드 엔지니어로 일을 했었기 때문에 오디오와 레코딩에 지식을 가지고 있다. 또한 어릴 때부터 꾸준히 음악 교육을 받았기 때문에 음악에 대한 지식도 어느 정도 가지고 있다.</p><p>그래서 필자는 <code>Web Audio API</code>와 같은 생소한 API를 꽤나 단기간에 이해할 수 있었고, 이 API에서 제공해주는 오실레이터의 프로퍼티들을 조절하여 원하는 악기의 소리를 만들어 낼 수도 있었다. 이런 음악과 오디오 이론에 대한 지식은 컴퓨터 공학과 마찬가지로 하나의 전문 분야이기 때문에 반짝 공부한다고 단기간에 습득할 수 있는 것은 아니다.</p><p>많은 비전공 개발자 분들은 컴퓨터 공학에 대한 지식이 전공자보다 부족하다고 생각하기 때문에 자신이 부족한 개발자라고 생각하지만, 조금만 다르게 생각해보면 컴퓨터 공학 지식은 부족할지 몰라도 다른 분야에 대한 전문 지식을 가지고 있는, 오히려 더 특별한 능력의 소유자들이라고도 할 수 있다.</p><p>물론 지금 회사에서 맡고 있는 일이 자신의 전공과 전혀 다른 일이라면 딱히 도움은 안되겠지만, 필자는 오히려 자신의 전공을 살려서 틈새 시장을 노려볼 수도 있지 않나라는 생각을 해보게 된다.</p><h3 id="그래도-컴퓨터-기초-지식은-중요하다"><a href="#그래도-컴퓨터-기초-지식은-중요하다" class="headerlink" title="그래도 컴퓨터 기초 지식은 중요하다"></a>그래도 컴퓨터 기초 지식은 중요하다</h3><p>하지만 전공이든 비전공이든 어쨌든 개발자는 개발자이고, 개발자의 기본적인 능력은 컴퓨터에 대한 이해에서부터 출발하는 것이기 때문에 이 점을 무시할 수는 없다.</p><p>필자가 위에서 이야기했듯이 컴퓨터 공학을 전공한 사람이 비전공자에 비해서 강점을 가지는 부분은 바로 <code>컴퓨터에 대한 기초 지식</code>이다. 하지만 이런 기초 지식은 당장 취업에 도움이 되는 게 아니기 때문에 학원에서는 비중있게 가르쳐 주지 않고, 이론의 비중 또한 높기 때문에 독학으로 하기엔 너무 재미가 없다.</p><p>그러나 필자는 개인적으로 다른 건 몰라도 <code>자료구조</code>, <code>알고리즘</code>, <code>네트워크</code> 이 3개는 왠만하면 공부를 하는 것이 좋다고 생각한다. 이 3가지 과목은 실무에서 알게 모르게 도움이 많이 된다.</p><h4 id="자료구조"><a href="#자료구조" class="headerlink" title="자료구조"></a>자료구조</h4><p>예를 들어 어떤 상품들의 정보를 서버로부터 받아와서 클라이언트에 저장해야하는 상황이라고 생각해보자. 이때 각각의 상품들은 정수 자료형으로 표현되는 <code>ID</code> 값을 가지고 있다.</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="hljs-attr">"goods"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="hljs-attr">"id"</span>: <span class="hljs-number">1</span>,</span><br><span class="line">      <span class="hljs-attr">"name"</span>: <span class="hljs-string">"맥북프로"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="hljs-attr">"id"</span>: <span class="hljs-number">22</span>,</span><br><span class="line">      <span class="hljs-attr">"name"</span>: <span class="hljs-string">"청바지"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="hljs-attr">"id"</span>: <span class="hljs-number">100</span>,</span><br><span class="line">      <span class="hljs-attr">"name"</span>: <span class="hljs-string">"말린 오징어"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자, 서버로부터 응답이 이렇게 내려온다고 생각해보자. 이때 우리는 이 데이터를 어떻게 가공하고 저장할 것인지 선택해야한다. 지금 필자는 대충 3가지 정도를 떠올렸다.</p><blockquote><ol><li>그냥 저대로 배열 안에 담아 놓고 쓴다.</li><li>상품 ID를 인덱스로 사용해서 새로운 배열에 담는다.</li><li>맵을 사용한다.</li></ol></blockquote><p>이 중에서 각 방법이 어떤 장점이 있고 어떤 단점이 있을까? 1번 방법은 서버에서 내려준 응답 상태의 구조를 그대로 사용하기 때문에 추가적인 이터레이션을 돌지 않아도 된다. 대신 어떤 특정 상품에 접근하고 싶다면 매번 배열을 탐색해야하기 때문에 <code>O(n)</code>의 시간 복잡도가 소요될 것이다.</p><p>2번 방법은 어떨까? 이 방법은 상품의 ID를 배열의 인덱스로 사용하기 때문에 값에 대한 접근을 <code>O(1)</code>만에 할 수 있다고 생각할 수 있지만, JavaScript에서는 아니다. 이 경우 배열에 들어가는 원소는 <code>Object</code> 자료형이므로 원시 자료형처럼 원소들이 동일한 자료형으로 평가되지 않는다. 결국 저 배열은 <code>리스트</code>로 생성될 것이고, 리스트는 특정 원소에 접근하기 위해 <code>Head</code>부터 차례대로 탐색해야하므로 접근 시간은 결국 <code>O(n)</code>이다.</p><p>이에 대한 자세한 내용은 <a href="/2019/06/15/diving-into-js-array/" title="JavaScript 배열(Array)의 발전과 성능에 대해서 자세히 알아보기">JavaScript 배열(Array)의 발전과 성능에 대해서 자세히 알아보기</a> 포스팅을 참고하자.</p><p>게다가 저 배열이 리스트가 아니라 실제 배열이라고 하더라도 문제는 여전히 존재한다. 상품의 ID는 대부분 데이터베이스에서 사용하는 <code>Primary Key</code>일 것이기 때문에 새로운 상품이 데이터베이스에 추가될수록 할당되는 ID의 값도 점점 증가할 것이다. 그러면 메모리에 할당해야하는 배열의 길이도 점점 길어질 것이라는 사실을 예상 해볼 수 있다.<small>(배열은 메모리에 연속적으로 할당된다)</small></p><p>그래서 이런 경우라면 필자는 3번 방법을 사용할 것 같다. ID는 상품을 구분하는 고유한 값이기 때문에 중복될 가능성이 없다고 봐도 무방하다. 즉 그냥 맵에다가 데이터를 막 때려박아도 충돌이 날 가능성이 없다는 것이다. 맵의 특성 상 접근 자체도 <code>O(1)</code>으로 해결할 수 있고, 늘 서버로부터 받아온 상품 만큼만 메모리를 할당하면 되므로 합리적이다.</p><center><br>  <img src="/2019/09/09/major-is-not-important/array-data-structure.jpg" width="500"><br>  <small>배열에 대한 이해가 없다면 잘못된 선택을 할 수도 있다</small><br>  <br><br></center><p>지금 이 예시는 굉장히 간단한 예시지만 실무에서 충분히 자주 접하는 상황이다. 기본적으로 <code>배열이라는 자료구조가 메모리에 어떻게 할당되는지</code>, <code>배열과 맵의 장단점이 무엇인지</code>, <code>이 자료구조에서 값에 어떻게 접근하는지</code>와 같은 <code>자료구조</code>에 대한 기본적인 지식이 없다면 저 3가지 보기 중에 현재 상황에 적합한 답을 찾기 힘들 것이다.</p><h4 id="알고리즘"><a href="#알고리즘" class="headerlink" title="알고리즘"></a>알고리즘</h4><p><code>알고리즘</code>의 경우에는 <code>하노이의 탑</code>같은 문제를 푸는 방법을 외우라는 것이 절대 아니다. 알고리즘은 단순히 어떤 문제를 풀기 위한 방법을 외우는 것이 아니라 어떤 문제를 <code>효율적으로 풀기 위한 방법</code>을 찾는 것이다. 주어진 행렬 안에서 가장 큰 정사각형을 찾는 문제를 푸는 것이 중요한 게 아니라, 내가 삼중 <code>for</code>문으로 작성한 코드에서 어떻게 하면 <code>for</code>문을 하나라도 줄일 수 있을 지를 고민하는 것이 중요한 것이다.</p><p>최소한 자신이 작성한 코드가 어느 정도의 시간 복잡도를 가졌는지는 계산할 수 있어야 한다. 필자가 방금 위의 예시에서 배열의 요소에 접근하는데 소요되는 시간복잡도와 리스트의 요소에 접근하는데 소요되는 시간복잡도를 계산한 것도 알고리즘의 범주 안에 속한다.</p><p>또한 알고리즘은 굉장히 넓고 방대한 분야이기 때문에, 어떤 것부터 시작해야 하는지 감이 오지 않을 수도 있다. 그럴 때는 정렬과 탐색부터 한번 도전해보는 것을 추천한다. 기본적인 정렬 알고리즘인 <code>Bubble</code>, <code>Merge</code>, <code>Quick</code> 같은 알고리즘이나 탐색 알고리즘인 <code>Binary Search</code>와 같은 알고리즘은 꽤 직관적이기 때문에 이해하기도 그렇게 어렵지 않다.</p><p>또한 이런 알고리즘을 공부하다보면 자연스럽게 자료구조와도 엮이기 때문에 자료구조와 알고리즘을 함께 공부하는 것을 추천한다. 프로그래머스와 같은 알고리즘 문제 사이트에서 문제를 푸는 것도 물론 재밌고 좋지만, 이런 문제는 기초라기보다 응용 문제에 가깝기 때문에 기초적인 개념을 먼저 잡고나서 도전하는 것을 추천한다.</p><p>그리고 이런 사이트들은 다른 사람들이 이 문제를 어떻게 풀었는지 볼 수 있는 기능을 제공하는 경우가 많은데, 많은 분들이 극단적으로 코드 라인을 줄이는 것에 초점을 맞추고 있는 것 같아서 그런 코드를 보고 공부하는 것을 딱히 추천하고 싶지는 않다. 아마 그런 사이트에서 그렇게 코드 라인을 줄여서 작성하시는 분들도 실무에서까지 그렇게 작성하시진 않을 것이다.</p><h4 id="네트워크"><a href="#네트워크" class="headerlink" title="네트워크"></a>네트워크</h4><p><code>네트워크</code>의 경우, 웹이나 앱 개발자인 이상 대부분 클라이언트와 서버가 통신하는 기능을 만질 수 밖에 없다. 특히 웹의 경우는 네트워크 위에서 개발하는 것이라고 봐도 무방할 정도로 네트워크와 밀접한 관련이 있기 때문에 네트워크에 대한 기본적인 지식은 필수다. 또한 웹 어플리케이션을 개발하다보면 네트워크와 관련된 다양한 문제들이 발생하는데, 네트워크에 대한 기본적인 지식이 없다면 해결하기 힘든 경우가 많다.</p><p>아마 프론트엔드 개발자가 겪는 대표적인 네트워크 이슈로는 <code>CORS(Cross-Origin Resource Sharing)</code> 위반을 예로 들 수 있을 것 같다. 이 이슈는 <code>a.com</code>이 <code>b.com</code>처럼 서로 다른 오리진을 가진 곳으로 리소스를 요청하는 경우 보안을 침해할 가능성이 있기 때문에 브라우저가 서버의 응답을 무시해버리는 이슈다.</p><p>클라이언트는 본 요청을 서버로 보내기 전에 <code>Preflight</code>라는 예비 요청에 사용하고 싶은 커스텀 헤더와 메소드 등을 담아서 미리 보내게 되는데 이때 서버가 이 예비 요청을 받고 응답 헤더 내에 <code>Access-Control-Allow-Origin</code>라는 키를 사용하여 올바른 값을 내려주지 않는다면 CORS 위반이 되어 통신을 할 수 없는 이슈가 발생하는 것이다.</p><center><br>  <img src="/2019/09/09/major-is-not-important/cors-preflight.png" width="500"><br>  <small>CORS의 통신 과정</small><br>  <br><br></center><p>이때 이런 일련의 통신 과정과 보안에 대한 기본적인 개념이 없다면 인터넷에 많이 나와있는 해결책인 <code>Access-Control-Allow-Origin: *</code>을 운영환경에서 사용하여 서버의 보안을 망가트릴수도 있다. 게다가 이 문제를 주로 접하는 것은 프론트엔드 개발자이지만 실질적인 해결은 백엔드 쪽에서 해줘야 하기 때문에 뭐가 문제인지 모른다면 혼자 부여잡고 끙끙대다가 아예 해결을 못할 수도 있다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>필자가 이 포스팅을 작성하게 된 이유는 자신이 비전공 개발자라는 이유로 자신을 낮게 평가하는 분들 때문이었다. 필자는 부트캠프나 학원을 다녀본 적이 없기 때문에 모든 것을 공감하지는 못하지만, 부트캠프나 학원 출신 개발자 분들이 전공에 대한 선입견 때문에 답답한 감정을 느꼈다고 하는 이야기를 들으면 기분이 좋지는 않았다.</p><p>전공 여부를 가지고 뭐라고 하는 사람들도 문제지만, 본인들 스스로도 그 프레임에 갖혀서 <code>내가 비전공이라 그런가</code>라는 이야기를 하는 경우가 종종 있기에, 필자는 그럴때마다 <code>그냥 개발자는 개발자일 뿐이다</code>라고 얘기를 해주고는 한다.</p><p>사실 학원에서 6개월 동안 공부한 개발자가 학교에서 4년 동안 공부한 개발자에 비해 컴퓨터에 대한 기초 지식이 모자른 것은 어찌보면 당연하다. 그러나 어떠한 개발자에 대한 평가는 컴퓨터에 대한 지식만으로 평가되는 것이 아니라는 사실을 잊지 않았으면 좋겠다.</p><p>그리고 포스팅의 주제 상 어쩔 수 없이 <code>전공</code>과 <code>비전공</code>이라는 단어를 많이 사용했지만, 개발에 있어서 전공자냐 비전공자냐는 절대 중요한 게 아니다. 그냥 개발자는 개발자일 뿐이고 컴퓨터 이론에 특화된 개발자와 다른 분야의 지식도 함께 섭렵한 개발자처럼 각 개발자마다의 특징만 있을 뿐이다.</p><p>만약에 누군가가 여러분에게 <code>컴공 출신 개발자는 역시 잘하네</code>, <code>역시 비전공자 출신은 안돼</code> 같은 말을 한다면 그건 그 사람의 마인드 셋이 잘못된 것이지, 여러분이 잘못된 것이 아니다. 하지만 위에서 설명한대로 4년 동안 컴퓨터 공학 공부를 하고 졸업한 사람들에 비교했을 때, 그렇지 않은 사람들이 컴퓨터에 대한 기초 지식이 부족한 것은 사실이기에 기초에 대한 공부는 꾸준히 하는 것이 좋을 것 같다는 생각이 든다.</p><p>IT 시장의 스펙트럼은 굉장히 넓고, 각 분야에서 요구되는 개발자들의 스펙도 그만큼 다양하다. 그 말인 즉슨, 전공 여부와 상관없이 여러분이 가진 능력들을 잘 조합해서 자신만의 무기로 만들면 시장에서 충분히 경쟁력을 가질 수 있다는 소리다. 꾸준히 공부하고 재밌게 코딩하다보면 일은 알아서 잘 풀릴 거라고 생각하자.</p><p>이상으로 비전공 개발자가 전공자보다 정말 불리할까? 포스팅을 마친다.</p>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/09/09/major-is-not-important/#disqus_thread</comments>
    </item>
    
    <item>
      <title>프라하에서 디지털 노마드로 살아남기</title>
      <link>https://evan-moon.github.io/2019/09/06/life-in-prague-tip/</link>
      <guid>https://evan-moon.github.io/2019/09/06/life-in-prague-tip/</guid>
      <pubDate>Thu, 05 Sep 2019 22:30:23 GMT</pubDate>
      <description>
      
        &lt;p&gt;필자는 지난 9월 1일에 체코 프라하에 도착해서 휴가를 보내고 있는 중이다. 근데 마냥 휴가라고 하기에는 뭐한게, 전 직장과 프리랜서 계약을 했기 때문에 여기서도 결국 코딩을 하고 있기 때문이다. 나름 디지털 노마드 흉내를 내고 있는 셈이다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>필자는 지난 9월 1일에 체코 프라하에 도착해서 휴가를 보내고 있는 중이다. 근데 마냥 휴가라고 하기에는 뭐한게, 전 직장과 프리랜서 계약을 했기 때문에 여기서도 결국 코딩을 하고 있기 때문이다. 나름 디지털 노마드 흉내를 내고 있는 셈이다.</p><a id="more"></a><p>체코는 유럽치고 물가가 저렴한 편이고 인터넷도 빠른 편이기 때문에 전 세계의 많은 개발자들이 디지털 노마딩을 하러 온다고 한다. 독자분들 중에서 혹시라도 나중에 필자처럼 프라하에서 한 달 정도 살아보고 싶으신 분들이 있을 것 같아서 이번 포스팅에서는 필자가 잠깐 동안 지내면서 느낀 프라하의 모습들과 몇가지 팁을 적어보려고 한다.</p><p>필자는 여행 블로거도 아니고 프라하에 관광을 목적으로 왔다기 보다 한번 살아보고 싶어서 온 것이기 때문에 다른 여행 블로그처럼 관광지에 대한 이야기를 하기보다는 그냥 생활에 관련된 이야기를 주로 하려고 한다.</p><h2 id="프라하에-대한-간단한-설명"><a href="#프라하에-대한-간단한-설명" class="headerlink" title="프라하에 대한 간단한 설명"></a>프라하에 대한 간단한 설명</h2><p>다들 아시겠지만 프라하는 중유럽에 위치한 체코 공화국의 수도이다. 체코는 2차 세계대전 때 독일군이 침공했을 당시 나치와 싸우지 않고 일찍 항복했기 때문에 다른 국가의 도시와 다르게 문화유산들이 파괴되지 않고 많이 남아있는 편이다. 그래서 프라하는 현대적인 모습보다는 예전 중세 유럽의 모습이 아직 많이 남아있는 도시 중 하나이다. 프라하의 올드 스퀘어가 있는 구 시가지는 유네스코 세계유산으로 지정되어 있을 만큼 역사가 깊다.</p><center><br>  <img src="/2019/09/06/life-in-prague-tip/prague1.jpg" width="500"><br>  <small>카를교 쪽은 진짜 옛날 건물들 밖에 없다</small><br>  <br><br></center><p>화폐 단위는 유로가 아닌 <code>코루나(Kč)</code>를 사용하며 환율은 대략 1코루나에 <code>50~53</code>원 정도로 왔다갔다 한다. 필자는 현지에서 <code>200코루나 == 10,000원</code> 정도로 생각하고 생활하고 있다. 그리고 유럽치고는 물가가 싼 편이기 때문에 그냥저냥 생활비는 한국이랑 비슷하게 나가는 수준이다.</p><p>단, 유럽이다 보니 한국과 시차가 7시간이라 필자처럼 한국에서 일을 받아서 가지고 온 사람은 커뮤니케이션을 위해 아침에 조금 일찍 일어나야 할 수도 있다.<small>(참고로 프라하는 UTC +02:00이다)</small></p><p>필자도 처음에는 시차 때문에 저절로 눈이 일찍 떠지긴 했는데, 한 3일 정도 지난 후부터는 다시 한국에서의 생활 패턴으로 돌아가고 있어서 점점 일찍 일어나기 힘들어지고 있다.</p><p>그리고 언어는 슬라브어 계통인 <code>체코어</code>를 사용한다. 체코어는 영어와 비슷한 부분도 있지만 다른 부분이 더 많기 때문에 따로 공부를 안하면 알아듣기나 읽기는 힘들다. 필자는 체코어를 제대로 공부할 것도 아니고 공부할 시간도 없었기 때문에 그냥 아무 생각없이 왔다. 그래도 이왕 체코에 왔으면 체코어를 써보고 싶기도 해서 필자는 간단한 몇 가지 문장만 외운 후 열심히 조합해서 사용 중이다.</p><p>한가지 꿀팁을 주자면 제일 먼저 <code>감사합니다(Děkuji)</code>나 <code>안녕하세요(Dobrý den)</code>와 같은 기본적인 말부터 외우고 나면, 그 다음으로 반드시 <code>못 알아듣겠어요(Nerozumím)</code>, <code>영어하실 수 있어요?(Mluvíte anglicky?)</code>라는 말을 외우자. 이러면 현지어를 사용함으로써 현지인에게 좋은 첫인상도 주고 영어로 도움도 받을 수 있다. 어느 나라를 가던 똑같겠지만, 서툴더라도 자국어를 사용하려고 하는 외국인을 나쁘게 보는 사람은 없다.<small>(마트에서 뎨꾸이했다가 지나가던 할아버지한테 칭찬받은 1인)</small></p><p>그럼 이제 필자가 며칠 동안 지내며 겪었던 내용들을 몇가지 이야기 해보도록 하겠다.</p><h2 id="맥북-프로-레티나-기내-반입에-대해서"><a href="#맥북-프로-레티나-기내-반입에-대해서" class="headerlink" title="맥북 프로 레티나 기내 반입에 대해서"></a>맥북 프로 레티나 기내 반입에 대해서</h2><p>이건 필자도 출발하기 하루 전에 알게 된 것이라 조금 당황했던 항목인데, 딱히 프라하에만 관련된 내용은 아니지만 혹시나 모르시는 분들이 계실까봐 이야기 하도록 하겠다.</p><p><code>2015년</code>에서 <code>2017년</code> 사이에 제조된 맥북 프로 레티나 중 일부 제품이 배터리 불량으로 인해 폭발 사고가 몇 번 발생했다. 그래서 2019년 8월부터 EU 회원국의 항공사에서 운행하는 비행기를 탈 때 위탁 수하물로는 맥프레를 운송할 수 없고 무조건 기내 수하물로 가지고 타야한다. 그리고 기내에서 절대 전원도 키면 안된다.</p><p>EU가 아닌 다른 국가의 경우는 아예 비행기에 맥프레를 반입하지 못하게 금지시킨 항공사도 있으니 잘 알아보고 타도록 하자. 필자같은 경우는 EU로 왔기 때문에 가지고 올 수는 있었지만 다시 귀국할 때 규정이 어떻게 변경될 지 모르기 때문에 안전한 2009년형 맥북 프로를 데려왔다.</p><p>필자가 체코항공에 직접 문의해본 결과, 기내에서 전원만 안키면 괜찮다는 답신을 받기는 했으나 나중에는 상황이 어떻게 바뀔지 모른다. 탑승객의 생명과 직결되는 항공사 안전 규정의 특성 상, 맥프레 배터리 폭발 사고가 한두번만 더 발생해도 유예 기간없이 해당 규정이 변경될 수도 있다.</p><p>게다가 한국에서 반입 금지당하면 택배로 집에 보낼수라도 있지만 체코에서 귀국할 때 반입 금지당하면 처리가 곤란해지기 때문에 필자는 그냥 조금 답답하더라도 2009년형 맥북을 가져오는 것을 선택했다.</p><p>자세한 내용은 <a href="https://www.ytn.co.kr/_ln/0104_201908141632359132" rel="external nofollow noopener noreferrer" target="_blank">관련 기사</a>를 참고하자.</p><h2 id="물가가-싸다"><a href="#물가가-싸다" class="headerlink" title="물가가 싸다?"></a>물가가 싸다?</h2><p>필자가 프라하에 오기 전에 사전조사를 하면서 알게된 사실은, 체코가 생각보다 물가가 싸다는 것이다. 물론 이 싸다는 것이 유럽치고 싸다는 것이지 한국에 비해서 엄청 싸거나 그렇다는 의미는 아니다. 그래도 한국보다 전체적으로 물가가 싼 느낌이 있긴 하다.</p><p>하지만 해외 물가라는 것이 어떤 특정 아이템은 한국보다 쌀 수도 있지만 다른 아이템은 또 비쌀 수도 있는 것이라서 막상 며칠 살아보니 한국과 그렇게 큰 차이는 못 느꼈다. 확실히 식재료 같은 것은 한국에 비해 싸지만 멀티탭 같은 전기 제품은 한국보다 훨씬 비쌌다.<small>(멀티탭 하나에 만원이 넘는다…)</small></p><p>필자 같은 경우는 요리를 잘하는 편이 아니기 때문에 주로 밖에서 사먹거나 마트에서 즉석식품을 사와서 먹는 편인데, 이 경우에는 한국과 거의 비슷한 금액이 지출된다. 뭐 맥도날드에서 햄버거 사먹으면 <code>5,000원</code> 정도, 길거리에서 샌드위치 하나 사먹으면 <code>3,000원</code> 정도 이런 느낌이다.</p><p>그리고 필자가 출발하기 전에 친구가 <code>유럽은 물이 엄청 비싸다</code>라고 해서 겁먹었는데, 테스코에서 사면 1.5L짜리 생수병 1통이 <code>600원</code>정도 밖에 안하더라.</p><p>참고로 생수는 파란색 포장지에 <code>Neperlivá Voda</code>라고 적혀있다. <code>Ne</code>는 아니라는 뜻이고 <code>perlivá</code>는 스파클링, <code>Voda</code>는 물이다. 즉, <code>Neperlivá Voda</code>는 탄산수 아닌 물이라는 뜻이다. 탄산수를 별로 안 좋아하시는 분들은 참고하도록 하자.</p><p>한국에 비해서 확실히 싸다고 느낀 건 바로 교통비인데, 한 달 교통비로 <code>35,000원</code> 정도만 지불하면 대중 교통을 무제한으로 이용할 수 있다. 한국에서 필자는 한 달에 교통비로만 거의 <code>70,000원</code> 가까이 지출하기 때문에 확실히 교통비는 한국에 비해서 싸다고 할 수 있다.</p><h2 id="생각보다-영어가-잘-안통한다"><a href="#생각보다-영어가-잘-안통한다" class="headerlink" title="생각보다 영어가 잘 안통한다"></a>생각보다 영어가 잘 안통한다</h2><p>사실 필자는 프라하가 유명한 관광지이기 때문에 사람들이 영어를 다 잘할 것이라고 생각했다. 하지만 관광객들이 주로 다니는 프라하 성이나 카를교, 올드 스퀘어 쪽을 제외한 지역은 생각보다 영어가 잘 안통한다.</p><p>물론 일본이나 중국같은 아시아 국가처럼 아예 못 알아듣는 정도는 아니지만 너무 빨리 이야기하거나 너무 복잡한 어휘를 사용하면 잘 못 알아듣는다. 그리고 아무래도 나이가 어린 사람들 보다는 나이가 조금 있으신 분들 일수록 더 영어를 못하신다.</p><p>그리고 이건 우리나라도 비슷하지만 테스코와 같은 대형마트에 가면 제품명이라던가 코너 간판이 전부 체코어로만 적혀있기 때문에 조금 헤멜 수 있다. 필자는 도착한 첫날에 <code>Mléko</code>라고 적혀있길래 우유인줄 알고 샀는데 알고보니 요거트 밀크였다.<small>(시리얼에 붓고 나서 알았다)</small></p><p>필자처럼 오랜 기간 동안 머문다면 체코에 오기 전 기본적인 단어나 파닉스 정도는 공부를 해서 오면 도움이 될 것 같다. 필자는 영어만 믿고 왔다가 꽤나 고생 중이다.</p><h2 id="대중-교통타고-다니기"><a href="#대중-교통타고-다니기" class="headerlink" title="대중 교통타고 다니기"></a>대중 교통타고 다니기</h2><p>프라하의 대중 교통은 버스, 트램, 지하철이 있다. 필자는 개인적으로 버스보다는 트램이나 지하철이 더 편한 것 같다. 여기서는 교통권을 사용하거나 한국의 T머니와 같은 라테츠카 카드를 사용해서 대중교통을 이용할 수 있는데, 라테츠카 카드는 시청까지 가서 발급 받아야 하고 여권 사진도 제출해야 해서 귀찮다. 그래서 필자는 그냥 한 달 교통권을 구매해서 사용 중 이다.</p><h3 id="교통권이-시간제로-운영된다"><a href="#교통권이-시간제로-운영된다" class="headerlink" title="교통권이 시간제로 운영된다"></a>교통권이 시간제로 운영된다</h3><p>프라하의 교통권은 우리나라처럼 거리비례제가 아니라 시간제이다. 티켓을 구매한 이후에 펀칭 기계라고 부르는 요상한 기계에 교통권을 넣고 사용 시작 시간을 찍는다. 즉, <code>90분 이용권</code>을 구매했다면 사용 시작 시간이 찍힌 이후로부터 <code>90분</code> 동안은 트램을 타던 지하철을 타던 뭘 타던 환승도 자유다.</p><p>하지만 시간이 지나버렸는데 내 몸뚱아리가 아직 대중교통 안에 있고 게다가 검표원한테 걸렸다면 얄짤없이 벌금행이다. 참고로 무임승차 벌금은 무조건 현금으로 내야하는데, 현장에서 바로 내면 <code>800Kč</code>이고 당장 현금이 없어서 ATM에서 뽑아서 내야한다면 <code>1,500Kč</code>이다.</p><p>블로그 후기를 봐도 이 티켓 펀칭을 안해서 벌금냈다는 사람들이 꽤 많았다. 근데 필자도 막상 트램이나 지하철을 타보고 나니까 그런 실수를 할만 하다고 생각하긴 했다.</p><center><br>  <img src="/2019/09/06/life-in-prague-tip/metro.jpg" width="500"><br>  <small>그냥 저 기둥 사이로 들어가면 된다</small><br>  <br><br></center><p>처음 프라하에 왔을 때 당황했던 것 중에 하나가 대중교통을 이용할 때 표를 검사하는 기계적인 시스템 자체가 없다는 것이였다. 우리나라는 카드를 찍거나 교통권을 넣는 개찰구가 칸막이로 막혀있고 인증이 되면 들여보내주는 방식인데, 여기는 그런 게 없이 그냥 뻥 뚫려있다. 트램도 마찬가지다.</p><p>위 사진에 보이는 저 노란색 장치가 바로 아까 말한 <code>티켓 펀칭 기계</code>이다. 지하철에 들어갈 때 반드시 저 기계에 교통권을 넣고 반드시 <code>티켓 사용 시작 시간</code>을 찍어야 한다. 트램이나 버스같은 경우에도 그냥 트램이나 버스가 오면 탄 다음에 차량 내부에 있는 펀칭 기계에 사용 시작 시간을 찍으면 된다.</p><p>근데 솔직히 티켓 펀칭을 안하고 탄다고 해서 우리나라처럼 무슨 경고음이 울리고 하는 것도 아니기 때문에 정신놓고 타다가는 까먹기 딱 좋은 것 같다.</p><h3 id="교통권의-종류"><a href="#교통권의-종류" class="headerlink" title="교통권의 종류"></a>교통권의 종류</h3><p>프라하의 교통권은 총 4개 종류가 있고 가격과 사용 시간은 다음과 같다.</p><table><thead><tr><th>사용가능시간</th><th>가격</th></tr></thead><tbody><tr><td>30분</td><td>24Kč</td></tr><tr><td>90분</td><td>32Kč</td></tr><tr><td>1일</td><td>110Kč</td></tr><tr><td>3일</td><td>310Kč</td></tr></tbody></table><p>필자같은 경우 집에서 한 달 교통권을 팔고 있는 프라하 중앙역까지 가기 위해 교통권을 구매해야했는데, 트램타고 25분 정도의 거리였지만 그냥 90분 짜리를 끊었다. 뭐 중간에 어떤 변수가 생길지 모르기 때문에 나름 방어한다고 그렇게 한 것인데, 그냥 딱 맞춰서 사도 상관없었을 것 같다.</p><center><br>  <img src="/2019/09/06/life-in-prague-tip/32ticket.jpg" width="200"><br>  <small>하단에 화살표처럼 되어있는 부분을 펀칭 기계에 넣으면 시작 시간이 찍힌다</small><br>  <br><br></center><h3 id="교통권은-어디서-구매하나요"><a href="#교통권은-어디서-구매하나요" class="headerlink" title="교통권은 어디서 구매하나요?"></a>교통권은 어디서 구매하나요?</h3><p>자, 그럼 교통권은 어디서 살 수 있을까? 뭐 뻔한 이야기이지만 당연히 대중교통을 탈 수 있는 곳 근처에서 살 수 있다.</p><p>교통권은 지하철역에서 팔거나 정류장 근처의 슈퍼에서 살 수 있다. 지하철역 같은 경우는 역에 들어가면 왠지 티켓 판매기가 있어야할 것 같은 위치에 티켓 판매기같이 생긴 게 떡하니 들어가 있기 때문에 그냥 마음이 시키는 대로 가서 돈 넣고 표를 뽑으면 된다. 현대인이라면 누구든지 할 수 있는 난이도니까 걱정하지말자.</p><center><br>  <img src="/2019/09/06/life-in-prague-tip/ticket-machine.jpg" width="500"><br>  <small>대놓고 Tickets라고 적혀있으니 못 찾을 걱정은 안해도 된다</small><br>  <br><br></center><p>정류장 근처의 슈퍼에서 교통권을 사야하는 경우에는 조금 난이도가 있다고 생각이 드는게, 이 동네는 간판에 영어가 잘 안적혀있다. 대부분 체코어로 적혀있는 데다가 처음 오는 타지에서 다 비슷비슷하게 생긴 유럽식 건물들을 하나하나 흝어보면서 슈퍼를 찾는다는 건 생각보다 힘든 일이다. 그래서 필자는 될 수 있으면 그냥 근처 지하철역에서 사는 걸 추천한다.</p><h3 id="한-달-교통권-구매하기"><a href="#한-달-교통권-구매하기" class="headerlink" title="한 달 교통권 구매하기"></a>한 달 교통권 구매하기</h3><p>대부분의 경우에는 프라하에 2~3일 정도 머물다 다른 도시나 다른 나라로 떠나기 때문에 위에서 설명한 교통권만으로도 충분하겠지만 필자처럼 길게 머무는 사람은 매일 저 티켓을 사는 게 여간 귀찮은 일이 아니다.</p><p>보통 필자처럼 오래 머무는 사람들은 <code>한 달 교통권</code>을 구매하거나 <code>라테츠카 카드</code>를 등록해서 사용하는데, 라테츠카는 시청까지 가서 발급받아야하고 여권 사진도 제출해야해서 좀 귀찮다. 그래서 필자는 그냥 프라하 중앙역에 가서 한 달 교통권을 구매했다.</p><p>블로그를 뒤져가며 알아본 정보로는 <code>어느 정도 규모가 있는 역</code>에서는 다 판다고 하는데 <code>어느 정도</code>가 진짜 얼마나 큰 역을 의미하는 지 애매하기 때문에 그냥 프라하 구 시가지 구경도 할겸 프라하 중앙역으로 갔다.</p><center><br>  <img src="/2019/09/06/life-in-prague-tip/dpp_booth.jpg" width="500"><br>  <small>이렇게 생긴 인포메이션 센터에서 한 달 교통권을 판매한다</small><br>  <br><br></center><p>한 달 교통권의 가격은 <code>670Kč</code>이고 다른 교통권과 다르게 따로 펀칭은 필요없다. 검표원이 검사할 때 그냥 보여주기만 하면 된다. 한 달 교통권을 구매할 때 판매하시는 분이 교통권을 언제부터 이용할 것인지 물어보는데 그냥 <code>I&#39;m gonna use it right now</code>라고 하면 바로 날짜랑 시간을 찍어준다.</p><center><br>  <img src="/2019/09/06/life-in-prague-tip/monthly-ticket.jpg" width="500"><br>  <small>한 달 교통권은 이렇게 생겼다</small><br>  <br><br></center><p>그리고 대중 교통 외에도 한국의 킥고잉같은 <code>Lime</code>이라는 서비스가 있어서 전동 킥보드를 타고 다닐 수도 있다. 사용법은 한국과 동일하게 앱을 설치하고 결제 수단을 등록한 후 킥보드에 있는 QR 코드를 스캔하는 방식이다. 이 Lime이라는 회사는 체코 회사는 아니고 미국 회사인데 아시아 지역을 제외한 다른 지역에서는 많이 사용하는 서비스라고 한다.</p><h2 id="현지-통신사-유심"><a href="#현지-통신사-유심" class="headerlink" title="현지 통신사 유심"></a>현지 통신사 유심</h2><p>필자는 보통 단기로 여행을 가면 그냥 국내 통신사 로밍을 하는 편인데 이번에는 한 달이나 있어야 하는 만큼 로밍을 하면 요금 폭탄을 맞을게 뻔했기 때문에 유심을 구매해서 사용해야 했다.</p><h3 id="유심-구매하기"><a href="#유심-구매하기" class="headerlink" title="유심 구매하기"></a>유심 구매하기</h3><p>유심 구매는 공항에서 해도 되고 시내에서 휴대폰 매장을 직접 찾아가도 된다. 우리나라에 SKT, KT, LGT라는 거대 통신사들이 있듯이 체코에는 <code>T-Mobile</code>, <code>Vodafone</code>, <code>O2</code>라는 3개의 거대 통신사가 있다.</p><p>필자는 이 중 필자에게 익숙한 <code>Vodafone</code>에서 유심을 구매했다. 이 통신사는 다국적 통신사라 중국이나 홍콩에서 사용 했던 적이 있어서 선택한 것이다. 사실 Vodafone이 통신 커버리지가 안좋다고 소문이 자자하긴 한데, 필자 경험상 상하이나 홍콩같은 대도시에서는 딱히 문제가 없었기 때문에 프라하도 마찬가지일 것이라고 생각했고, 실제로도 그냥저냥 잘 된다.</p><center><br>  <img src="/2019/09/06/life-in-prague-tip/vodafone.jpg" width="500"><br>  <small>300미터 밖에서도 눈에 띄는 존재감을 뽐내는 Vodafone 매장</small><br>  <br><br></center><p>Vodafone 매장은 우리나라의 KT 마냥 뻘건색으로 도배가 되어있기 때문에 어디서든 쉽게 눈에 띈다. 매장을 발견했다면 그냥 매장에 들어가서 놀고 있는 직원에게 <code>I&#39;d like to buy prepaid sim card</code>라고 하면 다 알아서 해준다.<small>(거의 한국만 유심이라고 부르고 다른 나라는 대부분 심카드라고 한다.)</small></p><p>이때 직원이 필자에게 3가지 정도를 물어봤는데, <code>며칠 동안 사용할 것인지</code>와 <code>데이터 사용만을 원하는지</code>, <code>몇 GB의 데이터를 원하는지</code>였다. 필자는 사실 한국에서 <code>500MB</code>짜리 초저렴 요금제를 사용하고 있기 때문에 한 달에 얼마 정도의 데이터가 적당한지 잘 몰랐다. 그래서 고민하느라 잠깐 멍때리고 있으니 바로 <code>10GB</code>를 추천하길래, 됐고 그냥 <code>4GB</code>만 달라고 했다.</p><p>데이터 <code>4GB</code>짜리 심카드의 가격은 <code>500Kč</code>으로 한화로 대략 <code>26,000원</code>정도이다. 한국에서 이런 식으로 유심을 구매해본 경험이 없기 때문에 적당한 가격인지는 잘 모르겠지만 가격 자체만 보면 그렇게 부담스럽지 않았다.</p><p>나중에 블로그를 조금 찾아보니 아시안처럼 딱 봐도 외국인처럼 보이는 경우 속사포처럼 영어를 쏟아내며 바가지를 씌우는 경우도 있다고 하니 필자처럼 아무 생각없이 매장에 찾아가는 것보다는 미리 어느 정도의 데이터가 필요한지 생각해놓고 가는 것이 좋을 것 같다.</p><h3 id="유심-등록하기"><a href="#유심-등록하기" class="headerlink" title="유심 등록하기"></a>유심 등록하기</h3><p>통신사에서 유심을 구매할 때 통신사에서 개통까지 한번에 알아서 해주기 때문에 활성화만 시키면 바로 사용할 수 있는 상태가 된다. 개통에 별다른 문서 작성은 필요없고 그냥 유심받아서 바로 사용하면 된다.</p><center><br>  <img src="/2019/09/06/life-in-prague-tip/simcard.jpg" width="500"><br>  <small>뒷면에 휴대폰 번호와 핀 번호가 적혀있다</small><br>  <br><br></center><p>유심 케이스의 뒷면에는 발급받은 유심에 대한 정보를 적어주는데, <code>Telefonní číslo</code>는 발급받은 휴대폰 번호를 의미하고 <code>Poznámka</code>는 핀 번호를 의미한다. 이때 발급받은 유심에는 락이 걸려있기 때문에 휴대폰을 껐다 킬때마다 이 핀 번호를 입력해줘야한다. 보다폰은 그냥 <code>1234</code>를 사용하지만 다른 통신사는 유심 구매시 동봉되어있는 카드를 긁으면 핀 번호가 노출되도록 되어있다.</p><center><br>  <img src="/2019/09/06/life-in-prague-tip/europe_number.jpg" width="500"><br>  <small>참고로 이 동네는 1하고 7을 이런 식으로 쓰는 사람이 많으니 헷갈리지 말자</small><br>  <br><br></center><p>이렇게 유심을 구매해서 휴대폰에 끼우고 나면 개통은 되었지만 활성화가 되지않은 상태가 된다. 통신사는 잡혀서 상태표시바에 <code>Vodafone CZ LTE</code>라는 글자는 보이지만 실제 인터넷 연결은 막혀있는 상태이다.</p><p>유심 케이스에 유심을 활성화시킬 수 있는 방법이 적혀있기 때문에 잘 보고 따라하면 된다…라고 하기엔 좀 애매한 것이, 이 방법이 체코어로 적혀있다. 만약 와이파이를 사용할 수 있는 환경이라면 그냥 번역기에 돌리면 되지만 와이파이를 쓰지 못하는 환경인 경우에는 그냥 통신사 직원한테 도와달라고 하자. 필자는 당연히 영어로 되어 있을 줄 알고 패기있게 그냥 나왔다가 길 한복판에서 지나가는 사람 붙잡고 도와달라고 했다.</p><p>어쨌든 Vodafone의 유심 활성화 방법은 다음과 같다.</p><blockquote><ol><li>유심이 개통되면 Vodafone에서 형식적인 개통 축하 문자와 함께 비밀번호를 보내준다.</li><li><code>*77</code>에 전화를 건다. 체코어가 나와도 당황하지말자. <code>*</code>을 누르면 영어로 진행할 수 있다.</li><li>1번에서 확인한 비밀번호를 입력한다.</li><li>요금과 관세에 해당하는 설명을 해주는데 그냥 끊어도 된다.</li></ol></blockquote><p>문제는 이게 바로 활성화되는 게 아니고 시간이 조금 걸린다. 통신사 직원 말로는 10분이면 될 거라고 그랬는데, 필자는 3시간 조금 넘게 걸렸다. 그리고 유심이 개통되면 보내주는 문자에 현재 남은 데이터나 사용 중인 서비스를 확인할 수 있는 링크도 함께 보내주니까 문자 지우지 말자.</p><p>만약 이렇게 해도 안된다면 <code>APN</code> 세팅을 한번 확인해보자. 필자 같은 경우 저번에 일본에 갔을 때 한번 현지 통신사로 APN 세팅을 했었는데 이후 한국에 돌아와서 다시 세팅하는 과정에서 APN이 <code>lte.sktelecom.com</code>으로 설정되어 있었다. 이렇게 타 통신사의 APN이 상수로 잡혀있다면 당연히 인터넷이 되지 않으니 해당 값을 지워주자.</p><h2 id="카드-결제-시-현지-통화로-결제하자"><a href="#카드-결제-시-현지-통화로-결제하자" class="headerlink" title="카드 결제 시 현지 통화로 결제하자"></a>카드 결제 시 현지 통화로 결제하자</h2><p>필자는 지금 거의 카카오 체크카드 하나만 믿고 프라하를 돌아다니고 있다. 해외에서 카드를 사용하여 결제를 자주 해보신 분들은 알겠지만 결제할 때 <code>현지 통화 결제</code>와 <code>원화 결제</code>를 선택할 수 있다.</p><p>이때 <code>원화 결제</code>를 하게되면 당일 환율로 결제 대금이 환산되어 결제되어 우리에게 원화로 얼마가 결제되었는지 알려준다. 그래서 내가 지금 얼마를 썼는지 한 눈에 알아볼 수 있다는 장점이 있긴 하지만, 문제는 이거 해외 결제 수수료 외에도 <code>DCC 수수료</code>라는 게 추가로 붙기 때문에 수수료가 2중으로 나간다. 게다가 현지 통화를 원화로 변경할 때 적용되는 환율은 고객보다는 가맹점과 은행에 유리한 환율이 적용되기 때문에 될 수 있으면 안하는 것이 좋다.</p><p>카카오 체크카드 같은 경우에는 카카오뱅크 앱 내에서 간단하게 해외 원화결제를 차단할 수 있는 설정이 있기 때문에 해당 옵션을 켜두면 원화 결제로 인한 2중 수수료 부과를 막을 수 있다.</p><center><br>  <img src="/2019/09/06/life-in-prague-tip/kakao_dcc_blocking.jpg" width="500"><br>  <small>카드 &gt; 내 카드 &gt; 카드관리에서 간단하게 설정할 수 있다</small><br>  <br><br></center><p>근데 진짜 문제는 대부분의 매장이 카드 결제를 할 때 직원이 카드를 받아서 결제해주는 것이 아니라 고객이 직접 카드 결제기에 카드를 넣어서 결제하는 방식이라는 것이다. 우리나라도 스타벅스 같은 곳에 가면 손님이 직접 카드를 결제기에 꽂아서 결제하는 경우가 있는데, 여기는 대부분이 그런 방식을 택하고 있다.</p><p>직원이 결제해주면 그냥 <code>I&#39;ll pay in local currency</code>라고 하면 왠만큼 알아듣고 알아서 해주지만, 내가 직접 카드 결제기에 카드를 넣고 결제하는 경우에는 아무래도 이 기계를 사용해본 경험도 없고 체코어로 나오기 때문에 당황할 수 밖에 없다. </p><p>하지만 당황하지말자. 카드를 기계에 꽂아넣고 금액을 확인하는 화면이 뜨는데 자세히 보면 <code>Select currency?</code>라고 물어보고 그 밑에는 <code>CZK</code>와 <code>KRW</code>이 떠있다. 이때 빨간색의 취소 버튼을 누르면 <code>코루나</code>로 결제가 되고 초록색의 확인 버튼을 누르면 <code>원화</code>로 결제가 된다. 필자는 처음에 화면을 자세히 안보고 그냥 최종 금액 확인만 하는 건줄 알고 초록색 버튼을 눌렀었다.</p><center><br>  <img src="/2019/09/06/life-in-prague-tip/pay-machine.jpg" width="400"><br>  <small>어떤 통화로 결제할 것인지 선택할 수 있다</small><br>  <br><br></center><p>그리고 대부분 위 사진과 동일한 기계를 사용하지만 맥도날드 같이 다른 결제기를 사용하는 경우에는 가끔 체크카드 비밀번호를 입력해야 결제가 되는 경우도 있다. 이때 4자리 비밀번호를 눌러보고 안되면 뒤에 <code>00</code>을 추가로 붙혀서 6자리로 만들면 결제가 된다.<small>(방금 맥도날드에서 이것 때문에 삽질하고 왔다)</small></p><h2 id="코워킹-스페이스-알아보기"><a href="#코워킹-스페이스-알아보기" class="headerlink" title="코워킹 스페이스 알아보기"></a>코워킹 스페이스 알아보기</h2><p>필자는 프라하에 오면서 전 직장과 프리랜서 계약을 했고 이 계약은 9월 2일부터 시작이었기 때문에 프라하에 있는 동안 일을 하긴 해야한다. 다행히 집에 와이파이가 빵빵하게 잘 터지기 때문에 집에서 일을 해도 상관없긴 하지만 이왕 해외에 온 김에 다른 나라 개발자들이랑 얘기도 해볼 겸 코워킹 스페이스에 가서 작업을 하고 있다.</p><p>프라하는 은근히 다른 나라에서 디지털 노마딩을 하러 오는 사람들이 많기 때문에 나름 코워킹 스페이스가 꽤 있는 편이다. 그리고 대부분의 코워킹 스페이스는 하루 동안만 이용할 수 있는 <code>Day pass</code>를 제공하기 때문에 여러 군데를 다녀보면서 괜찮은 곳을 물색해보는 것을 추천한다.</p><p>필자는 <a href="https://www.coworker.com" rel="external nofollow noopener noreferrer" target="_blank">Coworker.com</a>에서 프라하에 있는 코워킹 스페이스를 몇 개 골라놓고 시간될 때 한번씩 가보고 있다. 일반적으로 하루 이용료는 <code>200Kč</code>에서 <code>300Kč</code> 정도 된다. 필자 생각에 카페에 비해서 코워킹 스페이스가 좋은 점은 다른 나라의 개발자들이랑 네트워킹을 할 수 있는 기회가 생긴다는 것과 물과 커피, 화장실을 공짜로 사용할 수 있다는 것이다.<small>(유럽은 화장실 돈 내고 쓴다. 게다가 동전만 받는다.)</small></p><center><br>  <img src="/2019/09/06/life-in-prague-tip/coworkers.png" width="500"><br>  <small>Coworker에서 Prague를 검색하면 많은 코워킹 스페이스들이 나온다.</small><br>  <br><br></center><p>그리고 카페에서는 화장실이나 흡연으로 인해 자리를 비울때 테이블에 짐을 놓고 가면 분실할 위험이 높지만 코워킹 스페이스는 안전한 편이다. 필자는 처음에 코워킹 스페이스도 믿을 수 없어서 짐 다 싸서 화장실에 다녀왔는데 거기 직원이 그냥 놓고 가도 된다고 해서 좀 뻘쭘했다.</p><p>혹시 프라하 5구역의 안뎰(Andêl)역 근처에서 머물 예정이라면 <a href="https://www.hubpraha.cz/en/" rel="external nofollow noopener noreferrer" target="_blank">Impact Hub</a> D10을 추천한다. 일단 카운터 직원이 영어를 굉장히 잘하고 친절했으며 내부 공간 인테리어도 좋았다. 대신 Day pass 가격이 <code>390Kč</code>로, 다른 코워킹 스페이스에 비해서 조금 더 나가는 편이다.</p><center><br>  <img src="/2019/09/06/life-in-prague-tip/impact-hub.jpeg"><br>  <small>Impact Hub D10의 중앙 홀</small><br>  <br><br></center><p>근데 의외로 개발자는 생각보다 별로 없었다. 필자 포함 5~6명 정도? 그때만 그랬던 것일 수도 있지만 한국의 코워킹 스페이스에 비하면 생각보다 개발자가 많이 없어서 놀랬다. 그래서 그런지 필자가 코딩하고 있으니까 다른 개발자 분들이 먼저 관심도 가져주고 말도 걸어주고 했다.</p><p>어떤 영국 개발자 분이 필자한테 <code>어디서 왔냐</code>, <code>뭐 만드는 개발자냐</code>, <code>지금은 뭐 만들고 있는거냐</code>라고 물어보길래 지금 작업 중인 부분은 기존의 레거시 어플리케이션을 새로 만든 어플리케이션으로 마이그레이션하는 작업이라고 했더니 레거시 구조에 대해서도 관심을 가지고 물어보고 하더라.</p><p>근데 이 아저씨… 정작 레거시에 대한 설명을 듣더니 심각한 얼굴로 <code>Good luck, mate</code>를 외치고 커피타러 가버렸다.<small>(뭔가 팁이라도 줄 거라고 기대했다)</small></p><p>필자는 지금 프라하 5구역에서 머물고 있기 때문에 D10 스페이스에만 갔었지만 프라하 2구역에도 K10 스페이스가 또 있다. 근데 여기는 Day pass 가격이 <code>500Kč</code>이다. 사실 여기는 안가봐서 왜 이렇게 비싼지는 잘 모르겠는데 사진을 보면 뭔가 인테리어가 더 고급스러운 것 같기도 하다. 어쨌든 Impact Hub는 글로벌 기업이기 때문에 뭔가 검증된 시설을 원한다면 좋은 선택이 될 수 있을 것 같다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>사실 필자는 프라하에 도착한지 겨우 5일 정도 밖에 지나지 않았기 때문에 프라하의 구석구석을 다 아는 것은 아니다. 게다가 관광이 목적이 아니기 때문에 관광지를 많이 둘러보지도 않았고 그냥 산책 겸 왔다갔다 정도만 하고 있기 때문에 관광지에 대해서도 잘 모르는 상태다. 사실 한국에서처럼 카페가서 코딩하고 있으면 여기가 프라하라는 것도 잊어버릴 때가 있다.</p><p>그러나 한 달이라는 긴 시간을 머무는 만큼 일반적인 여행보다는 조금 더 여유를 가지고 이 도시에서만 느낄 수 있는 일상을 느낄 수 있다는 점이 좋은 것 같다. 그냥 집 밖을 나가서 동네만 돌아다녀도 한국과는 전혀 다른, 이국적인 풍경이 펼쳐지기 때문에 신기하기도 하고, 코워킹 스페이스에서 다른 나라의 개발자들과 얘기해볼 수 있다는 것도 재밌는 것 같다.<small>(사실 개발자라는 종족이 어느 나라든 다 비슷비슷한 느낌이기는 하다)</small></p><center><br>  <img src="/2019/09/06/life-in-prague-tip/prague-street.jpg" width="500"><br>  <small>확실히 이 동네는 유럽 느낌이 팍팍 난다</small><br>  <br><br></center><p>어차피 다음 달에 한국에 다시 돌아가면 면접도 보러다녀야하고 프리랜서 일도 마무리 해야해서 정신없을테니 여기 있는 동안 만큼은 최대한 여유를 가지고 지내려고 한다. 9월이라 날씨도 좋아서 공원에 가서 책 읽기도 좋다.</p><p>사실 출발하기 전에는 이런 저런 걱정이 많았지만 막상 와보니 여기도 결국 사람사는 곳이라 문제가 생겨도 어떻게든 해결할 수는 있는 것 같다. 그리고 체코 사람들 무뚝뚝 하다고 해서 걱정했는데, 그냥 표정만 무표정이고 행동은 다들 친절하다.<small>(츤데레)</small></p><p>한 달 동안 문화도, 언어도 다른 타국에서 생활한다는 것이 쉽지만은 않은 일이겠지만 해외에 나가본 경험이라고는 여행이나 출장 밖에 없는 필자에게 이번 경험은 굉장히 소중한 추억이 될 것 같다.</p><p>이상으로 프라하에서 디지털 노마드로 살아남기 포스팅을 마친다.</p>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/09/06/life-in-prague-tip/#disqus_thread</comments>
    </item>
    
    <item>
      <title>나는 어떤 마음으로 소프트웨어를 만들어야 하는가</title>
      <link>https://evan-moon.github.io/2019/09/05/about-software-craftsmanship/</link>
      <guid>https://evan-moon.github.io/2019/09/05/about-software-craftsmanship/</guid>
      <pubDate>Wed, 04 Sep 2019 22:58:15 GMT</pubDate>
      <description>
      
        &lt;p&gt;최근 필자는 산드로 만쿠소의 &lt;code&gt;소프트웨어 장인&lt;/code&gt;이라는 책을 읽게 되었는데, 이 책을 읽으며 느낀 점이 많았기 때문에 이번 포스팅에서는 산드로 만쿠소가 이 책을 통해 이야기하고자 하는 것이 무엇인지와 그에 따른 필자의 생각을 한번 편하게 적어보려고 한다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>최근 필자는 산드로 만쿠소의 <code>소프트웨어 장인</code>이라는 책을 읽게 되었는데, 이 책을 읽으며 느낀 점이 많았기 때문에 이번 포스팅에서는 산드로 만쿠소가 이 책을 통해 이야기하고자 하는 것이 무엇인지와 그에 따른 필자의 생각을 한번 편하게 적어보려고 한다.</p><a id="more"></a><center><br>  <img src="/2019/09/05/about-software-craftsmanship/book.jpg" width="500"><br>  <small>표지가 깔끔하니 이쁘장하다</small><br>  <br><br></center><p>산드로 만쿠소가 이 책에서 계속 해서 강조하고 있는 것은 제목 그대로 <code>프로페셔널리즘</code>이다. 저자는 책의 초반에서는 내가 개발자로써, 또는 기술 전문가로써 비전문가인 고객들에게 <code>어떠한 만족을 줄 것인지</code> 혹은 <code>고객이 진짜로 나에게 원하는 것은 무엇인지</code>와 같은 질문을 통해 소프트웨어를 개발하는 장인으로써의 태도를 이끌어 내려고 하고 있다. 그러다가 후반에는 고객들이 원하는 바를 충족시켜주기 위해 개발자로써 어떤 방법들을 사용할 수 있는지 설명하고 있다.</p><p>사실 처음에는 아무 생각없이 읽기 시작했는데, 어느 샌가 <code>그치, 이건 맞지</code>, <code>이건 좀 아닌듯?</code>하면서 빠져들고 있는 자신을 볼 수 있었다. 저자가 예시로 이야기하고 있는 상황들이 개발자로서 자주 경험하게 되는 상황들인 경우가 많고, 책 내에서 필자가 평소에 생각하고 있던 주제들도 많이 다루고 있다보니 더 빨리 빠져들었던 것 같다. 그만큼 재미있다 이 책.</p><p>그래서 필자는 이 책에서 재미있게 읽었고 많은 것을 느낄 수 있었던 주제 몇 가지를 한번 소개해보려고 한다.</p><h2 id="내-커리어의-주인은-누구인가"><a href="#내-커리어의-주인은-누구인가" class="headerlink" title="내 커리어의 주인은 누구인가"></a>내 커리어의 주인은 누구인가</h2><p>많은 개발자들이 개발자의 성장에 대한 지원을 해주고 관심을 가지는 회사를 선호한다. 컨퍼런스 가고 싶다고 하면 돈도 내주고 책도 사주고 스터디를 하고 싶다고 하면 사무실도 빌려주거나하는 그런 회사 말이다. 간혹 조직 문화 차원에서 업무 시간에 공식적으로 공부할 수 있는 시간을 내어주는 회사도 있다.</p><p>이런 회사들의 특징은 조직원이 성장하는 것이 결과적으로는 회사의 성장이라는 것을 잘 알고 있다는 것이고, 실제로 이런 문화가 있는 조직에는 좋은 개발자들도 많이 몰릴 수 밖에 없다. 자신의 성장을 지원해주는 회사, 얼마나 좋은가?</p><p>하지만 이런 지원이 없는 회사를 다니고 있다면 이런 불만이 생길 수도 있다.</p><blockquote><p>옆 동네 철수네 회사는 컨퍼런스 비용도 다 대주고 한다는데 우리 회사는 왜 안해주는거야…?</p></blockquote><p>필자도 회사를 다니면서 우리 회사보다 더 좋은 혜택이 있는 회사 얘기를 들으면 이런 생각을 하긴 했다. 그러나 저자인 산드로는 이런 불만을 가지는 것에 대해서 옳지 않다고 이야기한다.</p><p>사실 개발자가 새로운 기술을 공부하거나 컨퍼런스에 참여하거나 하는 등의 자신의 기술을 갈고 닦는 행위는 고객들을 만족시키기 위한 일종의 <code>투자</code>이다. 우리가 만약 몸이 아파서 병원에 갔는데 의사가 환자들에게 자신의 <code>연구 비용</code> 명목으로 진료비의 10%를 추가한다면 기분이 어떻겠는가? 산드로는 이 예시가 개발자들이 회사에 자신의 자기 계발을 위한 배려를 해달라고 강요하는 것과 다르지 않다고 이야기한다.</p><p>회사는 고객으로써 나의 기술력을 얻기 위해 나에게 돈을 지불하고 있는 것이지 나의 성장을 위해 돈을 지불하고 있는 것이 아니다. 물론 회사에서 이런 것들을 지원해주면 결국 개발자들의 실력 향상이 되면서 회사에도 좋은 영향을 끼칠 수 있지만 이건 일종의 <code>배려</code>이지 <code>의무</code>가 아니다. 개발자의 자기 계발은 스스로를 위한 투자이기 때문에 회사에서 지원을 해주던 말던 간에 기본적으로 스스로 알아서 해야 한다.</p><p>사실 필자도 첫 직장을 다닐 때는 개발자들의 발전을 지원해주고 컨퍼런스비나 도서 구입비를 지원해주는 것이 일종의 의무라고 생각했던 적이 있었다. 이런 지원을 해주지 않는 회사는 조직원의 성장에 별로 관심이 없는 회사이기 때문에 이런 회사에서는 더 이상 내가 성장할 수 없다고 생각했다. 기본적으로 퇴근 후에 따로 토이 프로젝트를 하거나 새로운 기술을 공부하기는 했지만 회사에서 지원을 해주면 더 빨리 성장할 수 있을 것이라고 생각했기 때문에 이런 불만을 가졌던 것이다.</p><p>하지만 이 생각은 굉장히 어리고 부끄러운 생각이였다. 회사에서 이런 지원을 해주면 좋긴 하지만, 혹여 저런 지원이 없더라도 필자는 소프트웨어 프로페셔널로서 고객에게 항상 최고의 결과물을 제공해야한다.<small>(그래도 안해주면 아쉽긴 하다)</small></p><p>저자인 산드로는 직장에서 이런 불만을 가지고 있는 팀원에게 <code>당신의 커리어의 주인은 누구인가?</code>라는 질문을 던졌다고 한다. 위에서 구구절절히 이야기한 것들을 단번에 관통하는 명쾌한 질문이다. 결국 내 커리어를 만들어 가는 것은 자기 자신이고, 내가 성장함으로써 가장 큰 이익을 받는 것도 자기 자신이기 때문이다.</p><h2 id="프로답게-행동하자"><a href="#프로답게-행동하자" class="headerlink" title="프로답게 행동하자"></a>프로답게 행동하자</h2><p>산드로는 <code>고용</code>과 <code>피고용</code>의 관계는 창조적인 업무를 할 때 방해되는 모델이라고 이야기한다. 단, 여기서 저자가 이야기하는 고용과 피고용의 관계는 단어 자체가 아니라 <code>고용과 피고용의 관계에서 오는 상명하복 시스템</code>을 의미한다. 쉽게 말하면 아무리 아닌 것 같아도 대표가 까라면 까야하는 그 시스템이다.</p><p>사실 이 상명하복 시스템은 아무리 수평적인 문화를 지향하는 기업이라고 하더라도 어느 정도는 암묵적으로 존재하기 마련이다. 직원이 회사에 <code>이건 좀 아닌 것 같다</code>라고 말할 수 있는 기업은 우리나라 뿐만 아니라 세계적으로도 생각보다 많지 않다.<small>(대표와 HR 담당자는 바로 우리 회사가 그런 회사라고 이야기하지만, 이건 직원 얘기를 들어봐야한다.)</small></p><p>하지만 잘 생각해보면 우리는 사실 회사와 <code>계약</code>을 한 것이다. 이 계약은 <code>내가 너의 노예가 되겠다</code>라는 계약은 아니였을 것이다. 회사는 나의 기술력을 원하고, 나는 기술 전문가로서 회사에 나의 기술력을 제공하는 일종의 동반자 관계인 것이다.</p><center><br>  <img src="/2019/09/05/about-software-craftsmanship/snl.jpg" width="500"><br>  <small>결국 전문가는 자신의 전문성을 파는 사람이다</small><br>  <br><br></center><p>그렇기 때문에 산드로는 회사도 개발자의 <code>고객</code>이라고 이야기한다. 우리는 소프트웨어를 만드는 전문가로서 회사에 나의 기술력을 팔고 있는 것이기 때문이다. 우리가 몸이 아프면 병원에 가서 의사를 찾거나 하수구가 막히면 배관공을 찾는 것과 마찬가지다. 회사가 소프트웨어를 만들고 싶으면, 개발자를 찾는다.</p><p>그리고 이러한 전문가들은 자신의 고객이 손해를 볼 것을 알면서도 어떠한 일을 해주기를 원한다고 해도, 그 일이 자신의 소신에 어긋난다면 그것을 쉽게 해주지 않는다. 간단한 예로 수술이 끝나고 마취가 풀리면서 고통이 찾아오면 환자는 의사에게 진통제를 더 투여해달라고 할 수 있다. 이때, 환자의 몸 상태가 진통제를 받아들일 수 없는 상태라면 의사는 진통제를 더 투여하지 않을 것이다. 환자는 그 진통제가 자신에게 어떤 영향을 끼칠지 모르는 상태이지만 의사는 확실하게 알고 있다.</p><p>개발자도 마찬가지다. 우리는 기술 전문가이기 때문에 기술적으로 우려되는 부분이 있다면 회사에 전부 이야기 해야한다. 회사는 바로 그런 기술적인 부분을 알고 싶어서 우리를 고용한 것이다. 그 중 대표적인 예는 바로 <code>프로젝트 기간</code>이다.</p><p>만약 대충 봐도 한달 이상 걸릴 것 같은 스펙의 프로젝트를 PO나 대표가 와서 2주 안에 끝내달라고 부탁하면 어떻게 해야할까? 많은 개발자 분들이 <code>한번 노력해볼게요. 달려봅시다!</code>라고 말할 것 같다. 왜냐면 저 상황에서 대표가 와서 간곡히 부탁하는데 딱 잘라서 <code>안되는데요?</code>라고 하면 왠지 내가 능력이 없는 것 같기도 하고 나쁜 사람이 되는 것 같기도 하고 그런 느낌?</p><p>자, 그럼 우리가 한달 이상 걸릴 프로젝트를 2주 안에 끝내려면 어떻게 해야할까?</p><center><br>  <img src="/2019/09/05/about-software-craftsmanship/overtime-work.jpg" width="500"><br>  <small>네 야근입니다. 저녁 배달 시키실 분?</small><br>  <br><br></center><p>기본적으로 이런 상황에서 개발자들은 야근을 택할 수 밖에 없다. 또 다른 것으로는 문제가 생길 것 같은 부분을 일단 대충 때우고 넘어가는 등 일을 빠르고 대충 처리하는 방법도 있다. 문제가 생길 것을 뻔히 알면서 <code>일단 끝내고 보자</code>라는 마인드로 하드 코딩을 하거나 스키마 설계를 제대로 하지 않고 모델을 구현한다거나 하는 것들 말이다.</p><p>그러나 산드로는 개발자들의 이런 행위에 대해서 <code>프로페셔널하지 못하다</code>라고 이야기한다.<small>(뜨끔)</small></p><p>사실 필자도 회사에서 이런 마음으로 몇번 프로젝트를 진행한 적이 있다. 당연히 제 기간 안에 프로젝트를 끝내는 게 제일 중요하다고 생각했고, 문제가 생길 수 있는 부분을 제대로 해결하지않고 어떻게든 작동하게만 만들어놓고 정신없이 다음 구현사항으로 넘어갔다. 물론 개발에 내공이 쌓이신 분들이라면 대충 하더라도 어느 정도 퀄리티가 나오겠지만 아쉽게도 필자는 그 정도 내공이 있는 개발자는 아니기 때문에 진짜 개판으로 짠 적도 있다.</p><p>하지만 이렇게 프로젝트를 진행하는 경우, 나중에 어플리케이션이 커질수록 이런 기술 부채들이 계속 쌓여서 분명히 문제가 발생할 것이라는 또한 우리 모두 알고있는 사실이다. 게다가 아무리 야근을 한다고 해도 프로젝트의 배포 일정을 맞출 수 있으리라는 보장도 없고, 어찌어찌 일정을 맞췄다고 하더라도 이런 상황에서 작성된 코드의 질이 높을리가 없고, 질낮은 코드는 결국 버그를 발생시킬 확률이 높아진다.</p><p>아무리 프로젝트 일정에 맞춰 배포를 했다고 해도 버그로 인해 사용자들이 좋지 않은 경험을 하게 만들었다면 그 프로젝트는 제대로 완료되었다고 할 수 없다. 산드로는 이런 상황에서 개발자가 프로페셔널로서 회사에 <code>이렇게 프로젝트를 진행하면 안된다</code>라고 강력하게 말해야 한다고 이야기한다.</p><p>즉, 개발자만이 지금 이 코드가 나중에 어떤 문제를 가져올 지 가장 정확하게 알고 있는 사람이고, 우리는 프로페셔널로서 프로젝트를 이렇게 진행하면 추후에 이런 문제점이 발생할 수 있다는 것을 고객인 회사에게 이야기할 의무가 있다는 것이다. 뭐, 이 상황을 어떻게 개발자가 아닌 사람들에게 이해시킬 것인지는 또 다른 문제지만 필자도 일단 이야기를 해야하는 것 자체는 맞다고 생각한다.</p><p>이렇게 이야기함으로써 PO나 CEO 등 개발자가 아닌 다른 팀원들이 문제 상황을 제대로 인지하게 되면 새로운 해결 방법이 나올 수도 있기 때문이다. 뭐 스펙 아웃을 해준다던가, 일정을 약간 늘려준다거나 하는 등의 여러 가지 해결책이 있을 것이다.</p><p>어쨌든 결론적으로 이 책의 저자가 이야기하고 싶은 것은 우리는 소프트웨어를 만드는 프로페셔널로서 회사에 기술력을 제공하고 있는 것이라는 것이다. 우리는 무리한 일정이 가져올 수 있는 문제를 회사에 이야기해주고 다른 합리적인 대안을 제시할 수 있어야 한다. 단순히 <code>돈 주니까 받는 만큼 시키는대로 해야지</code>라는 생각으로 일하지 말자는 것이다.</p><p>또한 회사 입장에서는 개발자가 이런 주장을 한다면 <code>일 쉬엄쉬엄하려고 하네?</code>라고 생각할 것이 아니라 뭔가 켕기는 부분이 있어서 하는 말이라는 것을 확실히 인지하고, 이런 상황에서 프로젝트를 강행하면 얻을 수 있는 것과 잃을 수 있는 것을 잘 판단해야한다.</p><h2 id="개발자가-코드를-대하는-태도"><a href="#개발자가-코드를-대하는-태도" class="headerlink" title="개발자가 코드를 대하는 태도"></a>개발자가 코드를 대하는 태도</h2><p>필자도 저번에 <a href="/2019/07/02/what-is-agile/" title="애자일이 도대체 뭐길래?">애자일이 도대체 뭐길래?</a> 라는 포스팅에서 한번 다룬 적이 있지만 애자일이라는 방법론은 애자일 선언에서 출발했고, 그 애자일 선언에는 이런 항목이 있다.</p><blockquote><p>포괄적인 문서보다 <strong>작동하는 소프트웨어</strong>를 만들자</p></blockquote><p>이때 이 <code>작동하는 소프트웨어</code>라는 정의의 범위는 개개인마다 조금씩 다르다. 어떤 개발자는 일단 돌아가기만 하면 됐다고 생각할 수도 있고 어떤 개발자는 설계가 군더더기없이 깔끔하고 유닛 테스트까지 모두 작성되어야 한다고 생각할 수도 있다는 것이다. 하지만 사실 대부분의 경우 <code>애자일 == 기민하게 움직여야한다</code>라는 개념에 사로잡혀서 전자를 택하게 된다.</p><p>그러나 잘 생각해보면 일단 돌아가게만 작성된 코드, 그러니까 제대로 된 설계나 추상화나 패턴이 없이 작성된 코드는 지금 당장 작성하기엔 쉬울 지 몰라도 새로운 기능이 추가될 때마다 문제가 발생할 것이다.</p><p>한번 우리가 엉망진창인 레거시 코드와 만났을 때 느끼는 감정들을 떠올려보자.</p><p>코드를 파악하기가 힘들어서 잘못 수정하면 어디가 어떻게 망가질 지 몰라 손을 대기도 무섭다. 그래서 작은 수정을 할 때마다 전체 기능을 전부 테스트해야지 안심이 된다. 그마저도 자동화가 되어있지 않아서 일일히 손으로 테스트 해야한다. 일단 이런 경우도 <code>작동하는 소프트웨어</code>의 범주에는 들어간다.</p><p>자, 이제 이런 레거시 코드에 어떤 기능을 새로 추가하거나 기존의 기능을 개선해야 한다고 생각해보자. 우리가 처음에 애자일을 도입하면서 의도했던 것처럼 기민하게 움직일 수 있을 것인가? 필자는 아니라고 생각한다.</p><p>처음에는 기능 개발이 빠르기 때문에 기민하게 움직이는 것처럼 보일지 몰라도 점점 누적되는 기술 부채들 때문에 결국 나중에는 기민하게 움직일 수 없게 될 것이다. 게다가 애자일에서 기민하게 움직인다는 것은 <code>빠르게 개발을 끝낸다</code>가 아니다. 자주 변경되는 요구사항에 유연하게 대처할 수 있는 기민함을 말하는 것이다.</p><p>산드로는 소프트웨어를 만들어내는 프로페셔널이라면 단순히 작동하는 소프트웨어가 아니라 <code>정교하며 솜씨있게</code> 만들어진 소프트웨어를 추구해야 한다고 말한다. 정교하며 솜씨있게 만들어진 소프트웨어란, 오래 전에 작성한 코드라도 새로운 신입 개발자가 바로 이해할 수 있을 정도의 명료하고 단순한 디자인, 새로운 기능을 추가 및 수정하는 일이 처음 개발할 때와 비슷한 수준의 개발 공수로 완료될 수 있는 소프트웨어를 말한다.</p><p>즉, 예측가능하고 유지보수할 수 있는 소프트웨어인 것이다. 산드로는 이런 소프트웨어를 작성하기 위해 필요한 개념으로 단위 테스트, 페어 프로그래밍, 지속적인 통합 등을 제시하고 있다. 하지만 저자가 제시한 방법들을 전부 실행하지 않더라도 사실 코드 리뷰만 잘 되어도 어플리케이션의 코드가 진짜 막장으로 가는 최악의 사태는 어느 정도 방어할 수 있긴 하다.</p><p>작동하는 코드를 작성하는 것은 개발자로서 당연히 해야하는 것이고, 프로페셔널한 개발자는 거기에서 더 나아가서 정교하며 솜씨있는 코드를 작성하는 것이다.</p><h2 id="시간이-없어서-어쩔-수-없었다"><a href="#시간이-없어서-어쩔-수-없었다" class="headerlink" title="시간이 없어서 어쩔 수 없었다"></a>시간이 없어서 어쩔 수 없었다</h2><p>필자는 개인적으로 이 주제에 대해서 많은 반성을 했는데, 사실 필자가 회사에서 자주 했던 말이기 때문이다. 프로젝트의 막바지에 다가갈수록 더 이런 얘기를 하는 경향이 있었던 것 같다.</p><p>여기서 필자가 반성했던 것 중 하나는 <code>단위 테스트 작성</code>과 <code>비즈니스 로직</code> 작성을 완전 별개의 업무로 생각했다는 것이다. 그리고 유닛 테스트보다 비즈니스의 개발을 끝내는 것이 중요하다고 생각했다. 그렇기 때문에 <code>시간이 없어서 테스트 작성은 다음에 한다</code>라는 핑계도 댈 수 있었다.</p><p>저자인 산드로는 유닛 테스트 작성을 굉장히 강조하는 편인데, 처음에는 직접 손으로 테스트를 해도 할만하지만 나중에 어플리케이션이 거대해지면 거대해질수록 이 테스트에 소요되는 시간도 함께 늘어나기 때문이다.</p><p>상용 환경에서 갑작스럽게 발생하여 원인을 쉽게 파악하기 힘든 버그의 상당 수는 유닛 테스트를 작성함으로써 간단하게 개발 중에 잡아낼 수 있다. 산드로는 이렇게 유닛 테스트를 통해 소모적이고 반복적인 작업을 줄일 수 있고, 이는 곧 생산성의 증대로 이어진다고 이야기한다.</p><p>그러면 여기서 이런 의문이 들 수도 있다.</p><blockquote><p>단위 테스트를 작성하게되면 절대적으로 작성해야 할 코드의 양도 늘어나고, 명료한 기능의 정의를 해야 하니까 이에 대해서 고민하는 시간도 늘어날테고… 그럼 결국 개발 기간은 더 길어질텐데?</p></blockquote><p>이 이야기도 맞는 말이다. 그냥 짜는 것보다는 확실히 오래 걸릴 것이다. 그러니까 애초에 일정 산정을 테스트를 작성하는 것까지 모두 포함해서 해야한다. 비즈니스 로직과 테스트 작성은 별개의 업무가 아니라 그냥 <code>기능 개발</code>하는 과정 중 하나이다.</p><p>그리고 유닛 테스트말고도 시간이 없어서라는 변명을 또 하는 경우가 있는데, 바로 구조적이지 않은 코드를 작성할 때이다. 쉬운 말로 날림 코딩이다. 솔직히 말해서 <code>일단 이렇게 해놓고 나중에 고치자</code>라는 이야기는 필자도 많이 했다. 버그가 발생할 것 같지는 않지만 가독성이 떨어지거나 구조가 명료하지 않은 상황에서 시간이 없다는 이유로 일단 넘어간 경우는 필자 뿐만 아니라 다른 개발자들도 겪어봤으리라 생각한다.</p><p>산드로는 이런 행위를 한다는 것은 개발자가 질 나쁜 코드를 아무런 죄책감 없이 어플리케이션에 끼워넣었다는 그 이상 그 이하도 아니다라고 비판했다. 이 형 가만보면 사람 명치를 되게 잘 때리는 스타일이다.</p><p>필자는 다른 주제들보다 이 주제가 머릿 속에 오래 남았던 것 같다. 나도 모르게 <code>시간 없어서</code>, <code>프로젝트를 끝내는 게 더 중요해</code>라는 말로 자기 합리화를 하면서 질 나쁜 코드를 작성하고 있던 게 아닌가라는 생각이 들었기 때문이다. 다른 주제들은 뭔가 깨달음을 주는 주제였다면 이 주제는 필자를 굉장히 부끄럽게 만든 주제였다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p><code>소프트웨어 장인</code>을 읽어 보신 분은 아시겠지만 이 책의 저자인 산드로 만쿠소 형은 좀 세게 말하는 스타일이다. 기존의 잘못됐다고 생각하는 면에 있어서는 강하게 비판하고 그에 따른 해결책을 제시하는 그런 느낌이다.<small>(사람 뼈를 여러 번 때린다)</small></p><p>그리고 프로페셔널한 개발자가 되기 위해 갖춰야 할 하드스킬과 소프트스킬에 대해서도 균형있게 다루고 있어서 지루하지 않게 이야기를 풀어나간다. 특히 소프트스킬은 <code>소프트웨어 장인 면접보기</code>와 같은 다른 책에서 보기 힘든 주제도 담고 있기 때문에 재미도 있다.</p><p>또한 이 책은 개발자 뿐만 아니라 개발자와 협업하는 다른 직군에서 일하고 있는 사람에게 하는 이야기도 담고 있기 때문에 굳이 개발자가 아니더라도 한번 읽어보면 좋을 것 같다.</p><p>이상으로 나는 어떤 마음으로 소프트웨어를 만들어야 하는가 포스팅을 마친다.</p>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/09/05/about-software-craftsmanship/#disqus_thread</comments>
    </item>
    
    <item>
      <title>커밋 히스토리를 이쁘게 단장하자</title>
      <link>https://evan-moon.github.io/2019/08/30/commit-history-merge-strategy/</link>
      <guid>https://evan-moon.github.io/2019/08/30/commit-history-merge-strategy/</guid>
      <pubDate>Fri, 30 Aug 2019 05:31:29 GMT</pubDate>
      <description>
      
        &lt;p&gt;이번 포스팅에서는 Git의 머지 전략 중 대표적인 3가지인 &lt;code&gt;Merge&lt;/code&gt;, &lt;code&gt;Squash and merge&lt;/code&gt;, &lt;code&gt;Rebase and merge&lt;/code&gt;의 차이에 대해서 한번 이야기해보려고 한다. 이 3가지 머지 전략 모두 브랜치를 머지한다는 목적은 같지만, 어떤 방식을 선택하냐에 따라 &lt;code&gt;커밋 히스토리&lt;/code&gt;가 기록되는 방식이 달라지게 된다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>이번 포스팅에서는 Git의 머지 전략 중 대표적인 3가지인 <code>Merge</code>, <code>Squash and merge</code>, <code>Rebase and merge</code>의 차이에 대해서 한번 이야기해보려고 한다. 이 3가지 머지 전략 모두 브랜치를 머지한다는 목적은 같지만, 어떤 방식을 선택하냐에 따라 <code>커밋 히스토리</code>가 기록되는 방식이 달라지게 된다.</p><a id="more"></a><p>이 3가지 머지 전략은 Github 뿐만 아니라 Atlassian의 Bitbucket에서도 동일하게 지원하고 있는데, 그 만큼 머지를 할 때 커밋 히스토리를 어떤 방식으로 남길 것이냐를 선택할 수 있는 것이 중요하다고 말할 수 있다.</p><center><br>  <img src="/2019/08/30/commit-history-merge-strategy/github-merge.png" width="500"><br>  <small>Github에서는 Pull Request를 머지할 때 머지 전략을 선택할 수 있다.</small><br>  <br><br>  <img src="/2019/08/30/commit-history-merge-strategy/bitbucket-merge.png" width="500"><br>  <small>Bitbucket에서는 레파지토리 설정에서 기본 머지 전략을 선택할 수도 있다.</small><br>  <br><br></center><p>Github과 Bitbucket의 머지 전략은 이름은 조금 다르지만 이것들이 의미하는 기능은 모두 같다. Github의 <code>Create a merge commit</code>은 Bitbucket의 <code>Merge commit</code>과 같은 전략이고 <code>Squash and merge</code>는 <code>Squash</code>와, <code>Rebase and merge</code>는 <code>Fast forward</code>와 같은 전략을 의미한다.</p><p>물론 이 머지 전략들은 각자 장단점이 있기 때문에 적재적소에 잘 사용하는 것이 중요하다. 예를 들어, Git Flow를 사용할 때는 기능 개발을 하는 <code>feature</code> 브랜치가 <code>develop</code> 브랜치로 머지될 때는 <code>Squash and merge</code>를, <code>develop</code> 브랜치가 <code>master</code> 브랜치로 머지될 때는 <code>Merge</code>을 사용하는 등 유연하게 사용하기도 한다.</p><p>하지만 적재적소에 잘 사용하려면 각각의 머지 전략이 어떤 방식으로 브랜치를 머지하는지 잘 알고있어야 가능한 법이다. 그래서 이번 포스팅에서는 이 3가지 머지 방식이 뭐가 어떻게 다른지 살펴보려고 한다.</p><h2 id="커밋-히스토리가-왜-중요한가요"><a href="#커밋-히스토리가-왜-중요한가요" class="headerlink" title="커밋 히스토리가 왜 중요한가요?"></a>커밋 히스토리가 왜 중요한가요?</h2><p>일단 머지 전략에 대한 설명에 들어가기에 앞서, Git의 커밋 히스토리가 왜 중요한지에 대해 간단히 이야기해보려고 한다. 서두에서 이야기한 3가지 머지 전략은 브랜치를 머지할 때 커밋 히스토리를 어떻게 남길 것이냐를 선택하는 것이나 마찬가지이기 때문에 <code>개발자들이 왜 커밋 히스토리에 이렇게 목매는지</code>에 대한 이해가 필요하다.</p><p>모두 알다시피 <code>커밋(Commit)</code>은 Git을 구성하는 중요한 요소 중 하나이며, 원칙적으로 하나의 커밋은 <code>의미있는 하나의 변경사항</code>을 의미한다.</p><p>그 말인 즉슨, 커밋 메세지만 보고도 어떤 사항이 어떤 이유로 변경되었는지 쉽게 파악할 수 있어야한다는 것이다. 많은 개발자들이 의미 있는 커밋 메세지에 대한 중요성을 언급하는 이유도 짧은 커밋 메세지만 보고도 언제, 어떻게 코드가 변경되었는가를 한번에 알고 싶기 때문이다.</p><p>이 커밋들이 모여서 시간 순으로 정렬된 것을 <code>커밋 히스토리(Commit History)</code>라고 부른다. 히스토리라는 단어에서 알 수 있듯이, 이건 말 그대로 이 프로그램의 역사와 같은 것이다. 많은 개발자들이 커밋 히스토리에 <code>의미있는 역사</code>를 기록하는 것이 굉장히 중요하다고 하는 이유에는 여러 가지가 있겠지만 대표적인 두 가지는 다음과 같다.</p><h3 id="버그가-언제-터졌는지-파악하기가-쉽다"><a href="#버그가-언제-터졌는지-파악하기가-쉽다" class="headerlink" title="버그가 언제 터졌는지 파악하기가 쉽다"></a>버그가 언제 터졌는지 파악하기가 쉽다</h3><p>우리가 Git을 사용하여 프로그램의 버전 관리를 할 때 혼자 개발을 진행하는 경우도 있지만 대부분의 경우 다른 여러 명의 개발자들과 함께 협업을 하게 된다. 이때 프로그램의 변경 사항이 많을 수록, 혹은 프로그램의 규모 자체가 큰 경우 협업에 참여하고 있는 개발자들은 사소한 실수로 인해서 버그를 발생시킬 가능성 또한 커지게 된다</p><p>이때 개발자들이 커밋 히스토리를 보고 어떤 이유로 어떤 코드가 수정되었는지 빠르게 파악할 수 있다면 해당 버그의 원인을 찾는 것이 더 빨라진다.</p><p>예를 들어 새로운 버전을 릴리즈한 후에 결제 관련 버그가 터졌다고 생각해보자. 이때 당연히 개발자들은 결제에 관련된 코드부터 뜯어보기 시작할 것이다. 하지만 대부분의 프로그램은 내부적으로 수많은 모듈 간의 디펜던시가 얽혀있는 경우가 많기 때문에 그걸 짧은 시간안에 전부 파악하고 버그의 원인을 찾아서 수정한다는 것은 쉬운 일이 아니다. 이때 잘 정리된 커밋 히스토리가 있다면 이번 버전에서 결제 관련된 부분을 수정한 커밋을 찾아서 어떤 코드가 수정되었는지 빠르게 확인할 수 있다.</p><p>만약 이전 버전에서는 문제가 없었고 이번에 배포한 버전에서 문제가 발생했다면 결제 관련 버그가 발생한 이유는 해당 커밋에서 수정한 코드 때문일 가능성이 높기 때문에 조금 더 빠른 대응이 가능하다.</p><h3 id="레거시-코드를-수정해야할-때"><a href="#레거시-코드를-수정해야할-때" class="headerlink" title="레거시 코드를 수정해야할 때"></a>레거시 코드를 수정해야할 때</h3><p>두번째 이유는 조금 슬픈 상황인데, 바로 레거시 코드를 고쳐야하는데 <code>코드 짠 사람이 없을 때</code>이다. 이 사람이 없는 이유는 퇴사라던가, 퇴사라던가, 퇴사같은 경우가 있다.</p><p>사실 레거시 코드가 무서운 이유는 코드 자체가 너무 복잡해서 파악하기 힘들다는 것 보다는 이걸 건드렸을 때 다른 부분에 문제가 없을 것이란 보장이 없기 때문이다. 게다가 이런 레거시 코드는 어느 회사에나 다 존재하기 때문에 레거시를 수정해야하는 상황이 그렇게 드문 상황도 아니다.</p><p>만약 그 코드가 딱 봐도 책임 분리가 잘 되어 있는 코드거나 간단한 코드라면 뭐 그냥 가벼운 마음으로 수정할 수도 있지만, 대부분 우리가 수정하기 망설여지는 코드는 그냥 레거시가 아니라 <code>오랜 시간 숙성된 레거시</code>인 경우가 많다. 특히 이 코드가 회사 창립 초창기에 작성된 코드일 경우에는 그냥 코드만 봐도 당시 개발자가 얼마나 정신없이 개발을 했는지 알 수 있을 정도인 것들도 있다.</p><center><br>  <img src="/2019/08/30/commit-history-merge-strategy/exit-office.jpg" width="500"><br>  <small>호랭이는 죽어서 가죽을 남기고 개발자는 죽어서 레거시를 남…</small><br>  <br><br></center><p>이런 코드의 경우 섣불리 수정했다가 예상 못한 곳에서 도미노처럼 와장창나는 경우가 있기 때문에 이 와장창을 몇번 경험해본 개발자들은 레거시 코드를 수정함에 있어서 신중하게 접근할 수 밖에 없다. 그럼 이 상황에서 우리가 선택할 수 있는 방법은 대략 4가지 정도가 있다.</p><blockquote><ol><li>건드리기 무서우니까 그냥 냅둔다.</li><li>퇴사자한테 어떻게든 연락해서 물어본다.</li><li>주변에 있는 개발자를 붙잡고 물어본다.</li><li>그냥 내가 분석한다.</li></ol></blockquote><p>음, 일단 1번의 경우는 본인이 <code>PO</code>나 <code>CTO</code>를 설득할 말빨이 없다면 성공할 확률이 낮다고 본다. 그리고 아마 좋은 소리를 들을 것 같지도 않다. 일단 개발자로써 월급을 받고 있으니 월급 값은 해야하지 않는가?</p><p>그렇다고 이미 퇴사한 사람한테 카톡해서 코드를 작성한 의도를 물어보기에는 왠지 싸대기 맞을 것 같기도 하고 좀 그렇다. 3번 같은 경우는 그나마 나은 경우긴 하지만 다른 팀원들도 다 바쁜데 매번 붙잡고 물어볼 수도 없는 노릇이니 결국 직접 분석하는게 제일 깔끔한 방법이다.</p><p>하지만 이 분석이라는 것이 말이 쉽지, 실제로 거대한 어플리케이션에서 단 하나도 놓치지 않고 모든 의존 관계를 파악한다는 것은 사실 쉬운 일이 아니다. 게다가 이런 분석은 단순히 코드만 본다고 되는 것이 아니라 비즈니스와도 밀접한 관련이 있는 경우가 많기 때문에 해당 기능의 개발 당시 비즈니스 히스토리도 어느 정도 함께 파악하는 것이 좋다.</p><p>그나마 팀 내에 해당 기능을 개발하게 된 히스토리를 알고 있는 동료가 있다면 다행이지만, 그 마저도 없을 경우 우리가 의지할 것은 당시의 개발자가 어떤 의도로 코드를 고쳤는지 기록해놓은 <code>커밋 히스토리</code> 밖에 없는 것이다.</p><p>물론 정신없이 개발하는 와중에 커밋 메세지에 당시의 비즈니스적인 의도까지 담는 경우는 거의 없기 때문에 비즈니스 히스토리는 파악하기 힘들 수 있지만, 의미있는 단위로 커밋이 되어있다면 적어도 어떤 의도로 이 코드를 수정했는지 정도는 파악할 수 있다. 말 그대로 역사를 읽는 것이다. 하지만 이때 커밋 히스토리가 너무 쓸데 없이 복잡하거나 커밋 메세지가 개판이라면 아무래도 읽어나가는데 어려움이 있을 수 밖에 없다.</p><center><br>  <img src="/2019/08/30/commit-history-merge-strategy/bad-commit-message.png" width="500"><br>  <small>이렇게 커밋해버리면 뭘 고친건지 알 수가 없다.</small><br>  <small>[출처] <a href="https://xkcd.com/" rel="external nofollow noopener noreferrer" target="_blank">https://xkcd.com/</a></small><br>  <br><br></center><p>그래서 개발자들이 <code>의미 있는 단위의 커밋</code>, <code>의미 있는 커밋 메세지</code>를 강조하는 것이고 여기에 더해 적절한 머지 전략을 사용하여 가독성이 높고 의미도 있는 커밋 히스토리 그래프를 유지하려고 하는 것이다. 필자는 이 중 깔끔한 히스토리 그래프를 만드는 방법에 대해 설명하려고 하는 것이고, 이때 필요한 것이 적절한 브랜치 머지 전략의 선택인 것이다.</p><h2 id="히스토리를-깔끔하게-만드는-3가지-머지-전략"><a href="#히스토리를-깔끔하게-만드는-3가지-머지-전략" class="headerlink" title="히스토리를 깔끔하게 만드는 3가지 머지 전략"></a>히스토리를 깔끔하게 만드는 3가지 머지 전략</h2><p>위에서 한번 설명했듯이 <code>Merge</code>, <code>Squash and merge</code>, <code>Rebase</code>는 두 개의 브랜치를 머지한다는 의미는 모두 같지만 머지하는 방법과 커밋 히스토리의 기록을 다르게 가져가는 머지 전략들이다. 한번 이 3가지 전략이 어떤 방식으로 브랜치를 머지하는 지, 커밋 히스토리는 어떻게 기록되는지 살펴보고 이에 따른 장단점을 알아보도록 하자.</p><h3 id="Create-a-merge-commit"><a href="#Create-a-merge-commit" class="headerlink" title="Create a merge commit"></a>Create a merge commit</h3><center><br>  <img src="/2019/08/30/commit-history-merge-strategy/merge-icon.jpg" width="300"><br>  <br><br></center><p><code>머지(Merge)</code>는 우리가 알고 있는 일반적인 머지 전략이다. 머지의 장점은 기존 개발자들에게 익숙한 개념이라는 것과 머지된 브랜치가 삭제되어 사라졌다고 해도 히스토리 그래프 상에서는 그대로 다른 가지로 표기되기 때문에 <code>어떤 브랜치에서 어떤 커밋이 진행되어 어떻게 머지가 되었군</code>이라는 자세한 정보를 얻을 수 있다는 것이다.</p><center><br>  <img src="/2019/08/30/commit-history-merge-strategy/merge-commit-1.png" width="350"><br>  <small><code>first-merge</code> 브랜치가 <code>master</code>로 머지된 히스토리</small><br>  <br><br></center><center><br>  <img src="/2019/08/30/commit-history-merge-strategy/merge-commit-2.png" width="350"><br>  <small>추후 <code>first-merge</code> 브랜치를 삭제하더라도 히스토리와 브랜치 가지는 그대로 남아있다</small><br>  <br><br></center><p>반면에 단점은 너무 자세하게 히스토리가 남기 때문에 브랜치의 개수가 많아지거나 머지 횟수가 잦아질수록 히스토리 그래프의 가독성이 떨어진다는 것이다.</p><p>또한 원칙적으로 커밋은 의미있는 변경 사항의 최소 단위라고는 하지만 사실 실무에서 일을 하다보면 <code>오타 수정</code>과 같은 자잘한 커밋을 하는 경우도 많다. 사실 이런 자잘한 커밋의 경우 별로 정보성이 없기 때문에 이런 커밋들이 많아지면 오히려 히스토리의 가독성을 저해하는 원인이 된다.</p><center><br>  <img src="/2019/08/30/commit-history-merge-strategy/merge-commit-3.png" width="500"><br>  <small>규모가 큰 어플리케이션일수록 이런 복잡한 히스토리가 그려지기 쉽다</small><br>  <br><br></center><p>위 그림에서 볼 수 있듯이 머지가 수행되었을 때 생기는 <code>머지 커밋(Merge commit)</code>은 <code>어느 순간에 어떤 브랜치의 변경사항이 머지되었다</code>라는 소중한 정보를 주는 커밋이지만 개발이 진행되고 있는 브랜치가 많아진 상황에서는 이 머지 커밋들과 해당 브랜치에서 발생한 커밋들이 전부 기록되기 때문에 그래프가 너무 복잡해져서 오히려 히스토리를 추적하기 힘들 수도 있다.</p><p>위 예시의 그래프는 조금 오래된 히스토리라 헤드가 앞으로 나아가면서 해당 시점의 <code>master</code> 브랜치가 최신 버전인 상황이기 때문에 반드시 맨 아래 쪽에 <code>master</code> 브랜치가 위치한다.</p><p>그 덕분에 <code>master</code> 브랜치를 기준으로 읽어나간다면 어느 정도 흐름을 읽을 수 있지만, 한창 개발이 진행되는 중이라 <code>master</code>의 헤드가 뒤로 밀리기도 하는 상황이면 그래프의 맨 아래 쪽에 <code>master</code> 브랜치가 위치하지 않고 중간 어딘가 쯤에 끼어있기도 하기 때문에 히스토리 그래프를 읽으면서 추적하다가 놓칠 때도 있다.<small>(해보신 분은 알겠지만 진짜 눈알 빠질 것 같다)</small></p><h3 id="Squash-and-merge"><a href="#Squash-and-merge" class="headerlink" title="Squash and merge"></a>Squash and merge</h3><center><br>  <img src="/2019/08/30/commit-history-merge-strategy/merge-squash-icon.jpg" width="300"><br>  <br><br></center><p><code>Squash and merge</code>에서 Squash는 여러 개의 커밋을 하나로 합치는 기능을 말한다. 즉, 이 기능은 머지할 브랜치의 커밋을 전부 하나의 커밋으로 합친 뒤 타겟 브랜치에 커밋하는 방식으로 머지를 진행한다. 즉 <code>Squash and merge</code>에서 발생하는 머지 커밋은 실질적인 머지로 인해서 생성된 머지 커밋이라기보다는 그냥 다른 브랜치의 변경 사항을 하나로 뭉쳐놓은 커밋인 것이다.</p><p>그래도 Squash and merge 전략은 일단 머지 커밋이 남긴 하기 때문에 머지가 되었다는 사실을 히스토리 상에서 한번에 알아볼 수 있고 버전 별로 어떤 것이 변경 되었는지 한 눈에 알수 있다는 것이 장점이다. 또한 머지된 브랜치의 자잘한 커밋 사항이 남지 않기 때문에 <code>머지가 되었다</code>라는 사실 자체에만 집중한 기록이 남게되고, 그로 인해 이 프로그램의 변경 사항을 읽기가 한결 수월해진다.</p><p>단점은 일반적인 머지 커밋보다는 아무래도 정보력이 떨어진다는 것이다. 일반 머지는 해당 브랜치에서 누가 어떤 커밋을 통해 어떤 라인을 수정 했는지 까지 알려주지만 Squash and merge 전략은 머지 대상 브랜치의 모든 커밋을 하나로 통합해버리기 때문에 그 정도의 자세한 정보는 알 수가 없다.</p><center><br>  <img src="/2019/08/30/commit-history-merge-strategy/squash-1.png" width="500"><br>  <small>머지하기 전 히스토리 그래프</small><br>  <br><br></center><p>지금 상황은 <code>update-a-txt</code> 브랜치의 헤드가 <code>master</code>의 헤드보다 하나 더 앞으로 나아간 상황이다. <code>update-a-txt</code> 브랜치의 가지를 보면 <code>update a txt</code>, <code>Add b txt</code> 총 2개의 커밋이 있고 최근에 <code>master</code>에서 최신 변경 사항을 받아왔다. 이때 Squash and merge 전략을 사용하여 <code>master</code>에 머지를 하게 되면 이 브랜치에 있는 모든 커밋은 하나의 커밋으로 합쳐져서 마스터에 커밋된다.</p><center><br>  <img src="/2019/08/30/commit-history-merge-strategy/squash-2.png" width="500"><br>  <small>Squash and merge를 사용하여 <code>update-a-txt</code> 브랜치를 <code>master</code>에 머지한 모습</small><br>  <br><br></center><p>위 그림에서 볼 수 있듯이 일반적인 머지와는 다르게 <code>update-a-txt</code> 브랜치의 가지가 <code>master</code>로 들어가는 형태가 아니라 <code>master</code> 브랜치에 <code>update a txt(#1)</code>이라는 새로운 커밋이 하나 추가된 것을 볼 수 있다. 이때 <code>master</code>에 추가된 커밋은 <code>update-a-txt</code> 브랜치의 모든 커밋, 즉 변경 사항을 하나로 합친 커밋이다.</p><center><br>  <img src="/2019/08/30/commit-history-merge-strategy/squash-3.png" width="500"><br>  <br><br></center><p>이후 쓸모 없어진 <code>update-a-txt</code> 브랜치를 삭제하면 <code>master</code>에는 Squash된 커밋이 남지만 <code>update-a-txt</code> 브랜치에서 커밋되었던 자세한 내용을 볼 수는 없다. 즉, Squash and merge을 사용하여 브랜치를 머지하게 되면 <code>머지된 사실</code> 자체는 알 수 있으나 <code>어떤 상황에서 어떤 코드를 변경 했는지</code>까지는 알 수가 없다.</p><h3 id="Rebase-and-merge"><a href="#Rebase-and-merge" class="headerlink" title="Rebase and merge"></a>Rebase and merge</h3><center><br>  <img src="/2019/08/30/commit-history-merge-strategy/rebase-icon.jpg" width="300"><br>  <br><br></center><p><code>Rebase and merge</code> 전략은 Git의 <code>리베이스(Rebase)</code> 기능을 사용하여 브랜치를 머지하는 것이다. 이때 리베이스는 말 그대로 브랜치 히스토리들의 베이스를 변경하는 기능이다. 베이스를 변경한다는 의미를 좀 더 쉽게 말하자면 <code>a</code> 브랜치의 변경 사항이 마치 <code>b</code> 브랜치에서 변경된 것처럼 바꿀 수 있다는 것이다.</p><p>리베이스는 머지된 브랜치의 커밋을 모두 살려놓기 때문에 누가 언제, 어떤 부분을 수정했다는 정보는 전부 알 수 있지만 해당 브랜치가 어느 시점에 머지되었는지는 알 수 없다. 그래서 리베이스를 사용하는 경우 다른 방법보다 더 태깅에 신경써줘야한다.</p><center><br>  <img src="/2019/08/30/commit-history-merge-strategy/rebase-1.png" width="500"><br>  <br><br></center><p>위 그래프는 <code>rebase-test-1</code> 브랜치에서 총 4번의 커밋을 진행하고 이제 <code>master</code> 브랜치로 머지해야하는 상황이다. 이때 리베이스를 사용하여 브랜치를 머지하게 되면 <code>rebase-test-1</code> 브랜치에서 발생한 모든 변경 사항이 마치 <code>master</code>에서 직접 커밋한 것 처럼 변경할 수 있다.</p><center><br>  <img src="/2019/08/30/commit-history-merge-strategy/rebase-2.png" width="500"><br>  <br><br></center><p>쨘, 리베이스를 진행하고 난 이후의 상황이다. <code>rebase-test-1</code> 브랜치의 모든 커밋들이 <code>master</code> 브랜치로 그대로 옮겨진 것을 볼 수 있다. 이제 쓸모 없어진 <code>rebase-test-1</code> 브랜치를 삭제하게 되면 처음부터 <code>master</code>에서 개발을 진행한 것과 같은 깔끔한 히스토리 그래프를 얻을 수 있다.</p><center><br>  <img src="/2019/08/30/commit-history-merge-strategy/rebase-3.png" width="500"><br>  <br><br></center><p>위 그림에서 볼 수 있듯이 리베이스를 사용하여 브랜치를 머지하게되면 <code>머지 커밋</code>이 생성되지 않기 때문에 어느 시점에 어떤 브랜치가 머지된 것인지 알 수가 없다. 그래서 위에서 말했듯이 필자는 <code>tag</code> 기능을 사용하여 해당 브랜치가 머지된 시점에 태그를 달아주는 것을 추천한다.<small>(시멘틱 버저닝을 합시다)</small></p><p>그리고 리베이스의 치명적인 단점 중 하나는 바로 <code>머지 충돌(Merge Conflict)</code>이 발생했을 경우다. 이건 머지할 브랜치의 히스토리 자체를 그대로 복사해서 대상 브랜치의 히스토리에 박아버리는 방법이기 때문에 충돌이 발생하게 되면 <code>Merge commit</code>이나 <code>Squash and merge</code>처럼 충돌이 한번 발생하는 것이 아니라 각각의 커밋에 하나씩 충돌이 발생한다. 이게 머지할 브랜치의 커밋이 몇개 안되는 상황에서는 할만할지 몰라도 커밋이 몇 백개씩 되는 큰 기능의 브랜치를 리베이스로 머지했다가 충돌이 나면 그냥 죽었다 생각하고 커피를 타오도록 하자.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>사실 커밋 히스토리를 잘 남기는 것은 미래의 나 자신을 위한 것일수도 있지만, 그보다는 내가 작성하는 코드를 언젠가 고쳐야할 누군가를 위해 신경써야 하는 것이 더 크기는 하다.</p><p>쭉 읽어보면 알겠지만 이 3가지 머지 전략은 각각 장단점이 명확하기 때문에 머지 전략 간의 우위는 없다. 그냥 상황에 따라서, 혹은 팀의 전략에 따라서 알맞은 머지 전략을 선택하면 된다는 것이다. 혹자는 <code>Squash and merge</code>나 <code>Rebase</code>와 같은 기능이 필요없고 그냥 일반적인 머지만으로도 충분히 버전 관리가 가능하다고 말하기도 한다.</p><p>그래도 이 3가지 머지 전략이 어떤 원리로 브랜치를 병합하는지 제대로 파악하고 히스토리가 어떻게 기록되는지 알고 있다면 복잡한 협업을 통해 개발이 진행되는 상황에서도 가독성 높은 히스토리 그래프를 만들어 낼 수 있고, 깔끔한 히스토리가 가져다주는 장점들은 분명히 있기 때문에, 아직 일반적인 머지만을 사용하여 히스토리를 관리하고 있었다면 한번 여러가지 전략을 사용해보는 것을 추천한다.</p><p>이상으로 커밋 히스토리를 이쁘게 단장하자 포스팅을 마친다.</p>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/08/30/commit-history-merge-strategy/#disqus_thread</comments>
    </item>
    
    <item>
      <title>개발자가 공부로 살아남는 방법</title>
      <link>https://evan-moon.github.io/2019/08/26/how-does-developer-study/</link>
      <guid>https://evan-moon.github.io/2019/08/26/how-does-developer-study/</guid>
      <pubDate>Mon, 26 Aug 2019 09:53:03 GMT</pubDate>
      <description>
      
        &lt;p&gt;이번 포스팅에서는 개발자들에게 뗄레야 뗄 수 없는 키워드인 &lt;code&gt;공부&lt;/code&gt;에 대해서 포스팅 해보려고 한다. 물론 다른 직종도 마찬가지겠지만 다른 업계보다 빠르게 변화하는 IT 업계의 특성 상 개발자는 시대의 흐름을 따라가기위해 은퇴 전까지 계속 해서 공부를 하는 수 밖에 없다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>이번 포스팅에서는 개발자들에게 뗄레야 뗄 수 없는 키워드인 <code>공부</code>에 대해서 포스팅 해보려고 한다. 물론 다른 직종도 마찬가지겠지만 다른 업계보다 빠르게 변화하는 IT 업계의 특성 상 개발자는 시대의 흐름을 따라가기위해 은퇴 전까지 계속 해서 공부를 하는 수 밖에 없다.</p><a id="more"></a><p>개발자들은 아무래도 기술을 활용하는 최전선에 있는 사람들이기 때문에 이런 변화에 민감하다. 그 변화는 스쳐지나가는 한 때의 유행일수도 있고, 앞으로 20년을 버틸 수 있는 근본적인 지식일 수도 있다. 하지만 아무리 우리가 매일 공부를 한다고 해도 쏟아져 나오는 기술의 양이 워낙 많기 때문에 전부 공부한다는 것은 불가능하다. 그래서 우리는 이 기술이 단순한 유행인지, 오래 써먹을 수 있는 기술인지 혹은 지금 당장 나에게 필요한 기술인지 등을 파악하며 자신에게 맞는 기술을 습득해야한다.</p><p>그래서 이번 포스팅에서는 필자가 지금까지 4년 동안 거의 난장판이나 다름없던 웹 프론트엔드 생태계에서 어떤 기준을 가지고 공부할 것을 선택하고, 어떤 방법을 사용하여 공부를 해왔는지 한번 가볍게 적어보려고 한다. 물론 이 내용은 필자 개인의 주관적인 의견이므로 정답도 아닐 뿐더러 여러분과는 맞지않는 비효율적인 방법일 수도 있다. 그냥 <code>이런 사람도 있구나</code> 정도로 가볍게 읽어보고 참고하는 것을 추천한다.</p><h2 id="우리가-공부를-게을리하면-안되는-이유"><a href="#우리가-공부를-게을리하면-안되는-이유" class="headerlink" title="우리가 공부를 게을리하면 안되는 이유"></a>우리가 공부를 게을리하면 안되는 이유</h2><p>필자가 공부하는 방법을 설명하기에 앞서, 먼저 <code>왜 개발자는 공부를 게을리 하면 안되는가?</code>에 대해서 한번 이야기해보려고 한다. 사실 굳이 상세한 이유를 들지 않아도 빠르게 변화하는 업계에서 도태되지 않고 살아남으려면 공부를 해야한다는 간단명료한 대답이 있긴 하지만, 사실 이 대답은 제대로 된 대답은 아니다. 약간 결과론적인 대답이라는 느낌이 든다. <code>공부 안하면 도태당하니까 공부를 열심히 해야지</code> 이런 느낌이랄까?</p><p>이런 대답은 질문자에게 제대로 된 동기 부여도 되지않을뿐더러 <code>왜</code>에 대한 궁금증을 해결해주기 힘든 대답이다. 그래서 필자는 저 조금 더 자세하게 이야기를 해보려고 한다.</p><h3 id="기술이-발전하는-속도는-생각보다-빠르다"><a href="#기술이-발전하는-속도는-생각보다-빠르다" class="headerlink" title="기술이 발전하는 속도는 생각보다 빠르다"></a>기술이 발전하는 속도는 생각보다 빠르다</h3><p>일 시작한지 4년밖에 안된 개발자인 필자조차 일을 하다보면 <code>뭐가 이렇게 빨리 바뀌어?</code>라고 생각한 적이 꽤 있었다. 그렇게 바뀐 것들은 <code>오 좋은 게 새로 나왔네</code> 정도인 가벼운 변화부터 <code>응...? 도대체 이게 뭐지...?</code>라고 생각할만한 급격한 변화까지 아주 다양했다.</p><p>꼴랑 4년 차인 필자가 이런 생각을 할 정도면 10년이 넘으신 시니어들은 아마 더할 것이라고 생각한다. 게다가 옛날에 비해서 기술이 발전하는 속도는 점점 빨리지고 있기 때문에 앞으로는 더 빠르게 바뀔 수도 있다고 생각한다.</p><center><br>  <img src="/2019/08/26/how-does-developer-study/inderstrial_revolution.png" width="500"><br>  <small>인류의 기술 발전 속도는 점점 더 빨라지고 있다</small><br>  <br><br></center><p>위의 예시는 산업혁명이 언제 발생 했는지 나타낸 것인데, 1차 산업혁명이 발생한 1784년에서 시작해서 4차 산업혁명이 발생한 오늘날에 이르기까지 점점 더 간격이 줄어드는 것을 볼 수 있다. 이렇듯 인류의 기술 발전 속도는 선형이 아닌 지수형태로 증가하고 있다.</p><p>산업혁명을 예로 들면 너무 거시적이여서 와닿지 않을 수 있다. 하지만 기술자가 평소에 느끼는 기술의 변화 하나하나는 비록 자잘한 것들일 수 있어도 결국 산업 전반에 걸쳐 이런 것들이 쌓이고 쌓여서 서로 시너지 효과를 내며 임계점을 돌파하게 되는 것이기 때문에 기술자들이 기술의 변화를 느끼고 따라갈 수 있는 능력 또한 무시할 만한 것은 아니다.</p><p>즉, 사람들이 자주 이야기하는 <code>도태된다</code>라는 것은 이런 의미이다. 예를 들어 농사짓는 법을 마스터한 신라의 장인이 있다고 생각해보자. 그 사람은 1000년이 지난 후의 조선에서도 그 스킬을 가지고 충분히 먹고살 수 있다. 무려 1000년의 간극이 있는데도 말이다. 그에 비해 1970년대에 미국 국방성에서 계산 업무를 하던 인간 컴퓨터들은 2019년인 지금은 아예 사라진 직업이 되었다.</p><p>이 변화는 앞으로 점점 더 빨라질 것이며, 그렇기에 사람들이 <code>도태되지 않으려면 공부해야해</code>라는 소리를 하는 것이다. 물리 서버에서 클라우트 컴퓨팅으로 넘어가는 기술의 흐름은 아주 사소한 것처럼 보일 수 있지만, 그렇다고 그냥 가볍게 보고 넘겨버린다면 2년 정도만 지나도 그 이후에 나온 새로운 패러다임을 따라가기는 점점 더 어려워진다.</p><h3 id="IT-업계의-변화는-파장이-크다"><a href="#IT-업계의-변화는-파장이-크다" class="headerlink" title="IT 업계의 변화는 파장이 크다"></a>IT 업계의 변화는 파장이 크다</h3><p>사실 당연히 IT를 제외한 다른 계열의 지식들도 세월이 지남에 따라 변화한다. 그러나 IT 업계가 변화한다는 것은 단순히 속도 면에서 빠르게 변한다는 것 외에도 기존의 패러다임이 뒤집어 질 정도로 큰 변화가 자주 일어난다는 것을 의미한다.</p><p>예를 들어 물리학 같은 경우, 기존의 이론이 잘못 되었음을 증명하고 새로운 이론을 제시하게되면 전 세계의 물리 교과서가 다시 쓰여질 정도로 그 파장은 어마무시하다. 그러나 그런 경우는 생각보다 자주 일어나는 일이 아니다. 대표적인 예로 아인슈타인이 제시한 <code>시간은 관찰자의 상태에 따라 상대적으로 흐른다</code>라고 제시한 상대성 이론이 있다. 지난 몇천년의 세월동안 늘 절대적인 흐름일 것이라고 생각했던 시간이라는 개념이 한순간에 뒤집힌 사례이다.</p><p>또한 법학의 경우, 법이 개정됨에 따라 새로운 법을 공부하고 새로 제정된 법과 비슷한 사례가 적용된 판례를 다시 찾아보는 경우가 있다. 이는 정부에서 크고 작은 법을 개정할 때마다 반복되기 때문에 빈도는 잦을 수 있지만 기존의 법이 가지고 있던 패러다임을 완전 뒤집어 놓지는 않는다. 그 정도로 파격적인 법안을 제정하기란 쉽지 않기 때문이다.</p><p>그러나 IT 업계에서 발생하는 변화는 속도 면으로도 빠르게 변화하면서도 기존의 패러다임을 뒤집는 경우가 종종 있다. 몇가지 예를 들어보면, <code>jQuery</code>에서 <code>AngularJS</code>로 넘어갔을 때, <code>MVC</code> 패턴에서 <code>Flux</code> 패턴으로 넘어갔을 때, <code>Docker</code>라는 가상 컨테이너가 처음 나왔을 때도, <code>서버리스 아키텍처</code>라는 개념이 처음 나왔을 때도 그랬다. 아마 필자가 직접 겪지는 않았지만 클라우드 컴퓨팅 서비스를 제공하는 AWS가 처음 나왔을 때도 그랬을 것 같다.</p><p>이렇게 IT의 경우, 기존의 그것들을 구성하고 있는 패러다임을 완전히 버리고 온전히 새로운 것에 집중해야 이해할 수 있는 것들이 많았고, 그때마다 이 생태계는 많은 변화가 있었다. 그리고 그때마다 개발자 뿐만 아니라 개발자가 아닌 사람들의 생활에도 큰 영향을 끼쳤다.</p><p>사실 이런 이야기를 하면 <code>이런 것들이 어떻게 사람들의 생활에 영향을 준다는 거지?</code>라고 생각할 수 있는데, 대표적인 예를 몇개 들어보겠다.</p><p>이런 변화들 덕분에 지금은 많은 회사들이 실제 물리 서버를 구매한 후 <code>IDC(Internet Data Center)</code>에 입주해서 사용하지 않고 클라우드 컴퓨팅을 사용하여 서버를 운영하고 있다. 이는 서버를 직접 관리해야하는 리소스의 감소와 유연한 트래픽 대처로 이어졌고, 결과적으로 서버를 운영할 때 발생하는 부담을 상당 수 줄여주었다.</p><p>또한 요즘에는 JavaScript 하나만 할 줄 알아도 웹 클라이언트, 모바일 어플리케이션, 데스트톱 어플리케이션, 서버까지 전부 만들 수 있으며, 이는 개발자들이 용도에 맞는 어플리케이션을 개발하려고 할 때 여러 개의 언어를 공부하지 않아도 바로 원하는 서비스를 뚝딱 만들어낼 수 있다는 것을 의미한다.</p><p>또한 방금 설명한 클라우드 컴퓨팅 서비스를 제공하는 회사에 약간의 돈만 지불하면 백엔드 인프라도 클릭 몇번으로 간단하게 구성 및 관리할 수 있기 때문에 단 한명의 개발자가 거대한 시스템을 운영하는 것도 가능하다.</p><p>이런 변화들 덕분에 프로그래밍에 대한 장벽이 옛날에 비해 많이 내려간 상태이고 누구나 아이디어만 있다면 새로운 IT 사업에 도전할 수 있는 시대를 이끌어 냈으며, 그 결과 <code>Google</code>이나 <code>Facebook</code> 같은 IT 대기업들이 생겨나게 되어 우리에게도 직접적인 영향을 주고 있다.</p><h2 id="내가-공부하는-방법"><a href="#내가-공부하는-방법" class="headerlink" title="내가 공부하는 방법"></a>내가 공부하는 방법</h2><p>필자 또한 급격한 기술의 흐름 속에서 뒤쳐지지 않으려 발버둥 치고있는 개발자 중 한 사람이기 때문에, 당연히 평소에 공부를 하고 있다. 그러나 이 포스팅에서 필자는 <code>공부를 해야한다</code>라는 당연한 사실보다는 <code>나는 이렇게 공부하고 있다</code>에 대한 이야기를 하고 싶었다.</p><p>필자는 주변에 많은 개발자 분들이나 또는 개발을 공부하고 계신 분들, 혹은 어떤 분야에 있다가 다른 분야로 넘어가시는 분들이 공부에 대한 어려움을 표하는 것을 많이 들어본 적이 있다. 이들의 어려움은 공부해야하는 기술 자체의 난이도보다는 <code>어떤 것부터 공부해야할지 모르겠다</code>라는 것이다.</p><p>이건 요즘 같이 새로운 정보가 쏟아져 나오는 시대에는 당연한 이야기인데, 개발 공부를 시작하기 전에 선택해야할 것이 많아도 너무 많다. 언어와 프레임워크를 먼저 공부할 것인지 컴퓨터에 대한 기초부터 공부해야 하는 것인지부터 시작해서, 어떤 언어를 공부해야 하는지, React를 공부해야 하는 지 Vue를 공부해야 하는 지 등 개발 공부를 시작하려고하면 선택해야할 것도 너무나도 많다.</p><p>게다가 이런 것들은 정답이랄게 없기 때문에 주위의 개발자들에게 물어보거나 커뮤니티에 물어봐도 사람마다 다른 답변이 돌아올 가능성도 높다.</p><p>필자 개인적으로는 우리의 이런 성향에는 대한민국의 사회 분위기가 어느 정도 적용한 것 같다는 생각이다. 솔직히 우리는 어릴 때부터 내가 스스로 정하는 길이 아닌 부모님이 하라는 대로 열심히 학교나 학원가서 공부하고 자란, 그런 세대지 않은가? 심지어 대학 진학 시 과를 고를 때도 자기가 공부하고 싶은 학문이 아니라 성적에 맞춰서 가는 경우도 많다.</p><center><br>  <img src="/2019/08/26/how-does-developer-study/exam.jpg" width="500"><br>  <small>수능도 물론 중요하지만, 떨어지거나 인서울 못한다고 해서 인생이 망하는 건 아니더라.</small><br>  <small>필자도 맨날 놀다가 수능 망쳐서 대학 못갈 뻔 했지만 잘 살고 있다.</small><br>  <br><br></center><p>대학에 들어간 이후에는 남들이 하는 대로 토익 점수도 만들고 자격증도 따고 인턴십도 하면서 취업 준비를 하고 취업을 한다. 이 과정 속에서 <code>내가 진짜로 원하는 것은 뭘까?</code>라는 생각을 하기란 솔직히 쉽지 않은 현실이다.<small>(남들한테 뒤쳐질까봐 그냥 정신이 없다)</small></p><p>이런 상황에서 갑자기 <code>자, 이제 너는 으른이니까 니가 스스로 공부하고 싶은 것을 찾아보렴</code>이라고 하면 적응 안되는 게 당연한 것일지도 모른다.</p><p>자, 일단 필자가 제안하고 싶은 것은 이렇다. 일단 뭘 공부해야 할지에 대한 생각은 잠깐 접어두자. 이건 어차피 뭐부터 공부를 시작하던 간에 해야할 게 너무 많기 때문에 답이 없다. 여기서 중요한 것은 <code>뭘 공부할지</code>를 정하는 것이 아니라 <code>뭘 만들지</code>를 우선 정하는 일이다.</p><h3 id="무엇을-만들고-싶은-지-먼저-정해보자"><a href="#무엇을-만들고-싶은-지-먼저-정해보자" class="headerlink" title="무엇을 만들고 싶은 지 먼저 정해보자"></a>무엇을 만들고 싶은 지 먼저 정해보자</h3><p>필자에게 <code>뭘 공부해야할지 모르겠다</code>라는 이야기를 하는 분들에게 필자가 제일 먼저 던지는 질문이 있다.</p><blockquote><p>그래서, 뭘 만들고 싶은지 생각해봤어요?</p></blockquote><p>이 질문을 하면 놀랍게도 10명 중 9명은 <code>글쎄요</code>라고 대답을 한다. 자신이 뭘 만들고 싶은지 모르는 상태에서 개발에 대한 공부를 시작하려고 하는 것이다. 이런 접근 방식으로 개발을 공부하면 대략 이런 문제가 생긴다.</p><hr><ol><li>목표가 없거나 두루뭉술하기 때문에 어디까지 해야 공부가 끝나는 지 알 수가 없다.</li><li>배운 걸 바로 써먹지 못하니까 공부가 재미가 없다.</li></ol><hr><p>첫번째 문제같은 경우가 심각한 경우인데, 애초에 목표 자체가 없거나 단순히 <code>개발을 잘하고 싶다</code>와 같은 두루뭉술한 이유이기 때문에 아무리 공부해도 본인이 이 달리기의 결승점이 어디인지 알 수가 없다. 이런 경우에는 처음 시작은 열정적이었으나 점점 지쳐서 공부를 멀리 하게될 가능성이 높아진다.</p><p>공부는 사실 집중을 얼마나 잘하느냐가 중요하다. 100가지 과목을 10년 걸려서 끝내는 것보다 1가지 과목을 1달 안에 끝내고 다음 걸 하는 게 더 낫다는 이야기이다. 이때 뭐부터 공부해야할지 모르는 상황이라면 이것저것 건드려보다가 <code>아 개어렵다...</code>하고 그만 두게 될 가능성이 높다는 것이다.</p><p>두번째 문제의 경우, 그냥 첫번째 문제의 연장이나 마찬가지다. 그냥 재미가 없다. 초중고에서 배우는 영어나 수학이 재미없는 이유도 비슷한데, 이걸 어디다가 쓰는 지도 안 알려주고 무작정 외우라고 하기 때문에 재미가 없는 것이다. 지식이라는 것은 적재적소에 써먹어야 빛을 발하는 법인데 주구장창 외워서 시험 볼때만 사용하려고 공부한 지식은 사실 별 의미가 없다.</p><p>그래서 필자같은 경우는 어떤 기술을 공부하고 싶을 때, 그 기술을 사용해서 어떤 것을 만들 수 있을 지 먼저 고민해본다. 잘 고민해보면 분명히 한두개는 나온다. 혹은 만들고 싶은 것을 먼저 생각해보고 그걸 만들 때 해당 기술을 사용하는 방법으로 접근할 수도 있다. 중요한 포인트는 <code>그 기술을 사용하는 것</code>이다.</p><p>필자의 경우는 후자를 더 좋아하는 편이다. 일단 만들고 싶은 것을 먼저 생각하고 거기에 필요한 지식을 공부한다. 때로는 논문을 분석해야 할수도 있고, 대학교 때 잠깐 들었던 수업의 교재를 다시 꺼내봐야 하는 경우도 생길 수도 있으며 사용하고자 하는 기술의 공식 문서를 밤새도록 읽어봐야 할 수도 있지만 그래도 이왕 시작한 프로젝트를 완성하고 싶어서 끝까지 공부하게된다.</p><center><br>  <img src="/2019/08/26/how-does-developer-study/solar_system.png"><br>  <small>2017년부터 꾸준히 만들어온 태양계 시뮬레이터</small><br>  <br><br></center><p>필자는 어릴 때부터 우주를 굉장히 좋아했는데, 코딩을 처음 시작할때부터 태양계 천체의 움직임을 구현하고 싶다는 마음이 있었다. 하지만 이걸 만드려면 컴퓨터 그래픽과 수학, 천체물리학을 어느 정도 이해하고 있어야 했는데, 처음에는 엄두가 안나서 손을 안대고 있었다. 그러다가 개발자로 일을 시작하고 몇년이 지난 어느 날, <code>이대로 가다간 절대 이 프로젝트를 시작할 수 없겠다</code>라는 마음이 들었고, 그 이후 그냥 무작정 케플러 궤도 방정식과 선형대수학을 공부하기 시작해서 결국 오랫동안 그려왔던 프로젝트를 어느 정도 완성할 수 있었다.</p><p>물론 굉장히 어렵고 힘들었다. 필자는 수학을 그렇게 좋아하는 편이 아니기 때문에 온통 수학 떡칠인 저 어플리케이션을 만들 수 있을지도 의문이었다. 그래서 필자는 한 1년 정도 공부 하면서 만들면 기본적인 틀을 완성할 수 있을 것이라고 생각했는데 1년은 무슨… 3개월만에 만들었다.</p><p>물론 필자가 3개월 만에 케플러 궤도 방정식과 같은 어려운 이론을 전부 이해했다는 뜻이 아니다. 그냥 태양계 시뮬레이터를 만들 수 있을 정도의 수준으로 이해한 것이다. 그리고 애초의 필자의 목적은 천체 물리학을 공부하는 것보다는 태양계 시뮬레이터를 만드는 것이었으므로 완벽하게 이해할 필요도 없었다.</p><p>필자는 그렇게 머리가 좋은 편도 아니다. 그냥 매일 잠을 줄여가면서 꾸준히 공부한 것이다. 수식이 잘 이해가 안되면 코드로 포팅해서 한 라인씩 돌려보면서 이해했다. 그리고 이런 노가다성 공부는 진짜로 이루고 싶은 목표가 있다면 사실 누구나 다 할 수 있다.<small>(진짜 머리가 좋은 사람은 태양계 시뮬레이터 같은 거 만들 시간에 비트코인을 샀을 것이다)</small></p><center><br>  <img src="/2019/08/26/how-does-developer-study/exam_fail.png" width="400"><br>  <small>필자도 여러분과 마찬가지로 면접에 조져지고 시험에 조져지고 한다</small><br>  <br><br></center><p>결국 공부란 이런 것이다. <code>뭔가에 사용하기 위해 필요한 지식을 습득하는 것</code>이라는 것이다. 아무런 목표가 없는 공부는 우리가 단지 수능을 잘보기 위해 공부했던 고3 시절과 다름이 없다. 물론 그 당시 공부의 목표는 <code>수능을 잘 보는 것</code>이었겠지만 우리는 이제 그런 수박 겉핥기 같은 목표가 아니라 좀 더 본질적인 목표를 가져야 한다.</p><p>그렇게 자기 자신에게 목표를 부여함으로써 강한 동기를 이끌어내고, 그 동기로 끈기있는 공부를 할 수 있는 원동력을 만들어 가는 것이 중요하다. 무작정 공부를 시작하기 전에 <code>내가 왜 이걸 공부해야하는 지</code>부터 한번 만들어보자.</p><h3 id="자기-주관대로-공부하자"><a href="#자기-주관대로-공부하자" class="headerlink" title="자기 주관대로 공부하자"></a>자기 주관대로 공부하자</h3><p>방금 필자는 <code>공부의 목표</code>가 얼마나 중요한 것인지에 대해서 이야기했다. 필자가 방금 설명한 <code>만들고 싶은 것을 정하자</code>라는 목표는 나에게 당장 필요하지 않은 지식일지라도, 그 필요를 만들어내는 하나의 방법이다. 이 지식이 나에게 필요한 상태로 정의됨에 따라서 동기를 부여하는 방법이다.</p><p>하지만 이 방법은 공부를 시작하고나서 중간에 포기하지 않도록 만들어 주는 힘이 더 강하다. 그래서 우리는 <code>어떤 지식이 나에게 필요한 지식인가?</code>도 함께 생각해봐야한다. 단, 이 <code>필요한 지식</code>이라는 기준이 사람마다 다르다.</p><p>필자같은 경우 <code>필요한 지식</code>의 우선 순위는 철저하게 <code>내가 뭘 만들 때 필요한 지식</code>이다. 어떤 기술이 유행하든 세계 점유율이 90%가 넘든 간에 별로 흥미가 안가면 공부를 안하는 편이다. 그러다가 어떤 회사에 들어갔는데 그 지식이 필요하다싶으면 그때가서 공부하기도 한다.</p><p>필자가 지금까지 만든 프로젝트들만 봐도 알겠지만, 필자는 웹 프론트엔드 개발자이기 때문에 태양계 시뮬레이터나 오디오 이펙터같은 걸 만들어봤자 거기서 얻은 지식을 써먹을 확률은 상당히 낮다. 그래서 면접에 들어갔을 때 면접관이 <code>이건 왜 만드신거에요?</code>라고 물어보면 그냥 쿨하게 <code>자기만족이요</code>라고 대답한다.</p><p>이렇게 사람마다 <code>필요한 지식</code>의 정의는 달라질 수 있기 때문에 필자는 어떤 것이 필요한 지식이고 필요없는 지식인지를 알려줄 수 없다. 단, 필자가 이야기하고 싶은 것은 공부를 할 때도 <code>자기 주관</code>이 있어야 한다는 것이다.</p><p>이 <code>자기 주관</code>이 무엇인지에 대해 설명하기 위해 구글에서 만든 크로스 플랫폼 프레임워크인 <code>Flutter</code>를 공부하고 있는 분들을 예로 들어볼 수 있겠다. 이걸 공부하는 분들은 Flutter가 갑자기 잘나가서 공부하는 게 아닐 것이다. 애초에 Flutter는 아직 유명하지도 않을 뿐더러 이 프레임워크에서 사용하는 언어는 <code>Dart</code>이기 때문에 사실 상 Flutter가 아니면 써먹을 데도 별로 없다.</p><center><br>  <img src="/2019/08/26/how-does-developer-study/worst_languages.png" width="500"><br>  <small>codementor가 조사한 2018년도에 배우길 추천하지 않는 언어</small><br>  <small>Dart가 당당히 3개 부문 1위를 차지했었다. 물론 2019년에는 많이 좋아졌다.</small><br>  <br><br></center><p>그럼 왜 하는 것일까? 뭐 사람마다 여러가지 이유가 있겠지만 아마도 <code>재밌을 것 같아서</code>, <code>신기하니까</code>, <code>테스트 해보고 싶어서</code> 등의 이유가 많지 않을까? 왜냐면 아직 그렇게 유명하지도 않고, 성능이나 버그 등이 제대로 검증되지 않은 프레임워크이기 때문에 직장에 적용하기도 쉽지 않기 때문이다. 그래서 필자는 아마 이 분들의 개인적인 흥미가 크게 작용했을 것이라고 생각한다.</p><p><code>자기 주관</code>이 있는 사람들은 유행에 크게 흔들리지 않는다. 자신에게 필요한 것을 계속 찾아서 공부하고 자기가 하고 싶은 공부를 한다. 이런 사람들은 본인이 네트워크에 관한 지식이 부족하다고 느끼면 어떤 부분이 부족한 건지 찾아내서 그걸 공부하지, 유행 따라서 <code>쿠버네티스(Kubernetes)</code>부터 공부하지는 않을 것이다.</p><p>하지만 <code>내가 지금 어떤 것이 부족한 상황인가?</code>라는 질문의 해답을 찾기는 꽤 힘든 과정이다. 끊임없이 자기 자신에게 질문하고, 다른 사람과 비교도 해보고 자신이 앞으로 어떤 길을 가고 싶은 지도 생각해봐야 한다. 혹시 지금까지 이런 것에 대한 고찰을 깊게 해본 적이 없다면 한번 생각해보자.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>만약, 수능 쪽집게 강의처럼 <code>공부 잘하는 방법</code>을 기대하고 들어온 독자에게는 미안하지만, 필자는 공부를 잘 하는 방법을 알려줄 수 없다. 공부에는 왕도가 없다. 그냥 꾸준히 하다보면 느는 것이기 때문이다. 대신 필자가 이 포스팅에서 이야기하고 싶었던 것은 <code>공부를 조금이라도 효율적으로 하는 방법</code>이었다.</p><p>위에서 이야기한 두 가지를 한 문장으로 정리해보자면 대략 이런 느낌이다.</p><blockquote><ol><li>내가 이 공부를 왜 해야하는 지 알고 하자</li><li>남들이 다 React한다고 나도 반드시 React를 해야할 필요는 없다.</li></ol></blockquote><p>1번 같은 경우는 위에서 거듭 강조했던 <code>동기부여</code>에 대한 말이다. 공부가 아니라 그 어떤 것을 하던 간에 <code>동기부여</code>가 제대로 되지 않은 일은 재미도 없고 기계적으로 하게 될 수 밖에 없다. 그냥 <code>열심히</code>만 하는데는 한계가 있기 마련이다.</p><p>2번은 사람마다 의견이 조금 갈릴 수 있는데, 일단 필자 생각은 이렇다. 남들이 다 React를 사용할 때 나도 React를 공부한다면 취업은 조금 더 쉬워질 수 있을 것이다. 그러나 대부분의 경우, 특히 프레임워크같은 경우는 유행을 어느 정도 타기 마련이다. 그 시대에서 원하는 패러다임과 여러가지 한계 상황을 반영한 것이기 때문이다. 2~3년 뒤에 React보다 더 좋고 획기적인 프레임워크가 나오지 않을 것이라고 어느 누가 말할 수 있을까?</p><p>사실 여러 커뮤니티에서 자주 보이는 <code>React가 좋아요? Vue가 좋아요?</code>와 같은 질문도 어떤 것을 선택해야 최소 비용을 투자하여 최대 이윤을 얻을 수 있는 지를 고민하는 과정에서 나오는 질문인데, 그냥 아무거나 이름이나 로고가 맘에 드는 거 골라서 공부하자. 어차피 둘 중에 뭘 선택하든 3년 뒤에는 둘 다 버리고 새로운 거 공부해야할 수도 있다.</p><p>중요한 것은 <code>지금 나에게 필요한 것이 무엇인가?</code>이지, 아무 이유없이 단지 사람들이 많이 사용하고 있다거나 사람들이 이 프레임워크가 좋다고 말하는 정도로 그 기술의 공부를 시작하지는 말자. 물론 사람들이 많이 사용하고 있으니까 공부를 하려고 한다는 것도 하나의 이유가 될 수 있다. 필자가 말하는 것은 자기가 결정한 것이 아니라 친구따라 강남가는 식의 결정을 말하는 것이다.</p><p>사람들이 그 프레임워크가 좋다고 말해서 공부해보고 싶다면 적어도 진짜 그 프레임워크가 어떤 점이 좋다고 하는 것인지, 진짜 좋은 것인지 정도를 스스로 판단하고 공부를 시작할 수 있는 주관이 필요하다. 면접볼 때 본인이 어떤 기술을 공부했다고 하면 그걸 왜 공부했냐, 어떤 점이 좋았고 나빴냐고 물어보는 게 괜히 물어보는 것이 아니다.</p><p>글의 서두에서도 한번 언급했지만 이 포스팅은 <code>절대 정답이 아니다</code>. 필자는 필자만의 공부 방법을 찾은 것이고 여러분의 방법은 필자와 같을 수도, 또 다른 방법 일수도 있다. 가장 중요한 것은 여러분 스스로 어떤 것에 흥미를 느끼는 지, 어떨때 집중이 잘되는 사람인지 계속 자기 자신에게 질문하고 답을 찾아가는 것이다. 어쨌든 이 포스팅은 필자의 주관적인 생각이지만, 그래도 개발을 공부할 때 뭐부터 시작해야할지 고민하고 있는 분들에게 도움이 되었길 바란다.</p><p>이상으로 개발자가 공부로 살아남는 방법 포스팅을 마친다.</p>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/08/26/how-does-developer-study/#disqus_thread</comments>
    </item>
    
    <item>
      <title>알고 보면 재밌는 객체 지향 프로그래밍, OOP 흝어보기</title>
      <link>https://evan-moon.github.io/2019/08/24/what-is-object-oriented-programming/</link>
      <guid>https://evan-moon.github.io/2019/08/24/what-is-object-oriented-programming/</guid>
      <pubDate>Sat, 24 Aug 2019 03:35:13 GMT</pubDate>
      <description>
      
        &lt;p&gt;이번 포스팅에서는 &lt;code&gt;객체 지향 프로그래밍(Object-Oriented Programming)&lt;/code&gt;, 줄여서 흔히들 OOP라고 부르는 설계 방법론에 대해서 이야기해보려고 한다. OOP는 프로그래밍의 설계 패러다임 중 하나로, 현실 세계를 프로그램 설계에 반영한다는 개념을 기반으로 접근하는 방법이다. OOP는 90년대 초반부터 유명해지기 시작했지만 아직까지도 전 세계의 많은 프로그래머들이 사용하고 있는 설계 패턴 중 하나이기 때문에 알아둬서 나쁠 건 없다.&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>이번 포스팅에서는 <code>객체 지향 프로그래밍(Object-Oriented Programming)</code>, 줄여서 흔히들 OOP라고 부르는 설계 방법론에 대해서 이야기해보려고 한다. OOP는 프로그래밍의 설계 패러다임 중 하나로, 현실 세계를 프로그램 설계에 반영한다는 개념을 기반으로 접근하는 방법이다. OOP는 90년대 초반부터 유명해지기 시작했지만 아직까지도 전 세계의 많은 프로그래머들이 사용하고 있는 설계 패턴 중 하나이기 때문에 알아둬서 나쁠 건 없다.<br><a id="more"></a></p><h2 id="객체-지향-프로그래밍을-왜-알아야-하나요"><a href="#객체-지향-프로그래밍을-왜-알아야-하나요" class="headerlink" title="객체 지향 프로그래밍을 왜 알아야 하나요?"></a>객체 지향 프로그래밍을 왜 알아야 하나요?</h2><p>사실 OOP가 오랜 기간동안 전 세계에서 사랑받고있는 설계 패턴인 것은 맞지만 최근에는 OOP의 단점을 이야기하며 <code>함수형 프로그래밍</code>과 같은 새로운 설계 패러다임이 각광받기도 했다.<small>(함수형 프로그래밍도 사실 꽤 오래된 패러다임이다)</small> 사실 <code>OOP</code>니 <code>함수형 프로그래밍</code>이니 하는 이런 것들은 결국 <code>프로그램을 어떻게 설계할 것인가?</code>에 대한 방법이기 때문에 당연히 장단점 또한 존재하기 마련이고 시대나 용도에 맞게 개선된 패러다임이 제시되는 것은 자연스러운 흐름이다.</p><p>필자는 개인적으로 아직까지 OOP가 괜찮은 설계 패턴이라고 생각하고 있지만, 여러분은 함수형 프로그래밍이 OOP보다 더 효율적이고 괜찮다고 생각할 수도 있다.</p><p>당연히 어떤 패러다임을 선호하는지는 개인의 자유기 때문에 다르게 생각할 수 있지만, 어떤 기술을 선택할 때는 해당 기술의 장단점과 그 기술을 선택했을 때 얻을 수 있는 것과 잃을 수 있는 것을 제대로 파악하고 있어야 올바른 선택을 할 수 있기 때문에 여러분이 함수형 프로그래밍을 선택한다고 하더라도 OOP가 무엇인지 알고 있어야 하는 것은 마찬가지다.</p><p>또한 OOP는 1990년대 초반부터 2019년인 현재까지도 모던 프로그래밍 설계에 중요한 역할을 하고 있는 개념이다. 아무리 함수형 프로그래밍과 같은 새로운 패러다임이 주목받기는 했지만 아직까지는 OOP가 대부분의 프로그램 설계에 사용되고 있다는 사실은 부정할 수 없는 현실이며, 이게 바로 우리가 OOP를 좋은 싫든 알고 있어야 하는 현실적인 이유 중의 하나이다.<small>(참고로 <code>Java</code>, <code>Python</code>, <code>C++</code> 등 메이저 언어들도 전부 OOP를 지원하는 언어이다.)</small></p><p>그래서 이번 포스팅에서는 OOP가 추구하는 것이 무엇인지, 또 OOP를 이루고 있는 개념들은 무엇이 있는지 간략하게 살펴보려고 한다.</p><h2 id="객체-지향이라는-것은-무엇을-의미하나요"><a href="#객체-지향이라는-것은-무엇을-의미하나요" class="headerlink" title="객체 지향이라는 것은 무엇을 의미하나요?"></a>객체 지향이라는 것은 무엇을 의미하나요?</h2><p>OOP의 의미인 Object-Oriented Programming의 <code>Object-Oriented</code>를 한국말로 그대로 직역하면 <code>객체 지향</code>이다. 여기서 말하는 객체는 현실 세계에 존재하는 하나 하나의 독립된 무언가를 의미한다. 보통 OOP를 배울 때 가장 처음 접하는 개념이 바로 이 <code>객체</code>라는 개념인데, 사실 한번 이해하고나면 꽤 간단한 개념이지만 우리가 평소에 살면서 잘 생각해보지 않는 개념이기 때문에 잘 이해가 되지 않을 수도 있다.</p><p><code>객체</code>를 설명하기 위해서는 <code>클래스</code>라는 개념을 함께 설명해야하는데, 용어가 직관적이지 않아서 그렇지 조금만 생각해보면 누구나 다 이해할 수 있는 개념이다. 일반적으로 이걸 설명할 때 붕어빵과 붕어빵 틀과 같은 비유를 들며 설명하지만 필자는 일반적인 설명과 다르게 <code>클래스는 무엇이고, 객체는 무엇이다</code>라는 방식으로 접근하기보다는 일단 OOP의 포괄적인 설계 개념을 먼저 설명하는 방식으로 접근하도록 하겠다.</p><p>재미없고 복잡한 용어는 일단 제쳐두고 일단 예시를 보면서 의식의 흐름대로 따라와보자.</p><h3 id="클래스와-객체"><a href="#클래스와-객체" class="headerlink" title="클래스와 객체"></a>클래스와 객체</h3><p>필자는 이 포스팅의 서두에서 OOP란 <code>현실 세계를 프로그램의 설계에 반영하는 것</code>이라고 이야기했다. 이 말이 뜻하는 의미를 먼저 이해하고 나면 클래스나 객체 같은 것은 자연스럽게 이해할 수 있으니 먼저 OOP가 왜 현실 세계를 반영한 설계 방식이라고 하는 지를 먼저 알아보도록 하자.</p><p>뭐 여러가지 예시가 있겠지만 우리가 일상적으로 사용하고 있는 물건을 예로 드는 것이 좀 더 와닿을테니 필자는 <code>스마트폰</code>을 예로 들어서 설명을 진행하려고 한다. 필자는 애플에서 만든 <code>아이폰7</code>이라는 기종을 사용하고 있기 때문에 아이폰7을 예시로 설명을 시작하겠다.</p><center><br>  <img src="/2019/08/24/what-is-object-oriented-programming/iphone7.jpg" width="350"><br>  <br><br></center><p>먼저, 우리가 <code>아이폰7</code>이라는 것을 프로그램으로 구현하고 싶다면 제일 먼저 아이폰7이 무엇인지부터 정의해야한다. 너무 어렵게 생각할 필요없다. 진짜로 프로그램을 짜는 것이 아니기 때문에 대충 정의해도 된다.</p><p>필자가 지금 바로 생각해낸 아이폰7은 약간 동글동글한 바디를 가지고 있고 햅틱 엔진이 내장된 홈 버튼을 가지고 있으며, 시리즈 최초로 3.5mm 이어폰 단자가 없어진 <code>아이폰</code> 시리즈라는 것이다.<small>(개인적으로 이어폰 단자 좀 다시 넣어줬으면 한다…)</small></p><p>우리는 여기서 한발짝 더 나아가서 아이폰7의 상위 개념인 <code>아이폰</code>에 대해서도 정의해볼 수 있다. 결국 아이폰7은 아이폰이라는 개념을 기반으로 확장된 개념이기 때문이다.</p><p>그럼 <code>아이폰</code>은 무엇일까? 아이폰은 애플에서 제조한 스마트폰으로, iOS를 사용하고 있는 스마트폰 시리즈의 명칭이다. 이때 아이폰은 아이폰7 외에도 아이폰X, 아이폰8, 아이폰 SE 등 수많은 아이폰 시리즈의 제품들을 포함하는 좀 더 포괄적인 개념이다.</p><p>일상 속에서 우리가 친구한테 <code>너 핸드폰 뭐 써?</code>라고 물어봤을 때 친구가 <code>아이폰</code> 또는 <code>갤럭시</code>라고 대답하는 경우를 생각해보자. 이때 친구는 자신이 사용하는 스마트폰이 <code>아이폰X</code>든 <code>갤럭시 S10</code>이든 간에 무의식적으로 <code>아이폰</code>이나 <code>갤럭시</code>라는 좀 더 포괄적인 개념을 떠올리고 하위 개념들을 그룹핑한 것이다. 그 정도로 이런 접근 방법은 우리에게 이미 일상적이고 익숙한 방법이다. 어렵게 생각하지 말자.</p><center><br>  <img src="/2019/08/24/what-is-object-oriented-programming/iphones.jpg" width="500"><br>  <small>아이폰7의 상위 개념인 아이폰은 모든 아이폰을 포괄할 수 있는 개념이 된다.</small><br>  <br><br></center><p>여기서 가장 중요한 점은 하위 개념인 <code>아이폰7</code>은 상위 개념인 <code>아이폰</code>의 특징을 모두 가지고 있다는 것이다. 마찬가지로 아이폰의 다른 하위 개념인 아이폰X이나 아이폰 SE와 같은 아이폰 시리즈들도 아이폰의 모든 특징을 가지고 있을 것이다. 여기서 끝내면 아쉬우니 한번만 더 해보도록 하자.</p><p>아이폰의 상위 개념은 무엇일까? 아이폰은 애플에서 제조하고 iOS를 사용하는 <code>스마트폰</code>의 명칭이다. 즉, 아이폰의 상위 개념은 <code>스마트폰</code>이라고 할 수 있다. 이때 스마트폰이라는 개념은 아이폰 뿐만 아니라 갤럭시, 샤오미, 베가와 같은 다른 스마트폰들까지 모두 포괄하는 개념일테고, 마찬가지로 이 스마트폰이라는 개념의 하위 개념들은 모두 스마트폰의 특징을 그대로 가지며 자신들만의 고유한 특징을 추가적으로 가질 수 있을 것이다.</p><center><br>  <img src="/2019/08/24/what-is-object-oriented-programming/smartphones.jpg" width="500"><br>  <small>스마트폰이라는 개념은 아이폰, 갤럭시, 샤오미 등 모든 스마트폰을 포괄할 수 있는 개념이 된다.</small><br>  <br><br></center><p>이런 식으로 우리는 <code>아이폰7</code>이라는 개념에서 출발하여 계속해서 상위 개념을 정의해나갈 수 있다.</p><blockquote><p>아이폰7 -&gt; 아이폰 -&gt; 스마트폰 -&gt; 휴대전화 -&gt; 무선 전화기 -&gt; 전화기 -&gt; 통신 기기 -&gt; 기계…</p></blockquote><p>결국 이렇게 상위 개념을 추적해나가면서 설계하는 것이 OOP의 기초이고, 이때 <code>아이폰7</code>, <code>아이폰</code>과 같은 개념들을 <code>클래스(Class)</code>라고 부르는 것이다. 그리고 방금 했던 것처럼 상위 개념을 만들어나가는 행위 자체를 <code>추상화(Abstraction)</code>라고 한다. 추상화는 밑에서 다시 한번 설명할테니 일단 지금은 클래스라는 개념만 기억하도록 하자.</p><p>그럼 <code>객체(Object)</code>는 무엇일까? 필자는 방금 클래스를 설명하면서 <code>개념</code>이라는 단어를 굉장히 많이 사용했다. 말 그대로 클래스의 역할은 어떠한 개념을 의미하는 것이다. 하지만 개념이라는 것 그 자체 만으로는 현실의 물건이 될 수는 없는 법이다.</p><p>잘 생각해보면 아이폰7이라는 것 또한 그냥 어떠한 제품 라인의 이름이다. 어떤 고유한 물건의 이름이 아니라는 것이다. 여기서 필자가 말하는 <code>고유하다</code>라는 의미는 전 세계에 단 한개만 존재하는 수준의 고유함이다. 당장 내 아이폰7과 친구의 아이폰7만 봐도 실제로는 다른 아이폰7이지 않은가?</p><p>즉, 아이폰7이라는 클래스는 어떠한 실체가 있는 게 아니라는 것이다. 아이폰7 클래스에는 CPU, 디스플레이 해상도, 메모리와 같은 사양이 정의되어 있을 것이고 이를 기반으로 공장에서 <code>실제 아이폰7</code>을 찍어내고 일련번호를 부여한 후 출고하고나면 그제서야 우리 손에 잡을 수 있는 물건인 아이폰7이 되는 것이다. 이때 생산된 아이폰7에는 고유한 ID인 일련번호가 부여되었기 때문에 우리는 전 세계에 일련번호가 <code>1234</code>인 아이폰7은 단 하나밖에 없다는 사실을 알 수 있다.</p><p>이때 이렇게 생산된 아이폰7들을 <code>객체</code>라고 할 수 있다.</p><blockquote><p>즉, <code>클래스</code>는 일종의 설계도이고 이것을 사용하여 우리가 사용할 수 있는 실제 물건으로 만들어내는 행위가 반드시 필요하다. 그리고 <code>객체</code>는 클래스를 사용하여 생성한 실제 물건이다.</p></blockquote><p>이러한 OOP의 설계 접근 방식으로 우리의 일상 속에 보이는 대부분의 개념들을 추상화할 수 있는데, 그냥 평소에 보이는 모든 것들을 이렇게 추상화해보는 연습을 하면 나름 재미도 있다. 몇가지 예를 들어보겠다.</p><hr><ul><li>소나타 -&gt; 중형 세단 -&gt; 세단 -&gt; 자동차 -&gt; 이동수단</li><li>문동욱 -&gt; 남자 -&gt; 인간 -&gt; 영장류 -&gt; 포유류 -&gt; 동물</li><li>오버워치 -&gt; 블리자드가 만든 FPS 게임 -&gt; FPS 게임 -&gt; 게임</li></ul><hr><p>실제로 우리 일상 속에 존재하는 거의 대부분의 개념은 이런 추상화 기법으로 어느 정도 정리할 수 있다. 눈에 보이는 생활 속의 물건들을 추상화 해보는 것은 따로 시간을 내지 않아도 일상 속에서 할 수 있는 좋은 연습 방법이니 한번 해보기를 추천한다. 이 방법이 익숙해지면 카페에 가서 커피를 마시면서도 머릿 속에서 작은 카페를 만들어 볼 수도 있다.<small>(데이트 할때는 하지 맙시다)</small></p><p>결국 <code>객체 지향</code>이라는 말의 의미는 이렇게 클래스를 사용하여 추상적인 개념들을 정의하고, 그 클래스를 사용하여 실제로 사용할 객체를 만들어냄으로써 현실 세계의 모든 것을 표현할 수 있다는 것에서 출발하는 것이다.</p><h3 id="추상화에-대해서-조금-더-깊이-생각해보자"><a href="#추상화에-대해서-조금-더-깊이-생각해보자" class="headerlink" title="추상화에 대해서 조금 더 깊이 생각해보자"></a>추상화에 대해서 조금 더 깊이 생각해보자</h3><p>방금 우리는 아이폰7부터 시작해서 상위 개념을 이끌어내는 간단한 추상화를 경험해보았다. 하지만 우리가 방금 저 예시를 진행할 때는 그렇게까지 깊은 고민이 없었을 것이다. 왜냐면 아이폰이나 스마트폰 같은 개념은 이미 우리에게 상당히 친숙한 개념이기 때문에 깊이 고민할 필요없이 이미 여러분의 머릿속에 어느 정도 추상화가 되어 정리된 상태였기 때문이다.</p><p>하지만 실제로 프로그램 설계에 OOP를 사용할 때에는 우리에게 친숙한 아이폰과 같은 개념을 사용하는 것이 아니라 개발자가 이 개념 자체부터 정의해야하는 경우가 많다. 이때 추상화가 어떤 것인지 정확히 이해하고 있지 않다면 자칫 이상한 방향으로 클래스를 설계할 수 있기 때문에 정확히 추상화가 무엇인지 짚고 넘어가도록 하겠다.</p><p><code>추상</code>이라는 단어의 뜻부터 한번 생각해보자. <code>추상</code>은 어떠한 존재가 가지고 있는 여러가지의 속성 중에서 특정한 속성을 가려내어 포착하는 것을 의미한다. 대표적인 추상파 화가 중 한명인 피카소가 소를 점점 추상화하며 그려가는 과정을 한번 살펴보면 추상화가 어떤 것인지 조금 더 이해가 된다.</p><center><br>  <img src="/2019/08/24/what-is-object-oriented-programming/picasso_bull.jpg" width="500"><br>  <small>피카소가 소를 추상화하는 과정</small><br>  <br><br></center><p>이렇듯, 추상화라는 것은 그 존재가 가지고 있는 가장 특징적인 속성들을 파악해나가는 것을 의미한다.</p><p>우리가 방금 전 아이폰7의 상위 개념인 아이폰을 떠올리게 되는 과정은 꽤나 직관적으로 진행되었지만 사실 추상화를 그렇게 직관적으로 접근하려고 하면 더 방향을 잡기가 힘들다. 원래대로라면 아이폰이라는 상위 개념을 만들고자 했을 때 아이폰7 뿐만이 아니라 다른 아이폰 시리즈들까지 모두 포함할 수 있는 아이폰들의 공통된 특성을 먼저 찾는 것이 올바른 순서이다. 이렇게 만들어진 올바른 상위 개념의 속성은 그 개념의 하위 개념들에게 공통적으로 적용할 수 있는 속성이 된다.</p><blockquote><p><strong>상위 개념</strong><br>아이폰: 애플에서 만든 iOS 기반의 스마트폰</p><p><strong>아이폰 클래스 기반의 하위 개념</strong><br>아이폰X: 애플에서 만든 iOS 기반의 스마트폰이며, 홈 버튼이 없고 베젤리스 디자인이 적용된 아이폰<br>아이폰7: 애플에서 만든 iOS 기반의 스마트폰이며, 햅틱 엔진이 내장된 홈 버튼을 가지고 있는 아이폰.<br>아이폰 SE: 애플에서 만든 iOS 기반의 스마트폰이며, 사이즈가 작아서 한 손에 잡을 수 있는 아이폰.</p></blockquote><p>이 예시에서 볼 수 있듯이 하위 개념들은 상위 개념이 가지고 있는 모든 속성을 그대로 물려받는데, 그래서 이 과정을 <code>상속(Inheritance)</code>이라고 한다. 이 상속에 관해서는 밑에서 다시 자세하게 살펴보도록 하겠다.</p><h2 id="객체-지향-프로그래밍의-3대장"><a href="#객체-지향-프로그래밍의-3대장" class="headerlink" title="객체 지향 프로그래밍의 3대장"></a>객체 지향 프로그래밍의 3대장</h2><p>방금까지 설명한 클래스, 객체, 추상화는 OOP를 이루는 근본적인 개념들이다. 필자는 여기서 좀 더 나아가서 OOP를 지원하는 언어들이 기본적으로 갖추고 있는 몇가지 개념을 더 설명하려고 한다. OOP는 그 특성 상 클래스와 객체를 기반으로 <code>조립</code>하는 형태로 프로그램을 설계하게 되는데 이때 이 조립을 더 원활하게 하기 위해서 나온 유용한 몇가지 개념들이 있다.</p><p>하지만 이 개념들은 JavaScript에는 구현되지 않은 개념도 있으므로 이번에는 <code>Java</code>를 사용해서 예제를 진행하도록 하겠다. 단편적인 문법만 보면 그렇게 이질감 느껴질 정도로 차이가 크지 않기 때문에 JavaScript만 하셨던 분들도 아마 금방 이해할 수 있을 것이다. 참고로 TypeScript도 OOP를 지원하기는 하지만 이거 세팅하는 것보다 그냥 Java 컴파일하는게 편하기 때문에 Java로 간다.</p><p>그럼 이제 객체 지향의 3대장이라고 불리는 <code>상속</code>과 <code>캡슐화</code>, 그리고 <code>다형성</code>에 대해서 간단하게 알아보도록 하자.</p><h3 id="상속"><a href="#상속" class="headerlink" title="상속"></a>상속</h3><p><code>상속(Inheritance)</code>은 방금 전 추상화에 대한 설명을 진행하면서 한번 짚고 넘어갔던 개념이다. OOP를 제공하는 많은 프로그래밍 언어에서 상속은 <code>extends</code>라는 예약어로 표현되는데, 하위 개념 입장에서 보면 상위 개념의 속성을 물려받는 것이지만 반대로 상위 개념 입장에서 보면 자신의 속성들이 하위 개념으로 넘어가면서 확장되는 것이므로 이 말도 맞다. 그럼 이제 상속이 어떻게 이루어지는지 코드로 살펴보도록 하자.</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IPhone</span> </span>&#123;</span><br><span class="line">    String manufacturer = <span class="hljs-string">"apple"</span>;</span><br><span class="line">    String os = <span class="hljs-string">"iOS"</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IPhone7</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IPhone</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> version = <span class="hljs-number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IPhone7 myIPhone7 = <span class="hljs-keyword">new</span> IPhone7();</span><br><span class="line"></span><br><span class="line">        System.out.println(myIPhone7.manufacturer);</span><br><span class="line">        System.out.println(myIPhone7.os);</span><br><span class="line">        System.out.println(myIPhone7.version);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apple</span><br><span class="line">iOS</span><br><span class="line">7</span><br></pre></td></tr></table></figure><p><code>IPhone7</code> 클래스를 생성할 때 <code>extends</code> 예약어를 사용하여 <code>IPhone</code> 클래스를 상속받았다. <code>IPhone7</code> 클래스에는 <code>manufacturer</code>와 <code>os</code> 속성이 명시적으로 선언되지 않았지만 부모 클래스인 <code>IPhone</code> 클래스의 속성을 그대로 물려받은 것을 볼 수 있다.</p><p>마찬가지로 이 상황에서 <code>IPhoneX</code> 클래스를 새로 만들어야 할때도 <code>IPhone</code> 클래스를 그대로 다시 사용할 수 있다.</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IPhoneX</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IPhone</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> version = <span class="hljs-number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>즉, 추상화가 잘된 클래스를 하나만 만들어놓는다면 그와 비슷한 속성이 필요한 다른 클래스를 생성할 때 그대로 재사용할 수 있다는 말이다. 그리고 만약 아이폰 시리즈 전체에 걸친 변경사항이 생겼을 때도 <code>IPhone7</code>, <code>IPhoneX</code>와 같은 클래스는 건드릴 필요없이 <code>IPhone</code> 클래스 하나만 고치면 이 클래스를 상속받은 모든 하위 클래스에도 자동으로 적용되므로 개발 기간도 단축시킬 수 있고 휴먼 에러가 발생할 확률도 줄일 수 있다.</p><p>하지만 여기서 만약 요구사항이 변경되어서 갤럭시 시리즈를 만들어야한다면 어떻게 될까? 갤럭시 시리즈는 iOS가 아니라 Android를 사용하고, 제조사도 애플이 아니라 삼성이기 때문에 우리가 방금 만든 <code>IPhone</code> 클래스를 사용할 수는 없다. 이때 우리는 <code>IPhone</code> 클래스를 그대로 냅두고 그냥 <code>Galaxy</code> 클래스를 새로 만들 수도 있지만 <code>SmartPhone</code>이라는 한단계 더 상위 개념을 만드는 방향으로 가닥을 잡을 수도 있다.</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmartPhone</span> </span>&#123;</span><br><span class="line">    SmartPhone (String manufacturer, String os) &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.manufacturer = manufacturer;</span><br><span class="line">        <span class="hljs-keyword">this</span>.os = os;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IPhone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SmartPhone</span> </span>&#123;</span><br><span class="line">    IPhone () &#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(<span class="hljs-string">"apple"</span>, <span class="hljs-string">"iOS"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Galaxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SmartPhone</span> </span>&#123;</span><br><span class="line">    Galaxy () &#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(<span class="hljs-string">"samsung"</span>, <span class="hljs-string">"android"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IPhone7</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IPhone</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> version = <span class="hljs-number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GalaxyS10</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Galaxy</span> </span>&#123;</span><br><span class="line">    String version = <span class="hljs-string">"s10"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드에서 <code>super</code> 메소드는 부모 클래스의 생성자를 호출하는 메소드이다. 부모 클래스를 <code>Super Class</code>, 자식 클래스를 <code>Sub Class</code>라고 부르기도 하기 때문에 부모와 관련된 키워드 역시 <code>super</code>를 사용하는 것이다.</p><p>그리고 이때 자식 클래스인 <code>IPhone7</code>이나 <code>GalaxyS10</code> 클래스가 부모 클래스의 <code>manufacturer</code>나 <code>os</code> 속성을 덮어쓰게 할 수도 있는데, 이러한 작업을 <code>오버라이딩(Overriding)</code>이라고 한다. 안드로이드 개발을 하다보면 밥먹듯이 쓰는 <code>@Override</code> 데코레이터도 부모 클래스의 메소드를 덮어쓰는 방식으로 세부 구현을 진행하는 것이다.</p><p>이러한 OOP의 클래스 의존관계는 클래스의 재사용성을 높혀주는 방법이기도 하지만, 너무 클래스의 상속 관계가 복잡해지게 되면 개발자가 전체 구조를 파악하기가 힘들다는 단점도 가지고 있으므로 개발자가 확실한 의도를 가지고 적당한 선에서 상속 관계를 설계하는 것이 중요하다.<small>(근데 이 적당한 선의 기준이 개발자마다 다 다르다는 게 함정)</small></p><h3 id="캡슐화"><a href="#캡슐화" class="headerlink" title="캡슐화"></a>캡슐화</h3><p><code>캡슐화(Encapsulation)</code>는 어떠한 클래스를 사용할 때 내부 동작이 어떻게 돌아가는지 모르더라도 사용법만 알면 쓸 수 있도록 클래스 내부를 감추는 기법이다. 클래스를 캡슐화 함으로써 클래스를 사용하는 쪽에서는 머리 아프게 해당 클래스의 내부 로직을 파악할 필요가 없어진다. 또한 클래스 내에서 사용되는 변수나 메소드를 원하는 대로 감출 수 있기 때문에 필요 이상의 변수나 메소드가 클래스 외부로 노출되는 것을 방어햐여 보안도 챙길 수 있다.</p><p>이렇게 클래스 내부의 데이터를 감추는 것을 <code>정보 은닉(Information Hiding)</code>이라고 하며, 보통 <code>public</code>, <code>private</code>, <code>protected</code> 같은 접근제한자를 사용하여 원하는 정보를 감추거나 노출시킬 수 있다.</p><figure class="highlight java hljs"><figcaption><span>Capsulation.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">public</span> String name;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;</span><br><span class="line">    <span class="hljs-keyword">protected</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span> <span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, String address)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">        <span class="hljs-keyword">this</span>.age = age;</span><br><span class="line">        <span class="hljs-keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자 이렇게 간단한 클래스를 하나 만들어보았다. <code>Person</code> 클래스는 생성자의 인자로 들어온 값들을 자신의 멤버 변수에 할당하는데, 이 멤버 변수들은 각각 <code>public</code>, <code>private</code>, <code>protected</code>의 접근제한자를 가지고 있는 친구들이다. 그럼 한번 객체를 생성해보고 이 친구들의 멤버 변수에 접근이 가능한지를 알아보자.</p><figure class="highlight java hljs"><figcaption><span>Capsulation.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CapsulationTest</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person evan = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"Evan"</span>, <span class="hljs-number">29</span>, <span class="hljs-string">"Seoul"</span>);</span><br><span class="line">        System.out.println(evan.name);</span><br><span class="line">        System.out.println(evan.age);</span><br><span class="line">        System.out.println(evan.address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자, 여기까지 직접 작성해보면 알겠지만 Java는 컴파일 언어이기 때문에 굳이 실행시켜보지 않더라도 IDE에서 이미 알아서 다 분석을 끝내고 빨간줄을 쫙쫙 그어주었을 것이다.</p><center><br>  <img src="/2019/08/24/what-is-object-oriented-programming/private_error.png" width="500"><br>  <br><br></center><p>에러가 난 부분은 <code>private</code> 접근제한자를 사용한 멤버변수인 <code>age</code>이다. 이처럼 <code>private</code> 접근제한자를 사용하여 선언된 멤버 변수나 메소드는 클래스 내부에서만 사용될 수 있고 외부로는 아예 노출 자체가 되지 않는다. <code>public</code>과 <code>protected</code>를 사용하여 선언한 멤버 변수인 <code>name</code>과 <code>address</code>는 정상적으로 접근이 가능한 상태이다.</p><p><code>public</code> 같은 경우는 이름만 봐도 클래스 외부에서 마음대로 접근할 수 있도록 열어주는 접근제한자라는 것을 알 수 있지만, <code>protected</code>가 접근이 가능한 것은 조금 이상하다. 이름만 보면 왠지 이 친구도 <code>private</code>처럼 접근이 막혀야할 것 같은데 왜 외부에서 접근이 가능한 것일까?</p><p><code>protected</code> 접근제한자는 해당 클래스를 상속받은 클래스와 같은 패키지 안에 있는 클래스가 아니면 모두 접근을 막는 접근제한자인데, 위의 예시의 경우 필자는 <code>Person</code> 클래스와 <code>CapsulationTest</code> 클래스를 같은 파일에 선언했으므로 같은 패키지로 인식되어 접근이 가능했던 것이다.</p><p>그럼 <code>Person</code> 클래스를 다른 패키지로 분리해내면 어떻게 될까? 테스트 해보기 위해 먼저 <code>MyPacks</code>라는 디렉토리를 생성하고 그 안에 <code>Person.java</code> 파일을 따로 분리하여 별도의 패키지로 선언해주겠다.</p><figure class="highlight java hljs"><figcaption><span>MyPacks/Person.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> MyPacks;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">public</span> String name;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;</span><br><span class="line">    <span class="hljs-keyword">protected</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span> <span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, String address)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">        <span class="hljs-keyword">this</span>.age = age;</span><br><span class="line">        <span class="hljs-keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java hljs"><figcaption><span>Capsulation.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> MyPacks.Person;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CapsulationTest</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person evan = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"Evan"</span>, <span class="hljs-number">29</span>, <span class="hljs-string">"Seoul"</span>);</span><br><span class="line">        System.out.println(evan.name);</span><br><span class="line">        System.out.println(evan.address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 <code>Person</code> 클래스를 별도의 패키지로 분리하면 이제 <code>evan.address</code>에도 빨간 줄이 쫙 그어진다.</p><center><br>  <img src="/2019/08/24/what-is-object-oriented-programming/protected_error.png" width="500"><br>  <br><br></center><p>이렇게 외부 패키지로 불러온 클래스 내부 내의 <code>protected</code> 멤버 변수나 메소드에는 바로 접근할 수 없다. 그러나 Person 클래스를 상속한다면 외부 패키지인지 아닌지 여부와 상관 없이 자식 클래스 내에서는 <code>protected</code> 멤버에 접근이 가능하다.</p><figure class="highlight java hljs"><figcaption><span>Capsulation.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> MyPacks.Person;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CapsulationTest</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Evan evan = <span class="hljs-keyword">new</span> Evan();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Evan</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;</span><br><span class="line">    Evan () &#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(<span class="hljs-string">"Evan"</span>, <span class="hljs-number">29</span>, <span class="hljs-string">"Seoul"</span>);</span><br><span class="line">        System.out.println(<span class="hljs-keyword">this</span>.address);</span><br><span class="line">        System.out.println(<span class="hljs-keyword">super</span>.address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Seoul</span><br><span class="line">Seoul</span><br></pre></td></tr></table></figure><p>접근제한자는 Java 뿐만 아니라 TypeScript, Ruby, C++ 등과 같이 OOP를 지원하는 많은 프로그래밍 언어들도 가지고 있는 기능이므로 이 개념을 잘 알아두면 클래스를 설계할 때 원하는 정보만 노출시키고 원하지 않는 정보는 감추는 방법을 사용하여 보안도 지킬 수 있고 클래스를 가져다 쓰는 사용자로 하여금 쓸데없는 고민을 안하게 해줄 수도 있다.</p><h3 id="다형성"><a href="#다형성" class="headerlink" title="다형성"></a>다형성</h3><p><code>다형성(Polymorphism)</code>은 어떤 하나의 변수명이나 함수명이 상황에 따라서 다르게 해석될 수 있는 것을 의미한다. 다형성은 어떤 한가지 기능을 의미하는 것이 아니라 개념이기 때문에 여러가지 방법으로 표현할 수 있다.</p><p>Java에서 다형성을 위한 대표적인 기능은 바로 <code>추상 클래스(Abstract Class)</code>와 <code>인터페이스(Interface)</code>, 그리고 <code>Overloading</code>이 있다. 추상 클래스와 인터페이스는 사실 그 용도가 조금 다르지만 필자가 예로 들 간단한 예시에서는 그 차이를 크게 느끼기 힘들기도 하고 무엇보다 이 포스팅은 Java 포스팅이 아니라 단순히 <code>다형성</code>을 설명하기 위함이므로 필자는 이 중 <code>추상 클래스</code>만을 사용할 것이다.</p><p>그럼 이 기능들이 어떤 역할을 하는 지 살펴보면서 다형성이 무엇인가를 좀 더 자세히 알아보도록 하자. 먼저, 추상 클래스를 사용하여 다형성을 만족시키는 예시를 먼저 설명할텐데, 사실 다형성이라는 단어를 모르고 있던 분들이라도 자신도 모르게 이런 설계 패턴을 사용하고 있었을 수도 있을 정도로 기본적인 예시이다.</p><h4 id="추상-클래스를-사용한-다형성-구현"><a href="#추상-클래스를-사용한-다형성-구현" class="headerlink" title="추상 클래스를 사용한 다형성 구현"></a>추상 클래스를 사용한 다형성 구현</h4><p>추상 클래스는 Java에서 다형성을 만족시키기 위해 자주 사용되는 대표적인 기능이다. 말로만 설명하면 재미가 없으니 한번 코드를 직접 눈으로 보는 것이 좋은데, 필자는 오버워치를 좋아하기 때문에 추상 클래스에 대한 예시도 오버워치를 가져와서 설명하겠다.</p><center><br>  <img src="/2019/08/24/what-is-object-oriented-programming/overwatch.jpg" width="500"><br>  <small>갓겜 고오급 시계</small><br>  <br><br></center><p>자, 필자는 이제 오버워치의 여러 영웅들을 클래스로 만드려고 한다. 오버워치의 영웅들은 공통적으로 <code>궁극기 게이지가 찼을 때 Q 버튼을 누르면 궁극기가 발동된다</code>라는 기능을 가지고 있다. 하지만 오버워치의 영웅들은 각자 특색에 맞게 다른 궁극기를 가지고 있는데, 라인하르트는 망치를 내리치며 다른 영웅들을 기절시키고 맥크리는 시야에 보이는 여러 영웅에게 동시에 헤드샷을 날릴 수 있으며 메이는 로봇을 던져서 일정 범위 안의 영웅들을 얼린다.</p><p>이런 경우 다형성을 가지지 않은 오버워치 영웅 클래스는 다음과 같은 모습을 보일 것이다.</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hero</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">public</span> String name;</span><br><span class="line">    Hero (String name) &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reinhardt</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Hero</span> </span>&#123;</span><br><span class="line">    Reinhardt () &#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(<span class="hljs-string">"reinhardt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attackHammer</span> <span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"망치 나가신다!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McCree</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Hero</span> </span>&#123;</span><br><span class="line">    McCree () &#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(<span class="hljs-string">"mccree"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attackGun</span> <span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"석양이 진다. 빵야빵야"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mei</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Hero</span> </span>&#123;</span><br><span class="line">    Mei () &#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(<span class="hljs-string">"mei"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">throwRobot</span> <span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"꼼짝 마! 움직이지 마세요!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이때 만약 우리가 <code>Hero</code> 클래스를 상속받은 영웅 클래스들의 궁극기를 발동시키고 싶다면 어떻게 해야할까? 안봐도 뻔하겠지만 눈물나는 <code>if</code>문 또는 <code>switch</code>문의 향연이 펼쳐질 것이다.</p><p>모든 영웅들의 궁극기 발동 메소드의 이름이 다르기 때문에 달리 방도가 없다. 그리고 추가적으로 <code>Hero</code> 클래스에는 궁극기 발동 메소드가 없기 때문에 객체를 해당 영웅의 클래스로 형변환 해줘야하는 불편한 작업도 해야한다.</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mei myMei = <span class="hljs-keyword">new</span> Mei();</span><br><span class="line">        Reinhardt myReinhardt = <span class="hljs-keyword">new</span> Reinhardt();</span><br><span class="line">        McCree myMcCree = <span class="hljs-keyword">new</span> McCree();</span><br><span class="line"></span><br><span class="line">        Main.doUltimate(myMei);</span><br><span class="line">        Main.doUltimate(myReinhardt);</span><br><span class="line">        Main.doUltimate(myMcCree);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doUltimate</span> <span class="hljs-params">(Hero hero)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (hero <span class="hljs-keyword">instanceof</span> Reinhardt) &#123;</span><br><span class="line">            Reinhardt myHero = (Reinhardt)hero;</span><br><span class="line">            myHero.attackHammer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hero <span class="hljs-keyword">instanceof</span> McCree) &#123;</span><br><span class="line">            McCree myHero = (McCree)hero;</span><br><span class="line">            myHero.attackGun();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hero <span class="hljs-keyword">instanceof</span> Mei) &#123;</span><br><span class="line">            Mei myHero = (Mei)hero;</span><br><span class="line">            myHero.throwRobot();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">꼼짝 마! 움직이지 마세요!</span><br><span class="line">망치 나가신다!</span><br><span class="line">석양이 진다. 빵야빵야</span><br></pre></td></tr></table></figure><p>여기에 영웅이 더 추가된다면 영웅의 종류 만큼 분기의 개수도 늘어날 것이고, 무엇보다 <code>Mei myHero = (Mei)hero</code>처럼 굳이 새로운 변수를 선언하면서 사용하고 있는 걸 보자니 마음이 한켠이 먹먹해져온다. 다형성은 바로 이럴 때 우리를 행복하게 만들어 줄 수 있는 단비와 같은 개념이다.</p><p>자, 아까 위에서 필자는 다형성의 개념을 <code>어떤 하나의 변수명이나 함수명이 상황에 따라서 다르게 해석될 수 있는 것</code>이라고 했다. 그렇다면 이 경우 우리는 영웅들의 궁극기 호출 메소드명을 <code>ultimate</code>로 통일하되, 이 메소드를 호출했을 때 실행되는 코드는 영웅에 따라 달라지도록 만들면 다형성을 만족시킬 수 있는 것이다.</p><p>이런 경우 그냥 <code>Hero</code> 클래스를 상속받은 영웅 클래스들에게 직접 하나하나 <code>ultimate</code>라는 메소드를 선언할 수도 있지만, 그렇게 되면 개발자가 실수할 확률이 존재한다.<small>(특히 오타로 인한 실수가 가장 많을 것이다)</small> 그래서 Java는 개발자가 특정 메소드를 강제로 구현하도록 만들어주는 기능을 제공한다.</p><p>그 기능이 바로 <code>추상 클래스(Abstract Class)</code>와 <code>인터페이스(Interface)</code>인 것이다. 필자는 위에서 한번 이야기 했듯이 이 중 <code>추상 클래스</code>만을 사용하여 예제를 진행할 것이다.</p><p>그래도 혹시 이 두 기능이 뭐가 다른지 궁금하신 분이 있을 것 같으니 최대한 간단히만 설명하고 넘어가자면, <code>추상 클래스</code>는 어떤 클래스의 기능을 그대로 사용하면서 그 기능을 확장하고 싶을 때 사용하는 것이고 <code>인터페이스</code>는 아무런 구현체가 없는 그냥 껍데기만 구현하는 것이다. 그렇기 때문에 인터페이스에는 자세한 메소드의 구현체가 들어갈 수 없지만 추상 클래스는 자체적인 메소드의 구현체를 가질 수도 있다.<small>(Java 8부터는 default 키워드를 사용하여 인터페이스에도 메소드 구현체를 넣을 수 있게 변경되긴했다. 덕분에 구분이 더 애매해짐.)</small></p><p>이 예제의 <code>Hero</code> 클래스는 <code>name</code> 멤버 변수를 생성자로부터 받아서 자신의 멤버 변수로 추가하는 기능을 가지고 있기 때문에 추상 클래스를 사용하는 것이 더 적절하다. 그럼 이제 추상 클래스를 사용하여 <code>ultimate</code> 메소드의 구현을 강제해보도록 하자.</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hero</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">public</span> String name;</span><br><span class="line">    Hero (String name) &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 내부 구현체가 없는 추상 메소드를 선언한다.</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ultimate</span> <span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reinhardt</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Hero</span> </span>&#123;</span><br><span class="line">    Reinhardt () &#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(<span class="hljs-string">"reinhardt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ultimate</span> <span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"망치 나가신다!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McCree</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Hero</span> </span>&#123;</span><br><span class="line">    McCree () &#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(<span class="hljs-string">"mccree"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ultimate</span> <span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"석양이 진다. 빵야빵야"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mei</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Hero</span> </span>&#123;</span><br><span class="line">    Mei () &#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(<span class="hljs-string">"mei"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ultimate</span> <span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"꼼짝 마! 움직이지 마세요!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 추상 클래스인 <code>Hero</code>를 상속받은 영웅 클래스들은 무조건 <code>ultimate</code> 메소드를 구현해야한다. 이렇게 메소드명이 통일되면 영웅 클래스를 가져다 쓰는 입장에서는 궁극기를 발동시키고 싶을 때 어떤 메소드를 호출해야할지 이제 더 이상 고민할 필요가 없다.</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mei myMei = <span class="hljs-keyword">new</span> Mei();</span><br><span class="line">        Reinhardt myReinhardt = <span class="hljs-keyword">new</span> Reinhardt();</span><br><span class="line">        McCree myMcCree = <span class="hljs-keyword">new</span> McCree();</span><br><span class="line"></span><br><span class="line">        Main.doUltimate(myMei);</span><br><span class="line">        Main.doUltimate(myReinhardt);</span><br><span class="line">        Main.doUltimate(myMcCree);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doUltimate</span> <span class="hljs-params">(Hero hero)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">// Hero 클래스를 상속받은 클래스는</span></span><br><span class="line">        <span class="hljs-comment">// 무조건 ultimate 메소드를 가지고 있다는 것이 보장된다.</span></span><br><span class="line">        hero.ultimate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>어떤가? 코드가 훨씬 심플해지지 않았는가? 추상 메소드를 사용하여 클래스 내부의 <code>ultimate</code>라는 메소드의 구현을 강제했기 때문에 <code>Hero</code> 클래스를 상속받은 영웅 클래스에 해당 메소드가 없을 확률은 <code>0%</code>이다. 그렇기 때문에 사용하는 입장에서는 깊은 고민없이 안심하고 <code>ultimate</code> 메소드를 호출할 수 있다.</p><p>또한 <code>ultimate</code> 메소드는 모든 영웅 클래스들이 가지고 있는 메소드이지만 내부 구현은 전부 다르기 때문에 발동하는 스킬 또한 영웅 별로 다르게 나올 것이다. 이런 것을 바로 <code>다형성</code>이라고 하는 것이다.</p><h4 id="오버로딩을-사용한-다형성-구현"><a href="#오버로딩을-사용한-다형성-구현" class="headerlink" title="오버로딩을 사용한 다형성 구현"></a>오버로딩을 사용한 다형성 구현</h4><p>이번에는 <code>오버로딩(Overloading)</code>을 사용한 다형성의 예시를 한번 살펴보도록 하자. 위의 <code>상속</code> 챕터에서 잠깐 언급하고 넘어간 <code>오버라이딩(Overriding)</code>과 헷갈리지 말자.</p><p>오버라이딩은 부모 클래스의 멤버 변수나 메소드를 덮어 씌우는 것이고, 오버로딩은 같은 이름의 메소드를 상황에 따라 다르게 사용할 수 있게 해주는 다형성을 위한 기능이다.<small>(필자는 학교에서 시험볼 때 자주 헷갈렸다)</small></p><p>오버로딩은 생각보다 단순한 개념이지만, 만약 오버로딩을 지원하지 않는 언어인 JavaScipt나 Python을 주로 사용하는 개발자들에게는 나름 충공깽일 수 있다. 그 이유는 바로 오버로딩이 <code>메소드의 인자로 어떤 것을 넘기냐에 따라서 이름만 같은 다른 메소드가 호출되는 기능</code>이기 때문이다.</p><center><br>  <img src="/2019/08/24/what-is-object-oriented-programming/dog_voice.gif" width="500"><br>  <small>이게 뭔 개소리야?</small><br>  <br><br></center><p>어떤 클래스가 <code>sum</code>이라는 메소드를 가지고 있다고 생각해보자. 이때 <code>sum</code>은 두 개의 인자를 받은 후 이 두 값을 합쳐서 리턴하는 내부 구조를 가지고 있다. 근데 만약 3개를 합치고 싶다면 어떻게 해야할까? 이런 경우에 JavaScript와 같이 오버로딩을 지원하지 않는 언어에서는 편법을 사용할 수 밖에 없다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Calculator</span> </span>&#123;</span><br><span class="line">  sum (...args) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> args.reduce(<span class="hljs-function">(<span class="hljs-params">prev, current</span>) =&gt;</span> prev + current);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">const</span> c = <span class="hljs-keyword">new</span> Calculator();</span><br><span class="line">c.sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">15</span></span><br></pre></td></tr></table></figure><p>뭐 어쨌든 되긴 되니까 상관없다고 생각할 수 있지만, 이건 객체의 다형성이라기보다 그냥 JavaScript의 언어적인 특성을 사용하여 우회한 것에 불과하다. 이렇게 작성하면 <code>두 개의 인자를 더해서 반환</code>하는 메소드에서 <code>n개의 인자를 더해서 반환</code>하는 메소드로는 만들 수 있지만 객체의 다형성을 만족할 수는 없다. 이 메소드의 <code>더한다</code>라는 기능 자체도 변경할 수 있어야 그제서야 다형성을 만족한다고 할 수 있는 것이다.</p><p>반면, Java나 C++과 같은 언어에서는 제대로 다형성을 만족시킬 수 있는 오버로딩을 지원한다.</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Overloading</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sum</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sum</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sum</span> <span class="hljs-params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> a + b + <span class="hljs-string">"입니다."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>쨘, 간단한 클래스를 하나 선언하고 <code>sum</code>이라는 메소드를 여러 개 선언했다. 만약 JavaScript에서 이렇게 선언했다가는 위에 선언된 두개의 <code>sum</code>은 무시되고 맨 아래의 <code>sum</code> 메소드로 덮어씌워지기 때문에 오버로딩을 할 수가 없다.</p><p>그리고 문자열을 인자로 받는 <code>sum</code> 메소드의 경우에는 문자열 맨 뒤에 <code>입니다</code>도 붙히는 센스를 발휘하도록 만들어주었다. JavaScript에서는 이 동작을 구현하려면 반드시 타입을 체크하는 조건 분기문이 필요하지만 Java는 오버로딩을 지원하기 때문에 그럴 필요가 없다.</p><p>그럼 이제 한번 이 메소드들이 잘 작동하나 호출해보도록 하자.</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Overloading o = <span class="hljs-keyword">new</span> Overloading();</span><br><span class="line">        System.out.println(o.sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));</span><br><span class="line">        System.out.println(o.sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>));</span><br><span class="line">        System.out.println(o.sum(<span class="hljs-string">"자"</span>, <span class="hljs-string">"바"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">6</span><br><span class="line">자바입니다.</span><br></pre></td></tr></table></figure><p>위의 예시에서 볼 수 있듯이 <code>Overloading</code> 클래스는 여러 개의 <code>sum</code> 메소드를 가지고 있고, 메소드의 인자가 무엇인지에 따라서 이름만 동일한 다른 메소드들을 호출해주고 있다. 이것이 <code>오버로딩</code>이며, Java에서 제공해주는 대표적인 다형성 지원 기능 중 하나이다.<small>(오버라이딩이랑 헷갈리지 말자!)</small></p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>사실 이 포스팅을 작성할 때 생각했던 타겟 독자층은 컴퓨터 공학을 전공한 개발자들이 아니였다. 애초에 컴퓨터 공학을 전공하거나, 타 과라도 컴퓨터 공학 전공 수업을 들었던 사람들은 대부분 학교에서 <code>객체 지향 프로그래밍</code>이라는 수업을 들어보았을 것이기 때문에 이 개념에 대해서 어느 정도 알고 있을 것이다.</p><p>필자가 이 포스팅의 타겟으로 한 독자 층은 바로 학원이나 부트캠프에서 코딩을 처음 배우신지 얼마 안된 분들이다. 학원이나 부트캠프에서는 Java를 가르치는 경우가 아니라면 OOP에 대한 내용을 거의 언급하지 않고 넘어가는 경우가 많은 것으로 알고 있다.</p><p>사실 학교와 다르게 학원은 짧은 기간 안에 실무를 할 수 있는 인재를 양성하여 취업시키는 것이 목적인 기관이라는 점을 생각해보면 이해가 안가는 것도 아니지만, OOP는 Java에만 국한된 개념이 아니라 어떤 언어를 사용하더라도 적용할 수 있는 범용적인 프로그래밍 패러다임이기 때문에 이에 대한 내용을 가르치지 않는 것이 안타깝긴 하다.</p><p>참고로 필자는 <code>OOP가 좋은 패러다임이니까 배워야 한다</code>라고 이야기하는 것이 아니다. 이 포스팅의 서두에서 한번 언급했듯이 전 세계에서 상당한 점유율을 차지하고 있는 메이저 언어인 <code>Java</code>, <code>Python</code>, <code>C++</code>과 같은 언어들이 대부분 OOP를 기반으로 설계되었거나 OOP를 지원하기 때문에 2019년에 프로그래밍을 하는 개발자라면 좋든 싫든 OOP를 알고는 있어야 한다고 생각하기 때문에 OOP를 추천하는 것이다.</p><center><br>  <img src="/2019/08/24/what-is-object-oriented-programming/language_index.png"><br>  <small>TIOBE의 2019년 8월 전 세계 언어 순위</small><br>  <small>C와 JavaScript, SQL을 제외한 모든 언어가 OOP를 사용한다.</small><br>  <br><br></center><p>어차피 프로그래밍 패러다임에는 정답이 없다. 선언적 프로그래밍이 좋은 것이냐, 명령적 프로그래밍이 좋은 것이냐라고 물어보면 쉽사리 대답할 수 없는 것 처럼 말이다. 그냥 우리는 어떤 패러다임이 어떤 방향을 추구하는지, 거기서 파생된 개념은 어떤 것들이 있는 지를 학습하고 각기 상황에 맞는 패러다임을 도입해서 사용하면 되는 것이다.</p><p>어쨌든 이 포스팅을 통해 혹시나 OOP를 모르고 있었거나, 아니면 너무 어렵게 느끼고 있던 분들이 좀 더 OOP를 친숙하게 받아들일 수 있기를 바라는 마음이다.</p><p>이상으로 알고 보면 재밌는 객체 지향 프로그래밍, OOP 흝어보기 포스팅을 마친다.</p>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/08/24/what-is-object-oriented-programming/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[JavaScript로 오디오 이펙터를 만들어보자] 나만의 소리 만들기</title>
      <link>https://evan-moon.github.io/2019/08/21/javascript-audio-effectors-practice/</link>
      <guid>https://evan-moon.github.io/2019/08/21/javascript-audio-effectors-practice/</guid>
      <pubDate>Wed, 21 Aug 2019 10:59:46 GMT</pubDate>
      <description>
      
        &lt;p&gt;이번 포스팅에서는 &lt;a href=&quot;/2019/08/19/javascript-audio-effectors-gain/&quot; title=&quot;저번 포스팅&quot;&gt;저번 포스팅&lt;/a&gt;에 이어 HTML5 Audio API를 사용하여 실제로 오디오 이펙터를 만드는 과정에 대해서 포스팅 하려고 한다. 저번 포스팅에서 이미 이야기 했듯이 Audio API는 여러 개의 노드를 연결하여 오디오의 흐름을 만들어 내는 것을 기본 개념으로 가지고 있고, 이펙터를 만들기 위해 필요한 몇 개의 추상화된 노드들을 기본적으로 제공해주기 때문에 그렇게 어려울 건 없다.&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>이번 포스팅에서는 <a href="/2019/08/19/javascript-audio-effectors-gain/" title="저번 포스팅">저번 포스팅</a>에 이어 HTML5 Audio API를 사용하여 실제로 오디오 이펙터를 만드는 과정에 대해서 포스팅 하려고 한다. 저번 포스팅에서 이미 이야기 했듯이 Audio API는 여러 개의 노드를 연결하여 오디오의 흐름을 만들어 내는 것을 기본 개념으로 가지고 있고, 이펙터를 만들기 위해 필요한 몇 개의 추상화된 노드들을 기본적으로 제공해주기 때문에 그렇게 어려울 건 없다.<br><a id="more"></a></p><p>우리는 단지 우리가 만드려고 하는 이펙터들이 각각 어떤 역할을 하며, 어떤 원리를 가지고 있고, 어떤 용도로 사용되는지만 알고 있으면 된다. 오디오에 사용하는 이펙터는 그 종류가 굉장히 많기 때문에 모든 이펙터를 만들어 볼 수는 없고, 필자가 생각했을 때 가장 대표적으로 많이 사용되는 기본적인 이펙터 5개 정도를 구현해볼 생각이다.</p><p>기본적으로 오디오를 로드하여 <code>소스 노드(Source Node)</code>를 생성하는 과정은 이미 저번 포스팅에서 설명했기 때문에 따로 설명하지 않겠다. 이번 포스팅에서는 바로 이펙터를 구현하는 내용부터 설명한다. 모든 이펙터는 먼저 해당 이펙터가 하는 일과 원리에 대해서 간략하게 설명하고 이후 묻지도 따지지도 않고 바로 구현 들어가도록 하겠다.</p><p>자, 그럼 하나하나 뜯어보도록 하자.</p><h2 id="Compressor"><a href="#Compressor" class="headerlink" title="Compressor"></a>Compressor</h2><center><br>  <img src="/2019/08/21/javascript-audio-effectors-practice/compressor.png" width="500"><br>  <br><br></center><p><code>컴프레서(Compressor)</code>는 소리가 일정 크기 이상으로 커질 경우에 이를 꾹꾹 눌러서 다시 작은 소리로 만드는 일종의 압축기 역할을 하는 이펙터이다. 이렇게 소리의 크기를 조절하는 이펙터를 <code>다이나믹 이펙터</code>라고 한다.</p><p>기본적으로 오디오 소스를 사용할 때 기본적으로 컴프레서를 걸어놓고 믹싱을 시작하는 경우가 많은데, 이는 오디오 신호가 일정 크기 이상으로 갑자기 커졌을 때 발생하는 <code>클리핑(Clipping)</code> 현상을 방어하기 위해서이기도 하다. 그럼 여기서 한가지 의문이 들 수 있는데,</p><blockquote><p>아니 단순히 클리핑을 막는 거면 그냥 Gain을 줄이면 해결되는 거 아니야?</p></blockquote><p>맞다. 사실 게인을 줄여도 어느 정도 클리핑을 방어할 수는 있다. 하지만 일반적으로 음악이란 셈여림이 존재하기 때문에 무작정 게인을 낮추면 작은 소리는 아예 입력되지도 않는 슬픈 상황이 발생하게 된다.</p><p>예를 들어 여러분이 노래방에 갔을 때를 생각해보자. 일반적으로 발라드를 부른다면 노래의 도입부에서는 잔잔한 느낌으로 조용히 부르다가 후렴에서는 고음을 내기위해 성대를 통과하는 공기의 압력이 올라가며 음량이 커진다. 이때 무작정 게인을 낮춰서 녹음하는 방향으로 접근한다면 필연적으로 가장 큰 소리인 후렴의 빵빵 지르는 소리의 크기에 게인을 맞출 수 밖에 없고, 그러면 도입부의 잔잔한 부분은 거의 입력되지 않을 것이다.</p><center><br>  <img src="/2019/08/21/javascript-audio-effectors-practice/buzz.jpg" width="500"><br>  <small>창법에 따라 조금씩 다르지만 이 음량 차이는 생각보다 크다.</small><br>  <br><br></center><p>이때 컴프레서로 입력 게인을 적당한 수준으로 높혀주고 너무 큰 소리는 압축하여 노래 도입부의 작은 소리와 후렴부의 큰 소리의 격차를 좁혀 전체적인 소리의 크기를 맞추기 위해서 사용하는 것이다.</p><center><br>  <img src="/2019/08/21/javascript-audio-effectors-practice/audio-compression.png" width="500"><br>  <small>Threshold를 넘어선 세기의 신호를 압축해서 Threshold 밑으로 들어가도록 만든다</small><br>  <br><br></center><p>또한 필자가 컴프레서 소리를 압축한다고 했는데, 소리를 압축한다는 것이 뭔지 잘 이해가 안갈 수 있다. 대표적인 예로 우리가 일반적인 음원에서 듣고 있는 <code>퍽!</code>, <code>탁!</code> 하는 깔끔한 드럼소리가 바로 압축된 소리이다.<small>(보통 이렇게 팍팍치는 소리를 Damping이라고 한다.)</small></p><p>일반적으로 드럼을 녹음하면 드럼 특유의 통이 울리는 잔향이 남는데, 이 소리를 컴프레서로 압축하면 우리가 일반적으로 듣는 깔끔한 드럼소리로 만들 수 있다.</p><p>그 외에도 베이스에 컴프레서를 사용하여 단단한 느낌을 부여하거나 멀리 있는 소리를 가까이로 끌어오거나 그 반대 역할도 할 수 있는 등, 컴프레서만 잘 사용해도 소리에 굉장히 많은 느낌을 부여할 수 있다. 그래서 필자에게 사운드 엔지니어닝을 알려주셨던 선생님도 컴프레서의 중요성을 굉장히 강조하셨던 기억이 난다.</p><p>컴프레서는 몇가지 값들을 사용하여 신호를 언제부터 압축할 것인지, 어느 정도의 속도로 압축할 것인지와 같은 세팅을 할 수 있도록 설계되었다. HTML5 Audio API에서 제공하는 <code>DynamicsCompressorNode</code>도 이 값들을 동일하게 제공하고 있으므로 우리는 이 값들이 어떤 의미를 가지고 있는지 알아야 올바른 방법으로 이 노드를 사용할 수 있다.</p><p><strong>Threshold</strong><br><code>Threshold</code>는 소리를 어느 크기부터 압축할 것인지를 정하는 임계점을 의미한다. 단위는 <code>DB(데시벨)</code>을 사용한다.</p><p><strong>Ratio</strong><br><code>Ratio</code>는 Threshold를 넘은 소리가 어느 정도의 비율로 줄어들 것인지를 정하는 값이다. 이 값은 <code>입력:출력</code>의 비를 의미하기 때문에 일반적으로는 <code>2:1</code>, <code>5:1</code>와 같은 비율로 이야기한다.</p><center><br>  <img src="/2019/08/21/javascript-audio-effectors-practice/ratio.png" width="300"><br>  <br><br></center><p>하지만 HTML5 Audio API의 속성에서는 단위가 조금 다르다. 공식 문서에는 <code>출력 값의 1db를 변경하기 위해 필요한 db값</code>이라고 적혀있는데 그냥 이 속성에 <code>12</code>를 할당하면 압축 비율이 <code>12:1</code>인거라고 생각하면 된다.<small>(공돌이들 특징인 어렵게 말하기가 발동했다)</small></p><p>보통 컴프레서를 <code>적당히 걸었다</code>라고 하면 <code>4:1</code> 정도의 비율을 말하기 때문에 해당 속성의 기본 값인 <code>12:1</code>은 상당히 하드한 압축 비율이라고 할 수 있다.</p><p><strong>Attack</strong><br><code>Attack</code>은 소리를 어느 정도의 빠르기로 압축할 것인지를 정하는 값이다. Threshold를 넘은 값을 얼마나 빠르게 때려서 눌러 담을 지를 정하면 된다고 생각하자. 많은 분들이 여기서 정해주는 어택 타임이 <code>Attack이 시작되는 시간</code>으로 잘못 알고 있는 데, 사실 신호의 크기가 Threshold를 넘으면 Attack 자체는 바로 시작된다. 우리가 정해주는 어택 타임은 정해진 <code>Ratio로 정해준 비율까지 도달하는 데 걸리는 시간</code>이다.</p><p>단위는 보통 <code>밀리초(ms)</code>를 사용하지만 Audio API에서는 <code>초(seconds)</code>를 사용한다.</p><p><strong>Release</strong><br>Attack이 소리를 누르는 빠르기였다면 <code>Release</code>는 압축한 소리를 어느 정도의 빠르기로 다시 풀어줄 것인가를 정하는 값이다. 이때 풀어주는 값은 소리의 원래 크기가 아니라 표준 음량인 10db에 도달하는 시간을 목표로 한다.</p><p><code>Release</code>도 Attack과 마찬가지로 단위는 보통 <code>밀리초(ms)</code>를 사용하지만 Audio API에서는 <code>초(seconds)</code>를 사용한다.</p><p><strong>Knee</strong><br><code>Knee</code>는 사실 대부분의 하드웨어 컴프레서에는 없는 기능이지만 소프트웨어 컴프레서에서는 꽤 자주 볼 수 있는 기능이다. 이 값은 컴프레서가 얼마나 <code>자연스럽게</code> 적용될 것인지를 결정한다.</p><center><br>  <img src="/2019/08/21/javascript-audio-effectors-practice/hard-soft-compression.gif" width="500"><br>  <br><br></center><p>위 그림의 그래프의 꺾이는 정도가 컴프레서가 얼마나 서서히 적용되는지를 보여주고 있다. 이때 빠르게 팍! 적용하는 컴프레션을 <code>Hard</code>하다고 하고 천천히 적용하는 컴프레션을 <code>Soft</code>하다고 한다.</p><h3 id="Compressror-구현해보기"><a href="#Compressror-구현해보기" class="headerlink" title="Compressror 구현해보기"></a>Compressror 구현해보기</h3><p>사실 위에서 이야기 했듯이 HTML5 Audio API는 자체적으로 <code>DynamicsCompressorNode</code>를 제공하기 때문에 우리가 소리를 압축하는 알고리즘을 직접 구현할 필요가 없다. 단지 노드를 생성한 후 연결해주기만 하면 될 뿐이다.</p><p>이번에는 사용자가 업로드한 오디오 파일에서 오디오 버퍼를 추출하여 소스 노드를 생성하는 것이 아니라 <code>&lt;audio&gt;</code> 태그에서 추출하여 소스 노드를 생성하는 방식으로 진행하도록 하겠다.<small>(이렇게 하면 코드가 훨씬 간단해진다)</small> 지금 생성한 소스노드는 앞으로 다른 이펙터를 구현할 때도 계속 사용할 것이다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> audioContext = <span class="hljs-keyword">new</span> (AudioContext || webkitAudioContext)();</span><br><span class="line"><span class="hljs-keyword">const</span> audioDOM = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'my-audio'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> sourceNode = audioContext.createMediaElementSource(audioDOM);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> threshold = <span class="hljs-number">-24</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> attack = <span class="hljs-number">0.003</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> release = <span class="hljs-number">0.25</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> ratio = <span class="hljs-number">12</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> knee = <span class="hljs-number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> compressorNode = audioContext.createDynamicsCompressor();</span><br><span class="line">compressorNode.threshold.setValueAtTime(threshold, audioContext.currentTime);</span><br><span class="line">compressorNode.attack.setValueAtTime(attack, audioContext.currentTime);</span><br><span class="line">compressorNode.release.setValueAtTime(release, audioContext.currentTime);</span><br><span class="line">compressorNode.ratio.setValueAtTime(ratio, audioContext.currentTime);</span><br><span class="line">compressorNode.knee.setValueAtTime(knee, audioContext.currentTime);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> inputGainNode = audioContext.createGain();</span><br><span class="line"><span class="hljs-keyword">const</span> outputGainNode = audioContext.createGain();</span><br><span class="line"></span><br><span class="line">sourceNode.connect(inputGainNode);</span><br><span class="line">inputGainNode.connect(compressorNode);</span><br><span class="line">compressorNode.connect(outputGainNode);</span><br><span class="line">outputGainNode.connect(audioContext.destination);</span><br></pre></td></tr></table></figure><p>필자는 <code>소스 -&gt; 게인 -&gt; 컴프레서 -&gt; 게인</code>의 순서로 오디오 소스의 흐름을 생성했는데, 사실 이건 개인의 취향이다. 하지만 일반적으로 대부분의 컴프레서는 <code>인풋 게인</code>과 <code>아웃풋 게인</code>을 모두 가지고 있으므로 필자도 이와 동일하게 구현했다.</p><p>이후 소스노드를 재생해보면 압축된 소리를 들을 수 있긴 한데, 사실 사운드 엔지니어가 아닌 일반인이 소리의 미세한 압축의 정도를 느끼기는 힘드므로 위의 값들을 조금 극단적으로 바꿔보는 것을 추천한다.</p><h2 id="Reverb"><a href="#Reverb" class="headerlink" title="Reverb"></a>Reverb</h2><center><br>  <img src="/2019/08/21/javascript-audio-effectors-practice/reverb.jpg" width="500"><br>  <br><br></center><p><code>리버브(Reverb)</code>는 소리에 울림을 통해 공간감을 부여하는 <code>공간계 이펙터</code>이다. 소리에 울림을 통해 공간감을 부여한다는 게 어떤 의미일까?</p><p>사실 우리는 소리를 듣고 현재 있는 공간이 넓은지 좁은지, 이 공간이 거친 벽면으로 이루어져 있는지, 아니면 유리같은 맨들맨들한 공간으로 이루어져 있는지를 대략적으로 파악할 수 있다. 그 차이가 워낙 미세해서 훈련되지 않은 사람이라면 알아채기 힘들 뿐이다.</p><p>어떻게 이런 일이 가능할까? 바로 소리의 반사에 의한 <code>잔향</code> 때문이다. 먼저, 소리를 듣고 공간의 크기를 감지하는 원리는 간단하다. 필자가 어떤 방 안에서 소리를 <code>왁!</code>하고 지른 뒤 얼마 후에 첫번째 반사음이 들리는지를 감지하면 된다. 하지만 이 첫번째 반사음은 <code>ms</code> 단위의 굉장히 빠른 속도로 다시 필자에게 돌아오기 때문에 1초, 2초 이렇게 세는 것이 아니라 그냥 느껴야하는 것이다.</p><p>이때 이 반사음을 <code>초기 반사음(Early Reflection)</code>이라고 한다. 하지만 여기서 끝이 아니다. 소리가 한번 반사되어 여러분의 귀로 전달된 뒤에도 반사는 계속 될 것이다. 이때 이 잔향들은 공간의 사방팔방으로 부딫히고 반사되어 여러분의 귀로 다시 돌아올 것이다.</p><center><br>  <img src="/2019/08/21/javascript-audio-effectors-practice/reflection.gif" width="500"><br>  <small>초록색 선이 초기 반사음, 사방팔방 부딫히는 파란색 선이 바로 잔향이다</small><br>  <br><br></center><p>이때 이 잔향이 얼마나 오래 들리는가, 얼마나 선명하게 들리는가와 같은 특성이 방의 재질을 결정한다. 이야기만 들으면 이렇게 소리를 듣고 공간을 판별한다는 것이 불가능한 것 같지만 여러분이 이미 평소에 듣고 음악에는 모두 이 원리를 적용한 공간적 설계가 함께 담겨있다.</p><p>이렇게 리버브는 말 그대로 잔향을 만들어내기만 하면 되기 때문에 하드웨어 리버브 중에서는 스프링이나 철판 등의 재료를 장비 내부에 넣어놓고 오디오를 재생하여 재료가 떨리며 발생한 잔향을 증폭하는 방식을 사용하는 것도 있다. 즉, 뜯어보면 장비 내부에 스프링이나 철판 하나 딸랑 들어있다는 것이다.<small>(이런 단순한 구조로 좋은 소리를 뽑는다는 게 더 무섭…)</small></p><p>그러나 리버브를 소프트웨어로 구현할 때는 이야기가 조금 다르다. 컴퓨터는 스프링이나 철판의 떨림과 같은 자연적인 아날로그 신호를 생성할 수 없으므로 직접 계산을 통해 구현해야한다. 이때 소프트웨어 리버브는 크게 두 가지 종류로 나누어지는데 바로 <code>Convolution Reverb</code>와 <code>Algorithm Reverb</code>이다.</p><p>하지만 이 포스팅에서 두 리버브를 모두 구현하기에는 글이 너무 길어질 것 같으므로 아쉬운대로 컨볼루션 리버브에 초점을 맞춰 진행하겠다.<small>(알고리즘 리버브만 해도 포스팅 하나 분량이다.)</small></p><h3 id="Convolution-Reverb"><a href="#Convolution-Reverb" class="headerlink" title="Convolution Reverb"></a>Convolution Reverb</h3><p><code>컨볼루션 리버브(Convolution Reverb)</code>는 실제 공간의 잔향을 녹음한 후에 잔향 오디오 소스와 원본 오디오 소스를 실제 공간의 울림을 원본 오디오 소스에 합성하는 방법이다.</p><p>이때 실제 공간의 잔향을 녹음하는 대표적인 방법을 간단하게 설명하자면, 녹음하고자 하는 공간에 <code>순수한 사인파(Sine Wave)</code>의 소리를 낮은 주파수부터 높은 주파수까지 쭈우우욱 이어서 틀고 그때 발생하는 잔향을 녹음하는 것이다.</p><center><br>  <img src="/2019/08/21/javascript-audio-effectors-practice/ir-recording.jpg" width="500"><br>  <small>공간의 IR을 녹음하는 모습 - <a href="http://www.alanjshan.com/impulse-response-capture/" rel="external nofollow noopener noreferrer" target="_blank">Alan JS Han 블로그</a></small><br>  <br><br></center><p>이때 이 잔향 신호를 <code>Impulse Response(IR)</code>이라고 부르기 때문에 컨볼루션 리버브는 <code>IR 리버브</code>라는 이름으로도 불린다. 이렇게 녹음한 IR은 원본 소스에 <code>컨볼루션(Convolution)</code>, 또는 합성곱이라고 불리우는 연산을 통해 합쳐지게 된다.</p><p>이 컨볼루션이라는 개념을 수학적으로 접근하기 시작하면 머리도 아프고 또 포스팅이 길어지니까 간단하게 정의해보자면, 그냥 서로 다른 정보들을 섞는 것이라고 표현할 수 있다. 이 포스팅을 읽는 분들은 아마 개발자 분들이 많을 테니 우리에게 좀 더 친숙한 머신러닝을 사용하여 컨볼루션을 설명하자면 학습 알고리즘 중 하나인 <code>CNN(Convolution Neural Network)</code>을 예로 들어볼 수 있겠다.</p><p>CNN에서도 첫번째 레이어의 이미지를 두번째 레이어로 보낼 때 행렬로 구현한 커널<small>(또는 필터)</small>와 이미지를 섞어서 피처맵을 생성한 후 다음 레이어로 보내게된다. 이때 첫번째 레이어의 이미지와 커널의 정보가 섞인 것이라고 생각할 수 있다.</p><center><br>  <img src="/2019/08/21/javascript-audio-effectors-practice/convolution.png" width="500"><br>  <small>원본 이미지와 커널을 섞어서 새로운 정보인 피처맵을 만들어낸다</small><br>  <br><br></center><p>오디오에서의 컨볼루션 리버브도 이와 마찬가지다. 이 경우에는 섞어야하는 정보가 원본 소스와 IR이 된 것 뿐이다.</p><p>컨볼루션은 원본 소스와 IR이라는 두 오디오 소스의 주파수 스펙트럼을 곱하는 과정이기 때문에 이를 통해 두 소스 간에 겹치는 주파수는 강조되고 겹치지 않는 주파수는 감쇠된다. 이렇게 원본 소스와 IR 간 겹치는 주파수가 강조되면 원본 소스는 IR의 음질의 특성을 띄게 되는데, 이게 바로 컨볼루션 리버브의 원리이다.</p><center><br>  <img src="/2019/08/21/javascript-audio-effectors-practice/signal-convolution.png" width="500"><br>  <small>원본 신호와 녹음한 IR 신호를 컨볼루션 연산한 모습</small><br>  <br><br></center><p>사실 HTML5 Audio API는 컨볼루션 연산을 대신 수행해주는 <code>ConvolverNode</code>를 제공하기 때문에 컨볼루션이 무엇인지 몰라도 컨볼루션 리버브를 만드는 데는 아무 문제가 없다.</p><p>그러나 적어도 이 이펙터가 2개의 신호 정보를 곱해서 새로운 신호를 만들어내는 원리를 가지고 있다는 것을 알아야 필자가 왜 이런 코드를 작성하는지도 알 수 있기 때문에 대략적인 설명을 하는 것이다.</p><p>어쨌든 컨볼루션 리버브의 대략적인 원리를 파악했다면 이제 바로 만들어보도록 하자.</p><h3 id="Convolution-Reverb-구현해보기"><a href="#Convolution-Reverb-구현해보기" class="headerlink" title="Convolution Reverb 구현해보기"></a>Convolution Reverb 구현해보기</h3><p>먼저 HTML5 Audio API는 <code>ReverbNode</code> 같은 건 제공하지 않는다. 하지만 위에서 설명했듯이 컨볼루션 연산을 지원하는 <code>ConvolverNode</code>를 제공해주고 있기 때문에 우리는 잔향 소스인 <code>IR(Impulse Response)</code>만 직접 만들어주면 된다.</p><p>그리고 일반적으로 리버브는 <code>wet</code>과 <code>dry</code>라는 수치로 원본 소스와 잔향 소스를 비율에 맞게 섞을 수 있도록 제작되므로 필자도 동일하게 코드를 작성하겠다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> mix = <span class="hljs-number">0.5</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> time = <span class="hljs-number">0.01</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> decay = <span class="hljs-number">0.01</span>;</span><br></pre></td></tr></table></figure><p>리버브의 사용할 3개의 변수를 먼저 설명하자면, <code>mix</code>는 wet/dry의 비율을 의미하고, <code>time</code>은 잔향의 길이, <code>decay</code>는 잔향이 감소하는 빠르기를 의미한다. 그럼 이제 이 값들을 사용하여 직접 <code>IR</code>을 생성해보자.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateImpulseResponse</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">const</span> sampleRate = audioContext.sampleRate;</span><br><span class="line">  <span class="hljs-keyword">const</span> length = sampleRate * time;</span><br><span class="line">  <span class="hljs-keyword">const</span> impulse = audioContext.createBuffer(<span class="hljs-number">2</span>, length, sampleRate);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">const</span> leftImpulse = impulse.getChannelData(<span class="hljs-number">0</span>);</span><br><span class="line">  <span class="hljs-keyword">const</span> rightImpulse = impulse.getChannelData(<span class="hljs-number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    leftImpulse[i] = (<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>) * <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">1</span> - i / length, deacy);</span><br><span class="line">    rightImpulse[i] = (<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>) * <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">1</span> - i / length, deacy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> impulse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>뭔가 복잡해보이지만 뜯어보면 별 거 없다. <code>sampleRate</code>는 우리가 생성하고자 하는 <code>IR</code>의 샘플레이트, 즉 음질을 의미하고 <code>length</code>는 <code>sampleRate * time</code>, 즉 <code>time</code>초 만큼의 잔향을 표현하기 위한 버퍼의 길이를 의미한다.</p><p>그리고 그냥 버퍼 노드를 하나 생성한 다음 <code>-1 ~ 1</code>의 무작위 값을 생성한 후 <code>1 - i / length</code>에 <code>decay</code>를 제곱한 후 방금 생성한 난수에 곱해준다. 이러면 <code>i</code>값이 커질수록 값이 작아질 것이고, <code>deacy</code> 값이 커질수록 더 빠르게 작아질 것이다. 이는 잔향의 감쇠를 표현 해준 것이다. 이후 이 샘플을 방금 만든 버퍼 노드에 쭈르륵 담아주면 끝이다.</p><p>이렇게 생성된 <code>IR</code> 버퍼를 파형으로 표현해보면 대략 다음과 같은 모양을 가질 것이다.</p><center><br>  <img src="/2019/08/21/javascript-audio-effectors-practice/decay.jpg" width="300"><br>  <br><br></center><p>쨘, 이렇게 간단하게 <code>IR</code>를 생성해보았다. 이제 <code>ConvolverNode</code>를 사용하여 원본 소스와 이 IR을 합성해주는 것만 남았다. 리버브 이펙터의 오디오 흐름을 만들기 위해서 필요한 노드들을 먼저 생성해보자.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> inputNode = audioContext.createGain();</span><br><span class="line"><span class="hljs-keyword">const</span> wetGainNode = audioContext.createGain();</span><br><span class="line"><span class="hljs-keyword">const</span> dryGainNode = audioContext.createGain();</span><br><span class="line"><span class="hljs-keyword">const</span> reverbNode = audioContext.createConvolver();</span><br><span class="line"><span class="hljs-keyword">const</span> outputNode = audioContext.createGain();</span><br></pre></td></tr></table></figure><p>위에서도 설명했듯이 일반적인 리버브 이펙터는 <code>wet/dry</code>라는 수치를 사용하여 원본 소스와 리버브가 적용된 소스를 섞어서 출력하는 기능을 제공한다. 이때 dry한 소스는 리버브 이펙터를 거치지 않고 바로 <code>outputNode</code>로 연결되서 출력되어야 하며, wet한 소스는 우리가 만든 <code>reverbNode</code>를 한번 거치고 <code>outputNode</code>로 출력되어야 한다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sourceNode.connect(inputNode);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Dry 소스 노드 연결</span></span><br><span class="line">inputNode.connect(dryGainNode);</span><br><span class="line">dryGainNode.connect(outputNode);</span><br><span class="line">dryGainNode.gain.value = <span class="hljs-number">1</span> - mix;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// IR을 생성하여 Convolver의 오디오 버퍼에 입력해준다.</span></span><br><span class="line">reverbNode.buffer = generateImpulseResponse();</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Wet 소스 노드 연결</span></span><br><span class="line">inputNode.connect(reverbNode);</span><br><span class="line">reverbNode.connect(wetGainNode);</span><br><span class="line">webGainNode.connect(outputNode);</span><br><span class="line">wetGainNode.gain.vaule = mix;</span><br><span class="line"></span><br><span class="line">outputNode.connect(audioContext.destination);</span><br></pre></td></tr></table></figure><p>이렇게 컨볼루션 리버브를 간단하게 구현해보았다. 사실 컨볼루션 리버브의 퀄리티에 가장 큰 영향을 끼치는 것은 IR의 퀄리티인데, 우리는 대충 만든 샘플 오디오로 IR을 만들었으므로 이 리버브의 퀄리티는 좋을 수가 없다. 그러나 소스 노드를 재생해서 들어보면 신기하게도 소리에 공간감이 부여된 것을 들어볼 수 있다.</p><p>만약 기회가 된다면 다음에는 알고리즘 리버브의 구현체도 한번 포스팅 해보도록 하겠다. 알고리즘 리버브는 실제 공간의 잔향을 녹음하여 사용하는 컨볼루션 리버브와는 다르게 100% 알고리즘으로만 구현된 리버브이다. 그렇기 때문에 약간 인위적인 느낌이 나기는 하지만 컨볼루션 리버브와는 또 색다른 느낌을 부여할 수 있으므로 사운드 엔지니어들은 이 두가지 리버브의 특성을 파악하고 적재적소에 사용한다.</p><p>그렇기 때문에 개발자들에게는 오히려 컨볼루션 리버브보다 알고리즘 리버브 쪽이 더 이해가 잘될 수 있으나, <code>ConvolverNode</code> 하나와 대충 만든 <code>IR</code>만 있으면 나머지는 알아서 다 연산해주는 컨볼루션 리버브와는 다르게 알고리즘 리버브는 진짜 밑바닥부터 만들어야한다. 그래서 아쉽지만 알고리즘 리버브는 다음에 포스팅 하도록 하겠다.</p><p>만약 알고리즘 리버브의 구현체가 궁금하신 분은 <a href="https://github.com/evan-moon/simple-waveform-visualizer/blob/master/src/effects/AlgorithmReverb.js" rel="external nofollow noopener noreferrer" target="_blank">필자의 깃허브 레파지토리</a>에서 확인해볼 수 있다.</p><h2 id="Delay"><a href="#Delay" class="headerlink" title="Delay"></a>Delay</h2><center><br>  <img src="/2019/08/21/javascript-audio-effectors-practice/delay.jpg" width="500"><br>  <br><br></center><p><code>딜레이(Delay)</code>는 리버브와 같은 공간계 이펙터이고 소리를 반복해서 들려준다는 점이 같기 때문에 비슷하다고 생각할 수 있지만 그 원리와 용도는 많이 다르다.</p><p>먼저, 딜레이는 단순히 소리를 반복하는 효과이지만 리버브는 공간 내에서의 복잡한 반사음을 흉내내는 것이므로 딜레이만 사용하면 리버브와 같은 자연스러운 공간감을 표현하기가 힘들다.</p><p>방금 만들어봤던 리버브 이펙터는 사실적인 공간 표현이 목적이기 때문에 컨볼루션이나 복잡한 알고리즘을 사용하지만 딜레이는 그냥 원본 소스를 잠깐 지연시켰다가 <code>n</code>초 후에 다시 틀어주면서 조금씩 소리를 작게 해주면 끝이다.</p><center><br>  <img src="/2019/08/21/javascript-audio-effectors-practice/reverb_vs_delay.png" width="500"><br>  <small>Echo(Delay)와 Reverb의 차이</small><br>  <br><br></center><p>딜레이는 이렇게 간단한 원리를 가지고 있기 때문에 만드는 것 역시 그렇게 어렵지 않다.</p><h3 id="Delay-구현해보기"><a href="#Delay-구현해보기" class="headerlink" title="Delay 구현해보기"></a>Delay 구현해보기</h3><p>HTML5의 Audio API는 인풋으로 받은 신호를 지연시켜서 다시 출력하는 <code>Delay Node</code>를 제공해주기 때문에 우리는 이 노드를 사용하여 간단하게 딜레이 이펙터를 구현할 수 있다.</p><p>그러나 단순히 <code>DelayNode</code>만 사용한다면 단 한번의 지연만 발생시킬 수 있기 때문에 우리는 한가지 얌생이를 사용하여 딜레이를 구현할 것이다. 먼저 딜레이에 필요한 변수들을 선언해보도록 하자.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> mix = <span class="hljs-number">0.5</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> feedback = <span class="hljs-number">0.5</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> time = <span class="hljs-number">0.3</span>;</span><br></pre></td></tr></table></figure><p>리버브와 마찬가지로 대부분의 딜레이 이펙터도 <code>wet/dry</code> 값을 사용하여 원본 소스와 딜레이된 소스를 섞어서 출력해주는 기능을 가지고 있기 때문에 필자도 동일하게 구현해줄 것이다. 그리고 <code>feedback</code> 변수는 원본 소스가 한번 딜레이될 때 감소시킬 음량이고 <code>time</code> 변수는 메아리들의 간격을 의미한다. 딜레이에 사용할 변수들을 모두 선언했다면 이제 노드들을 만들 차레이다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> inputNode = audioContext.createGain();</span><br><span class="line"><span class="hljs-keyword">const</span> wetGainNode = audioContext.createGain();</span><br><span class="line"><span class="hljs-keyword">const</span> dryGainNode = audioContext.createGain();</span><br><span class="line"><span class="hljs-keyword">const</span> feedbackNode = audioContext.createGain();</span><br><span class="line"><span class="hljs-keyword">const</span> delayNode = audioContext.createDelay();</span><br><span class="line"><span class="hljs-keyword">const</span> outputNode = audioContext.createGain();</span><br></pre></td></tr></table></figure><p><code>webGainNode</code>와 <code>dryGainNode</code>는 리버브와 동일하기 때문에 그냥 넘어가고, 새로운 노드인 <code>feedbackNode</code>와 <code>delayNode</code>에 집중해보자. 사실상 딜레이 이펙터는 이 두개의 노드가 핵심이다. 먼저, 딜레이 이펙터가 하는 일에 대해서 다시 한번 살펴보자.</p><blockquote><p>입력 -&gt; 지연 -&gt; 감소된 신호 출력 -&gt; 입력 -&gt; 지연 -&gt; 감소된 신호 출력…</p></blockquote><p>딜레이 이펙터가 하는 일은 이게 전부다. 신호를 조금씩 지연시키고 감소된 신호를 다시 출력하는 일을 반복한다. 그래서 필자는 <code>delayNode</code>와 <code>feedbackNode</code>를 서로 연결해주는 방법으로 이 이펙터를 구현하려고 한다.</p><center><br>  <img src="/2019/08/21/javascript-audio-effectors-practice/delay-nodes.png" width="500"><br>  <small>이렇게 간단한 연결만으로 딜레이를 구현할 수 있다</small><br>  <br><br></center><p>이렇게 노드들을 연결하게되면 <code>DelayNode</code>를 통해 입력된 오디오 신호가 지연된 후 <code>FeedbackNode</code>와 <code>OutputNode</code>로 출력되고, <code>FeedbackNode</code>를 통해서 게인이 감소된 소리는 다시 <code>DelayNode</code>로 입력되어 지연된 후 <code>OutputNode</code>로 출력될 것이다. 그럼 위 그림대로 한번 노드들을 연결해보도록 하자.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sourceNode.connect(inputNode);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Dry 소스 노드 연결</span></span><br><span class="line">inputNode.connect(dryGainNode);</span><br><span class="line">dryGainNode.connect(outputNode);</span><br><span class="line">dryGainNode.gain.value = <span class="hljs-number">1</span> - mix;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Delay 루프 생성</span></span><br><span class="line">delayNode.connect(feedbackNode);</span><br><span class="line">feedbackNode.connect(delayNode);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Wet 소스 노드 연결</span></span><br><span class="line">inputNode.connect(delayNode);</span><br><span class="line">delayNode.connect(wetGainNode);</span><br><span class="line">wetGainNode.connect(outputNode);</span><br><span class="line">wetGainNode.gain.vaule = mix;</span><br><span class="line"></span><br><span class="line">outputNode.connect(audioContext.destination);</span><br></pre></td></tr></table></figure><p>이제 소스 노드를 재생해보면 딜레이 이펙터를 통해 메아리가 치는 듯한 효과가 적용된 소리를 들어볼 수 있다.</p><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><center><br>  <img src="/2019/08/21/javascript-audio-effectors-practice/filter.png" width="500"><br>  <br><br></center><p><code>필터(Filter)</code>는 무언가를 걸러내는 도구 혹은 개념을 의미한다. 우리는 이미 필터라는 개념을 평소에 많이 사용하고 있기 때문에 그렇게 이해하기 어려운 개념은 아닐 것이다. 그리고 오디오 이펙터에서의 필터는 바로 <code>주파수</code>를 걸러내는 역할을 한다.</p><p>쉽게 말하면 필터는 오디오의 음역대 중 특정한 음역대만 콕 집어내어 없애버릴 수 있는 이펙터인 것이다. 그래서 필터는 주로 소리에 섞여있는 노이즈를 걸러내거나 너무 낮거나 너무 높아서 쓸데없는 울림을 생성하는 주파수를 걸러내는데 많이 사용된다.</p><p>이러한 필터의 특성을 잘 사용하면 상당히 재미있는 짓을 많이 할 수 있는데 대표적인 예를 두개 정도 들자면, 바로 <code>전화기에서 나오는 목소리</code>를 만들거나 <code>클럽에서 나는 음악 소리</code>와 같은 소리를 만드는 경우가 있다.</p><p>먼저, 전화기에서 나오는 목소리는 전체 주파수 중에서 특정한 대역의 주파수만 통과시키는 <code>Bandpass</code> 필터를 사용하여 만들어 낼 수 있다. 전화기가 전송할 수 있는 주파수 대역에 한계가 있다는 것을 이용하여 인간의 목소리 대역인 <code>100 ~ 250hz</code>의 주파수를 제외한 나머지 주파수를 모두 잘라내는 것이다.</p><center><br>  <div class="video-container"><iframe src="//www.youtube.com/embed/JrbkbKt1iEM?start=300" frameborder="0" allowfullscreen></iframe></div><br>  <small>위 영상의 5:00 경 “Hey, kitty~” 하는 부분이 필터가 적용된 목소리이다.</small><br>  <br><br></center><p>그러므로 사람의 목소리 소스에 필터를 사용하여 <code>100 ~ 250hz</code> 대역을 제외하고 나머지 주파수를 모두 날려버리게되면 우리가 일반적으로 전화를 할때 들리는 목소리로 만들어낼 수 있는 것이다.</p><p>클럽에서 나는 음악 소리도 비슷한 원리로 만들어내는 것이다. 클럽의 특성 상 보통 지하에 위치하고 좁은 입구를 가지고 있는 경우가 많다. 그런 상황에서 클럽에서 노래를 틀게되면 소리가 밖으로 빠져나올 수 있는 통로가 거의 없기 때문에 우리가 지상에서 클럽에서 틀고 있는 노래를 들어보면 굉장히 묵직한 <code>붐~ 붐~</code>하는 소리가 들리게 된다.</p><p>클럽 음악의 특성 상 강한 드럼과 베이스로 인해 저음이 부각되는 경우가 많고, 고음보다는 저음의 물체 투과율이 높기 때문에 클럽 외부에서는 상대적으로 고음에 비해 많이 투과된 저음을 위주로 듣게 되는 것이다. 이러한 파동의 특성은 소리에 한정되는 것은 아니고 빛과 같은 다른 파동또한 고주파의 에너지 손실률이 저주파보다 높다.</p><center><br>  <div class="video-container"><iframe src="//www.youtube.com/embed/qmhwHUHc1Hc?start=397" frameborder="0" allowfullscreen></iframe></div><br>  <small>낮은 주파수만 통과시키는 Lowpass 필터를 사용한 소리</small><br>  <br><br></center><p>이렇듯 사운드 엔지니어들은 특정 상황의 소리가 어떻게 들리는지 분석하고 필터를 포함한 여러가지 이펙터들을 사용하여 그 상황의 현장감을 부여하기도 한다.</p><p>다행히도 HTML5 Audio API는 이런 필터를 만들 수 있는 <code>BiquadFilterNode</code>를 제공해주고 있기 때문에 우리가 직접 오디오 버퍼를 까서 주파수를 분석해야하는 슬픈 상황은 피할 수 있다. 우리는 이 노드가 제공하는 값들이 어떤 것을 의미하는지만 알고 있으면 된다.</p><p>그럼 <code>BiquadFilterNode</code>가 제공하는 속성들이 무엇을 의미하는지 하나하나 살펴보도록 하자.</p><p><strong>Frequency</strong><br><code>Frequency</code>는 어떤 대역의 주파수를 걸러낼 것인지를 정하는 값이다. 단위는 <code>hz(헤르츠)</code>를 사용하며, <code>10hz</code>부터 오디오의 샘플레이트의 절반까지의 값을 할당할 수 있다. 만약 오디오 소스의 샘플레이트가 <code>44,100hz</code>라면 <code>22,050</code>까지를 할당할 수 있다는 의미이다.</p><p><strong>Q</strong><br>신호를 걸러낸다는 것은 기본적으로 칼처럼 딱! 자를 수 있는 것이 아니다. 소리 자체는 아날로그 신호이기 때문에 네모 반듯하게 잘라낼 수 없고 어느 정도 바운더리를 가지고 걸러낼 수밖에 없는데, 이때 <code>Q</code>는 특정 주파수를 걸러낼 때 얼마나 예민하게 걸러낼 수 있는 지를 의미한다.</p><center><br>  <img src="/2019/08/21/javascript-audio-effectors-practice/filter-q.png" width="500"><br>  <br><br></center><p><code>Q</code>에는 <code>0.0001 ~ 1000</code> 사이의 값을 할당할 수 있으며, Q의 값이 높을 수록 잡아낸 주파수를 더 예민하게 걸러낼 수 있다. 그러나 오디오 신호를 필터링 할 때 Q가 너무 높다면 자연스럽게 들리지 않고 인위적으로 들릴 수 있기 때문에 적당한 값을 찾는 것이 중요하다.</p><p><strong>Type</strong><br><code>BiquadFilterNode</code>로는 여러가지 타입의 필터를 만들어 낼 수 있는데, 크게는 주파수를 아예 걸러내버리는 타입과, 특정 주파수를 증폭시키거나 감소시킬 수 있는 타입으로 나눠진다.</p><p><strong>주파수를 걸러내는 타입</strong></p><ul><li><code>lowpass(highcut)</code>: 지정한 주파수보다 높은 주파수를 모두 걸러낸다.</li><li><code>highpass(lowcut)</code>: 지정한 주파수보다 낮은 주파수를 모두 걸러낸다.</li><li><code>bandpass</code>: 지정한 주파수를 제외한 모든 주파수를 걸러낸다.</li><li><code>notch</code>: 지정한 주파수를 걸러낸다.</li></ul><p><strong>주파수를 증폭/감소하는 타입</strong></p><ul><li><code>lowshelf</code>: 지정한 주파수보다 낮은 주파수를 증폭/감소 시킨다.</li><li><code>highshelf</code>: 지정한 주파수보다 높은 주파수를 증폭/감소 시킨다.</li><li><code>peaking</code>: 지정한 주파수를 증폭/감소 시킨다.</li></ul><p>이 중 주파수를 증폭/감소시키는 타입은 밑에서 후술할 <code>EQ(Equalizer)</code>에서도 사용할 수 있다. 이번에는 단순히 주파수를 걸러내는 필터를 만들 예정이므로 필자는 주파수를 걸러내는 타입만을 사용하여 필터를 구현할 것이다.</p><p>필자는 특정 주파수보다 낮은 주파수를 모두 걸러내는 <code>Lowpass 필터</code>와 특정 주파수보다 높은 주파수를 모두 걸러내는 <code>Highpass 필터</code>를 구현할 것이다. 그럼 한번 간단하게 필터를 구현해보도록 하자.</p><h3 id="Filter-구현해보기"><a href="#Filter-구현해보기" class="headerlink" title="Filter 구현해보기"></a>Filter 구현해보기</h3><p>우선 AudioContext 객체의 <code>createBiquadFilter</code> 메소드를 사용하여 <code>BiquadFilterNode</code>를 생성한다. 필자가 가지고 있는 오디오 샘플은 <code>44,100hz</code>의 샘플레이트를 가지고 있으므로 Lowpass 필터의 주파수는 <code>1,000hz</code>로 Highpass 필터의 주파수는 <code>20,000hz</code>로 설정하겠다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> lowpassFilterNode = audioContext.createBiquadFilter();</span><br><span class="line">lowpassFilterNode.type = <span class="hljs-string">'lowpass'</span>;</span><br><span class="line">lowpassFilterNode.frequency.setValueAtTime(<span class="hljs-number">1000</span>, audioContext.currentTime);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> highpassFilterNode = audioContext.createBiquadFilter();</span><br><span class="line">highpassFilterNode.type = <span class="hljs-string">'highpass'</span>;</span><br><span class="line">highpassFilterNode.frequency.setValueAtTime(<span class="hljs-number">20000</span>, audioContext.currentTime);</span><br></pre></td></tr></table></figure><p><code>Q</code>값을 따로 설정해주지 않았는데, 그래도 사실 상관없다. <code>BiquadFilterNode</code>의 Q는 기본 값으로 350을 가지고 있고 이 값은 너무 과하지도 부족하지도 않은 적당한 값이기 때문에 그냥 기본 값을 사용할 것이다.<small>(조금 귀찮기도 하다.)</small></p><p>이제 생성한 필터 노드들을 오디오 소스와 연결해주면 <code>1,000hz</code>보다 낮고 <code>20,000hz</code>보다 높은 주파수가 제거된 오디오 샘플을 들어볼 수 있다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sourceNode.connect(lowpassFilterNode);</span><br><span class="line">lowpassFilterNode.connect(highpassFilterNode);</span><br><span class="line">highpassFilterNode.connect(audioContext.destination);</span><br></pre></td></tr></table></figure><p>여기까지 읽으신 분들은 슬슬 느끼기 시작했겠지만 사실 HTML5 Audio API가 워낙 잘 만들어져있어서 개발자가 만져야할 부분이 거의 없다. 필자는 <code>BiquadFilterNode</code>의 존재를 알기 전에는 <code>와 이거 필터는 어떻게 만들지...?</code>라고 고민했었는데 사실 제일 고민할 필요가 없는 놈이었다.<small>(그래서 약간 허무하기도 했다.)</small></p><h2 id="EQ"><a href="#EQ" class="headerlink" title="EQ"></a>EQ</h2><center><br>  <img src="/2019/08/21/javascript-audio-effectors-practice/parametric-eq.png" width="500"><br>  <br><br></center><p><code>Equalizer(EQ, 이퀄라이저)</code>는 이름에서도 알 수 있듯이 일종의 <code>주파수 평탄화 작업(Frequancy Equalizing)</code>을 하는 목적으로 사용하는 이펙터이다. EQ는 컴프레서와 함께 오디오 믹싱의 기본으로 깔고 들어가는 이펙터인데, 원본 소스에서 쓸데없는 소리를 없애고 다른 소리들과의 조화를 이루도록 하는 용도로 주로 사용한다. EQ는 결국 주파수를 컨트롤하는 이펙터이므로 필터를 사용하여 구현하는데, 이미 우리는 필터를 한번 만들어봤기 때문에 EQ 정도는 뚝딱 만들 수 있다.</p><p>EQ는 크게 <code>파라메트릭 이퀄라이저(Parametric EQ)</code>와 <code>그래픽 이퀄라이저(Graphic EQ)</code> 두 가지 종류로 나누어지는데, 필자는 이 중 그래픽 이퀄라이저를 구현할 예정이다. 참고로 상단의 그림은 파라메트릭 EQ인데, 그냥 이미지가 더 멋있어서 넣었다. 참고로 그래픽 EQ는 이렇게 생겼다.</p><center><br>  <img src="/2019/08/21/javascript-audio-effectors-practice/graphic-eq.jpg" width="500"><br>  <small>짙은 아날로그의 향수가 풍겨오는 비주얼</small><br>  <br><br></center><p>두 개의 EQ 모두 장단점이 존재하는데, 일단 그래픽 EQ의 장점은 파라메트릭 EQ에 비해 조절할 수 있는 주파수 대역의 수가 많고 직관적인 인터페이스를 가지고 있다는 것이다. 여러분은 이 단락의 맨 위에 첨부된 파라메트릭 EQ 이미지를 보고 <code>엥? 파라메트릭도 나름 직관적인데?</code>라고 하실 수 있는데, 원래 하드웨어 파라메트릭 EQ는 이렇게 생겼다.</p><center><br>  <img src="/2019/08/21/javascript-audio-effectors-practice/hardware-parametric-eq.jpg" width="500"><br>  <small>까만 것은 노브요. 하얀 것은 숫자로다.</small><br>  <br><br></center><p>그래서 그래픽 EQ는 보통 빠른 대응이 필요한 공연장같은 곳에서 많이 사용되고 있으며, 짬이 많이 쌓인 시니어 사운드 엔지니어들은 공연장에서 하울링<small>(노래방에서 삐- 하며 가끔 나는 날카로운 소리)</small>이 발생하면 바로 해당 주파수를 캐치해서 그래픽 EQ로 죽여버리는 무서운 스킬을 가지고 있다.</p><p>그래픽 EQ의 단점은 조절할 수 있는 주파수 대역이 정해져 있다는 것과 주파수의 세밀한 조정이 힘들다는 것이다. 반면 파라메트릭 EQ는 그래픽 EQ와 다르게 조절할 수 있는 주파수 대역까지 모두 정해줄 수 있다.</p><p>그러나 한번에 조절할 수 있는 주파수의 개수는 그래픽 EQ에 비해 크게 부족하다. 일반적인 파라메트릭 EQ가 <code>3~5</code>개의 주파수 대역을 조절할 수 있는 반면에 그래픽 EQ는 한번에 조절 가능한 주파수가 <code>40</code>개가 넘어가는 굇수도 존재한다.</p><p>필자 생각에 하드웨어 파라메트릭 EQ의 최대 단점은 바로 직관적이지 않은 인터페이스를 가지고 있다는 것인데, 이 단점은 소프트웨어로 구현하면 UI로 커버할 수 있는 영역이기도 하고 대부분의 녹음실에서는 즉각적인 대응보다는 계속 소리를 들어보면서 이퀄라이징을 할 수 있는 상황이 대부분이기 때문에 많은 소프트웨어 EQ가 주파수 대역 조절에 자유도가 높은 파라메트릭 EQ로 구현된다.</p><p>하지만 필자가 만드는 데모처럼 간단히 구현해보는 상황에서는 저 위에 하드웨어 파라메트릭 EQ와 비슷한 UI로 구현될 것이 뻔하므로 필자는 상대적으로 UI 만들기가 쉬운 그래픽 EQ를 선택했다.<small>(이 말이 잘 이해가 안된다면 EQ 챕터의 가장 위에 첨부한 파라메트릭 EQ를 한번 보고 오자)</small></p><p>위에서 한번 이야기했듯이 EQ는 필터를 사용하여 구현하므로 그렇게 복잡하지 않다. 그럼 이제 한번 간단하게 뚝딱 만들어보도록 하자.</p><h3 id="그래픽-EQ-구현하기"><a href="#그래픽-EQ-구현하기" class="headerlink" title="그래픽 EQ 구현하기"></a>그래픽 EQ 구현하기</h3><p>위에서 그래픽 EQ 이미지를 봤다면 알겠지만 이 친구는 조절할 수 있는 주파수 대역의 개수가 정해져 있는 장비이다. 그렇기 때문에 필자도 조절할 수 있는 주파수가 들어있는 배열을 하나 선언하고 이 배열을 이터레이션하면서 필터들을 생성할 것이다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> frequencies = [</span><br><span class="line">  <span class="hljs-number">25</span>, <span class="hljs-number">31</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">63</span>, <span class="hljs-number">80</span>, <span class="hljs-number">100</span>, <span class="hljs-number">125</span>, <span class="hljs-number">160</span>, <span class="hljs-number">200</span>,</span><br><span class="line">  <span class="hljs-number">250</span>, <span class="hljs-number">315</span>, <span class="hljs-number">400</span>, <span class="hljs-number">500</span>, <span class="hljs-number">630</span>, <span class="hljs-number">800</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">1250</span>, <span class="hljs-number">1600</span>, <span class="hljs-number">2000</span>,</span><br><span class="line">  <span class="hljs-number">2500</span>, <span class="hljs-number">3150</span>, <span class="hljs-number">4000</span>, <span class="hljs-number">5000</span>, <span class="hljs-number">6300</span>, <span class="hljs-number">8000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">12500</span>, <span class="hljs-number">16000</span>, <span class="hljs-number">20000</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>이때 주의해야할 점이 있다. EQ는 여러 개의 필터를 사용하기 때문에 각 필터를 서로 체이닝해서 연결해주어야한다. 이때 필터의 게인이 1보다 조금이라도 높다면 한번 필터를 통과할 때마다 소리가 조금씩 증폭되어 여러분의 귀에 들어올 때 쯤이면 엄청 큰 소리가 되어 여러분의 고막을 영원히 이별시킬 수도 있다.</p><blockquote><p>그렇기 때문에 반드시 필터들의 게인을 <code>0</code>이하로 설정해주어야 한다.</p></blockquote><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> inputNode = audioContext.createGain();</span><br><span class="line">sourceNode.connect(inputNode);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> filters = frequencies.map(<span class="hljs-function">(<span class="hljs-params">frequency, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="hljs-keyword">const</span> filterNode = audioContext.createBiquadFilter();</span><br><span class="line">  filterNode.gain.value = <span class="hljs-number">0</span>;</span><br><span class="line">  filterNode.frequency.setValueAtTime(frequency, audioContext.currentTime);</span><br><span class="line">  </span><br><span class="line">  <span class="hljs-keyword">if</span> (index === <span class="hljs-number">0</span>) &#123;</span><br><span class="line">    filterNode.type = <span class="hljs-string">'lowshelf'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index === array.length - <span class="hljs-number">1</span>) &#123;</span><br><span class="line">    filterNode.type = <span class="hljs-string">'highshelf'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">    filterNode.type = <span class="hljs-string">'peaking'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span> filterNode;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">filters.reduce(<span class="hljs-function">(<span class="hljs-params">prev, current</span>) =&gt;</span> &#123;</span><br><span class="line">  prev.connect(currentNode);</span><br><span class="line">  <span class="hljs-keyword">return</span> currentNode;</span><br><span class="line">&#125;, inputNode);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> outputNode = audioContext.createGain();</span><br><span class="line">filters[filters.length - <span class="hljs-number">1</span>].connect(outputNode);</span><br><span class="line">outputNode.connect(audioContext.destination);</span><br></pre></td></tr></table></figure><p><code>map</code> 메소드 내부의 <code>if</code> 문을 보면 해당 첫번째 필터와 마지막 필터의 타입만 다르게 주고 있는 것을 볼 수 있는데, 이는 <code>Shelf</code> 타입의 필터를 사용하여 첫번째 필터의 주파수보다 낮은 주파수와 마지막 필터의 주파수보다 높은 주파수까지 모두 커버하기 위해서이다.<small>(필터 타입이 잘 기억나지 않는다면 Filter 부분을 다시 보고 오자)</small></p><p>그 후 생성된 필터를 <code>reduce</code> 메소드를 통해 모두 체이닝해주고 <code>outputNode</code>와도 연결해주었다. 여기까지 작성한 후 <code>sourceNode</code>를 재생시켜보면 아무 변화도 없는 것을 알 수 있다.</p><p>당연히 모든 필터의 게인이 <code>0</code>이기 때문에 아무런 변화가 없는 것이다. 이때 저 필터들의 값을 <code>-1 ~ 1</code>사이의 랜덤한 난수로 할당하면 소리가 조금씩 변하는 것을 들어볼 수도 있다. 필자는 개인적으로 <code>input[type=&quot;range&quot;]</code> 엘리먼트와 연동하여 필터들의 게인을 조절할 수 있도록 만들고 직접 이것저것 만져보는 것을 추천한다.</p><p>또한 가장 낮은 주파수와 높은 주파수의 필터를 <code>Shelf</code> 타입으로 설정했기 때문에 이 필터들의 게인을 낮추면 <code>Lowpass 필터</code>나 <code>Highpass 필터</code>와 같은 효과도 낼 수 있다.</p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>자, 여기까지 대표적으로 많이 사용하는 이펙터들인 컴프레서, 리버브, 딜레이, 필터, EQ를 만들어보았다. 사실 이 5개 외에도 재밌는 여러가지 이펙터가 있지만 분량조절 대실패로 인해 여기까지만 노는 것으로 하겠다.</p><p>필터를 만들 때 한번 이야기 했듯이 HTML5 Audio API는 굉장히 높은 수준의 추상화된 노드를 제공해주기 때문에 사실 개발자가 직접 구현할 것들이 별로 없다. 이는 다르게 말하면 세밀한 수준의 구현이 힘들다는 뜻이기도 하지만 필자가 무슨 오디오 이펙터 회사를 차릴 것도 아니기 때문에 단순 재미로 만들어보기에는 충분한 것 같다.</p><p>이렇게 여러가지 이펙터를 구현해보며 필자도 예전에 사운드 엔지니어로 일할 때의 추억이 새록새록 떠오르기도 했고 또 이펙터에 대해서 새롭게 알게된 내용도 있어서 굉장히 재밌게 작업을 했다. 필자는 포스팅에 작성한 이펙터 외에도 여러가지 이펙터를 계속 구현해볼 예정이므로 관심있는 분들은 <a href="https://github.com/evan-moon/simple-waveform-visualizer" rel="external nofollow noopener noreferrer" target="_blank">필자의 깃허브</a>에서 한번 쓱 둘러보고 PR을 날려도 된다.<small>(좋은 건 나누면 배가 되는 법이다.)</small></p><p>이상으로 JavaScript로 오디오 이펙터를 만들어보자 - 나만의 소리 만들기 포스팅을 마친다.</p>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/08/21/javascript-audio-effectors-practice/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[JavaScript로 오디오 이펙터를 만들어보자] 소리의 흐름을 파악하자</title>
      <link>https://evan-moon.github.io/2019/08/19/javascript-audio-effectors-gain/</link>
      <guid>https://evan-moon.github.io/2019/08/19/javascript-audio-effectors-gain/</guid>
      <pubDate>Mon, 19 Aug 2019 04:12:07 GMT</pubDate>
      <description>
      
        &lt;p&gt;이번 포스팅에서는 &lt;a href=&quot;/2019/07/10/javascript-audio-waveform/&quot; title=&quot;컴퓨터는 어떻게 소리를 들을까?&quot;&gt;컴퓨터는 어떻게 소리를 들을까?&lt;/a&gt; 포스팅에서 진행했던 오디오 파형 그리기에 이어서 오디오에 여러가지 효과를 줄 수 있는 이펙터를 만드는 과정을 설명하려고 한다. HTML5의 Audio API는 오디오에 효과를 줄 수 있는 여러가지 노드를 제공하는데, 대부분의 이펙터는 이 노드들만 사용해도 구현할 수 있을 정도로 완성도있는 API를 제공한다.&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>이번 포스팅에서는 <a href="/2019/07/10/javascript-audio-waveform/" title="컴퓨터는 어떻게 소리를 들을까?">컴퓨터는 어떻게 소리를 들을까?</a> 포스팅에서 진행했던 오디오 파형 그리기에 이어서 오디오에 여러가지 효과를 줄 수 있는 이펙터를 만드는 과정을 설명하려고 한다. HTML5의 Audio API는 오디오에 효과를 줄 수 있는 여러가지 노드를 제공하는데, 대부분의 이펙터는 이 노드들만 사용해도 구현할 수 있을 정도로 완성도있는 API를 제공한다.<br><a id="more"></a></p><p>또한 이 포스팅은 총 두편에 나눠서 작성될 예정이며, 이번 포스팅에서는 <code>HTML5 Audio API</code>의 개요와 오디오의 음량을 조절할 수 있는 <code>GainNode</code>를 사용하는 방법에 대해서, 다음 포스팅에서는 좀 더 복잡한 오디오 이펙터들에 대한 설명과 제작 과정을 설명할 예정이다.</p><p>지난 포스팅에서 이미 오디오에 관한 기본적인 이론을 설명했으니 이번에는 기본적인 이론이 아니라 실제로 녹음실에서 오디오를 어떤 방식으로 컨트롤하고 효과를 주는 지에 대한 방법에 대해 초점을 맞추고 설명을 진행하도록 하겠다.</p><h2 id="오디오-신호는-흐르는-것이다"><a href="#오디오-신호는-흐르는-것이다" class="headerlink" title="오디오 신호는 흐르는 것이다"></a>오디오 신호는 흐르는 것이다</h2><p>일반적인 녹음실에서 우리는 마이크를 통해서 오디오를 녹음하거나 혹은 이미 녹음된 오디오를 <code>Logic Pro</code>나 <code>Cubase</code>와 같은 <code>DAW(Digital Audio Workstation)</code>으로 불러와서 사용하게 된다. 이때 처음으로 받게되는 이 오디오를 <code>소스(Source)</code>라고 한다.</p><p>이 소스는 앰프, 컴프레서, 이퀄라이저 등 오디오에 특별한 느낌을 줄 수 있는 여러가지 이펙터들을 지나서 최종적으로 스피커나 헤드폰을 통해서 출력되게 된다. 이 흐름을 알고나면 HTML5의 Audio API가 제공하는 <code>노드(Node)</code>의 개념을 쉽게 이해할 수 있다. 일단 이해를 돕기 위해 필자가 예전에 사운드 엔지니어로 일할 때 사용했던 시스템을 예로 들겠다.</p><center><br>  <img src="/2019/08/19/javascript-audio-effectors-gain/mixer.jpg" width="500"><br>  <small>필자가 예전에 사용했던 장비들</small><br>  <br><br></center><p>사진의 중앙에 있는 커다란 장비는 아마 여러분도 TV에서 몇번 보았던 장비일 것이다. 이 장비는 여러 개의 채널로 나눠진 오디오 소스의 볼륨이나 패닝, 이퀄라이징까지 할 수 있는 일종의 컨트롤 타워 역할을 하는 믹싱 콘솔이다.</p><p>그리고 믹싱 콘솔의 오른쪽에 있는 것들이 바로 오디오에 효과를 줄 수 있는 이펙터들이다. 보통은 믹싱 콘솔 양쪽에 가득 채워놓고 쓰는데 저 사진은 아직 녹음실 셋업이 덜 끝났을 때라서 몇가지 장비만 들어가 있다. 그리고 사진에는 나오지 않았지만 따로 <code>콘솔 랙(Console Rack)</code>이라는 선반을 두고 거기에도 이펙터들이 가득 채워져 있다.</p><p>그리고 이펙터들의 위쪽을 보면 붉은색 선이 꽂혀있는 것을 볼 수 있는데, 저 장비가 <code>오디오의 흐름</code>을 컨트롤할 수 있는 <code>패치 테이블(Patch Table)</code>이라고 하는 장비이다.</p><p>보통 사운드 엔지니어들은 같은 역할을 하는 이펙터라고 하더라도 여러 종류의 장비를 사용하게 되는데, 이는 같은 역할을 하는 이펙터라고 하더라도 장비마다 조금씩 소리가 다를 수 있기 때문이다. 즉, 같은 리버브를 사용한다고 해도 최종적으로 만들고자하는 소리가 어떤 느낌인지에 따라 <code>A 리버브</code>를 사용할 수도 있고 <code>B 리버브</code>를 사용할 수도 있다는 것이다. 그래서 이런 소리의 질을 만드는 고유한 알고리즘은 이펙터 제조 회사들의 기업 비밀이다.</p><p>하지만 다른 이펙터를 사용하고 싶을 때마다 장비에 꽂혀있는 케이블을 일일히 하나하나 빼서 다시 다른 장비에 연결하는 것은 비효율적이기도 하고 케이블을 계속 뺐다가 꼈다가 하면 장비에 손상이 갈수도 있기 때문에 모든 장비의 라인을 저 패치 테이블에 연결해놓고 사용하는 것이다. 게다가 케이블은 대부분 장비 뒤쪽에 위치하기 때문에 저 믹싱 콘솔을 앞으로 살짝 밀고 봐야하는데, 딱 봐도 저 큰 장비를 계속 밀었다 당겼다 하기에는 무거워 보이지 않는가? 허리 나간다.</p><center><br>  <img src="/2019/08/19/javascript-audio-effectors-gain/patch_table_chart.jpeg" width="500"><br>  <small>패치 테이블은 대략 이런 느낌으로 정리된다</small><br>  <br><br></center><p>사운드 엔지니어는 이렇게 복잡한 여러 개의 장비 사이를 흘러다니는 오디오 신호의 흐름을 패치 테이블을 통해서 한번에 파악하고 컨트롤 할 수 있다. 소리를 컨트롤하는 사람에게 오디오 신호의 흐름이라는 개념은 굉장히 중요하다. 필자가 방금 예로 든 하드웨어 장비 뿐만 아니라 소프트웨어로 구현된 이펙터를 사용하려할때도 결국은 이 흐름을 프로그램 내부에서 그대로 구현해줘야하기 때문이다.</p><center><br>  <img src="/2019/08/19/javascript-audio-effectors-gain/protools.png" width="300"><br>  <br><br></center><p>위 사진은 전 세계 녹음실 중 90%가 사용하고 있는 Protools라는 DAW의 믹서 창이다. 사진에 강조된 부분에 <code>Vocal Bus</code>라고 적혀있는 곳을 보면 맨 오른쪽 채널은 위쪽에 위치하고 있고 나머지 채널은 아래쪽에 위치하고 있다. <code>I/O</code> 메뉴에서 위쪽은 <code>In</code>을 의미하고 아래쪽은 <code>Out</code>을 의미하기 때문에 이 그림에서 오디오의 흐름은 대략 다음과 같이 나타날 수 있다.</p><center><br>  <img src="/2019/08/19/javascript-audio-effectors-gain/auxes.png"><br></center><blockquote><p>이때 저 네모 하나하나가 HTML5의 Audio API에서 제공해주는 <code>노드</code>와 정확히 같은 개념이다. 즉, 자바스크립트로 저 흐름을 완벽히 동일하게 구현할 수 있다는 뜻이다.</p></blockquote><p>이해를 돕기 위해 저 노드들의 역할에 대해서 조금 더 부가설명을 하자면, 일단 <code>Lead Vox</code>는 말 그래도 보컬의 노래 소스를 가진 노드이고 <code>LeadVxDbl</code>은 노래를 풍부하게 들리게 하기 위해 같은 멜로디를 한번 더 녹음한 것, 즉 더블링 작업을 한 노드이다. 그리고 <code>Vox Fill</code>은 화음을 쌓은 코러스를 담은 노드일 것 같다.</p><p>그리고 보컬이 노래한 이 오디오 소스를 모두 <code>Vocal Bus</code>라는 노드로 모으고 있다. 이렇게 하는 이유는 여러 개의 오디오 소스에 이펙터를 각각 사용하면 노드마다 조금씩 소리의 느낌이 달라질 수 있기 때문에 <code>Vocal Bus</code>라는 하나의 노드로 오디오 신호를 모은 다음 해당 노드에만 이펙터를 걸어주는 것이다. 이렇게 하면 모든 노드에 이펙터를 사용하지않고 하나의 노드에만 이펙터를 사용해도 되기 때문에 메모리 비용도 아낄 수 있고, <code>보컬</code>이라는 하나의 소스에 동일한 느낌을 부여할 수 있다.</p><p>그리고 최종적으로 신호가 들어가는 <code>Sub Master</code> 노드는 아마 최종 아웃풋으로 소리가 나가기 전에 한번 더 이펙터 처리를 하고 싶어서 생성한 것일 테고, Sub Master까지 도달한 오디오는 아웃풋, 즉 스피커를 통해 출력되어 우리의 귀로 들어오게 되는 것이다. 결국 <code>in -&gt; out -&gt; in -&gt; out</code>의 계속된 반복이라고 보면 된다. 그래서 필자가 오디오의 <code>흐름</code>이라고 표현하는 것이다.</p><p>이제 오디오 소스의 흐름이라는 것이 대략 이해가 되었으면 한번 직접 HTML5의 Audio API를 사용해서 이 흐름을 구현해보도록 하자.</p><h2 id="오디오의-음량을-조절하기"><a href="#오디오의-음량을-조절하기" class="headerlink" title="오디오의 음량을 조절하기"></a>오디오의 음량을 조절하기</h2><p>위에서 이야기했듯이 이번 포스팅에서는 본격적으로 이펙터를 구현해보기에 앞서 오디오의 흐름을 직접 구현해보고 체험해보는 것에 초점을 맞출 것이다. 그래서 이펙터라기에는 조금 애매한 단순한 구조의 흐름을 만들어보려고 한다. 바로 오디오의 음량을 조절하는 흐름이다. HTML5 Audio API의 <code>GainNode</code>를 사용하면 오디오 소스의 음량을 손쉽게 조절할 수 있다.</p><h3 id="Gain이란-무엇인가요"><a href="#Gain이란-무엇인가요" class="headerlink" title="Gain이란 무엇인가요?"></a>Gain이란 무엇인가요?</h3><p><code>게인(Gain)</code>이란 쉽게 말하면 입력 볼륨을 의미한다. 게인을 사용하여 마이크에서 오디오 믹서나 녹음기로 오디오 신호를 보낼 때 그 신호량을 컨트롤하는 것이다. 처음 오디오에 입문하시는 분들이 <code>게인(Gain)</code>과 <code>볼륨(Volume)</code>의 차이에 대해 헷갈려하시는데, 쉽게 말하면 게인은 <code>입력 신호를 조절</code>하는 것이고 볼륨은 <code>출력 신호를 조절</code>하는 것이다.</p><p>만약 <code>100</code>정도 세기의 신호를 처리할 수 있는 녹음기가 있다고 생각해보자. 이때 우리가 마이크에 대고 <code>80</code> 정도의 세기로 소리를 왁! 지르면 이 녹음기는 무리없이 이 신호를 받아들일 수 있지만, <code>150</code>의 세기로 소리를 지르게 되면 이 녹음기는 <code>50</code>만큼의 소리를 받아들이지 못하고 그대로 유실시킨다.</p><center><br>  <img src="/2019/08/19/javascript-audio-effectors-gain/clipping.png" width="500"><br>  <small>회색으로 표시된 부분이 잘려나간 신호이다.</small><br>  <br><br></center><p>이 현상은 여러분도 살면서 몇번 경험한 현상일텐데, 스피커로 소리를 엄청 크게 틀면 <code>지지직</code>거리는 잡음이 발생하는 것을 들어본 적이 있을 것이다. 이렇게 장비가 처리할 수 있는 신호의 세기를 넘어가는 현상을 <code>클리핑(Clipping)</code>이라고 한다. 말 그래도 신호가 잘려나가는 것이다.</p><p>이렇게 잘려나간 신호는 위 그림에서 볼 수 있듯이 머리가 네모 반듯한 <code>사각파</code>의 형태를 가지게 되는데, 이 사각파는 우리가 EDM 등에서 멜로디를 표현할 때 많이 들을 수 있는 신디사이저 <code>리드(Lead)</code> 계열의 <code>쭈와앙~</code>하는 금속성 소리를 낸다. 말로는 잘 이해가 안될테니 한번 음악으로 들어보면서 잠시 쉬어가도록 하자. 아마 클럽 좀 다녀보신 분들은 <code>아! 이 소리</code>할 것이다.</p><center><br>  <div class="video-container"><iframe src="//www.youtube.com/embed/usXhiWE2Uc0" frameborder="0" allowfullscreen></iframe></div><br>  <small>해당 곡의 인트로가 끝나는 35초부터 메인 멜로디를 맡는 악기가 사각파를 사용한 리드이다.</small><br>  <br><br></center><p>아무래도 리드는 악기로써 파형이 어느 정도 정제된 상태이기 때문에 클리핑이 발생했을 때 나는 소리는 이것보다 더 거칠고 날카롭다. 참고로 이렇게 파형에 따라 소리가 달라진다는 개념은 <code>왜곡계(Distortion)</code> 이펙터를 만들때도 사용하는 개념이기 때문에 기억해두면 좋다.</p><p>어쨌든 이런 클리핑 문제 때문에 사운드 엔지니어들은 오디오 소스와 다음 장비 사이에 게인을 조절할 수 있는 장치를 두고, 장비가 받아들일 수 있는 신호의 세기에 맞춰서 알맞게 게인을 조절하여 소스 오디오의 신호가 커지더라도 모든 신호를 다 담을 수 있도록 한다.</p><p>반대로 볼륨은 소리를 내보낼 때 얼마나 증폭시킬 것이냐를 의미한다. 많은 분들이 게인과 볼륨을 헷갈려하는 이유가 둘 다 소리를 증폭시키거나 감소시키는 역할을 하기 때문인데, 볼륨은 이미 입력된 신호를 출력할 때 건드리는 것이기 때문에 클리핑이 발생하더라도 볼륨을 줄이면 신호가 돌아오지만 녹음할 때 게인을 잘못 설정하여 유실된 소리는 다시 돌아오지 않는다.</p><p>신호 입력 단계에서 이미 유실된 것이기 때문에 영원한 이별인 것이다. 게다가 녹음이라는 특성 상 그 원본 소스는 <code>사람</code>인 경우가 많다. 결국 이 유실된 신호를 다시 살려낼 수 없기 때문에 게인을 잘못 설정하면 다시 녹음을 해야하는 슬픈 상황이 벌어질 수 있는 것이다.</p><p>그래서 사운드 엔지니어들은 소리를 녹음할 때 <code>게인을 잘 다루는 것</code>을 엄청 중요하게 생각한다. 사실 게인만 해도 좀 더 깊이 들어가면 하고 싶은 이야기가 많지만, 이 포스팅은 오디오 전문 포스팅이 아니므로 그냥 비슷한 거라고 생각하고 넘어가도 상관없다.</p><p>이제 게인이 무엇인지 이해했다면 <code>GainNode</code>와 함께 오디오 소스의 신호 세기를 조절해서 소리의 크기를 변형시켜보자!</p><h3 id="Gain-Node를-사용하여-음량을-조절해보자"><a href="#Gain-Node를-사용하여-음량을-조절해보자" class="headerlink" title="Gain Node를 사용하여 음량을 조절해보자"></a>Gain Node를 사용하여 음량을 조절해보자</h3><p>일단 게인을 사용해보려면 오디오 소스가 필요하다. 오디오 소스는 HTML5의 <code>&lt;audio&gt;</code> 태그를 사용하거나 사용자가 직접 업로드한 파일에서 추출하는 두가지 방법이 있는데, 필자는 이 중 후자의 방법을 사용하였다.</p><p>이것도 엄밀히 말하자면 <code>&lt;audio&gt;</code>태그를 사용하여 소스를 추출했을 때와 파일 버퍼에서 직접 추출했을 때는 다른 소스 노드 객체가 생성되긴 하지만 기능상 큰 차이 없으므로 그냥 개인의 취향대로 하면 된다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> audioContext = <span class="hljs-keyword">new</span> (Audiocontext || webkitAudioContext)();</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'audio-uploader'</span>).onchange = <span class="hljs-function"><span class="hljs-params">evt</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="hljs-keyword">const</span> file = evt.currentTarget.files[<span class="hljs-number">0</span>];</span><br><span class="line">  <span class="hljs-keyword">if</span> (!file) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> FileReader();</span><br><span class="line">  reader.onload = <span class="hljs-keyword">async</span> evt =&gt; &#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> buffer = <span class="hljs-keyword">await</span> audioContext.decodeAudioData(file);</span><br><span class="line">    <span class="hljs-keyword">const</span> sourceNode = audioContext.createBufferSource();</span><br><span class="line">    sourceNode.buffer = buffer;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(sourceNode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AudioBufferSourceNode &#123;<span class="hljs-attr">buffer</span>: AudioBuffer, <span class="hljs-attr">playbackRate</span>: AudioParam, <span class="hljs-attr">detune</span>: AudioParam, <span class="hljs-attr">loop</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">loopStart</span>: <span class="hljs-number">0</span>, …&#125;</span><br></pre></td></tr></table></figure><p>우선 간단한 설명을 하자면 <code>buffer</code> 변수에 담긴 오디오 데이터는 raw한 오디오 데이터일 뿐 아직 하나의 노드가 아니기 때문에 사용할 수 없는 상태이다. 그렇기 때문에 <code>createBufferSource</code> 메소드를 사용하여 소스 노드를 생성한 후 해당 소스 노드에 오디오 데이터를 입력해줘야만 비로소 오디오 데이터를 사용할 수 있는 상태가 되는 것이다.</p><p>이때 필자는 사용자가 업로드한 파일에서 직접 오디오 버퍼 데이터를 뽑아와서 노드를 만든 것이기 때문에 <code>createBufferSource</code> 메소드를 사용하여 소스 노드를 생성했지만, 만약 <code>&lt;audio&gt;</code> 태그에서 추출한 오디오 데이터를 사용하여 소스 노드를 생성하고 싶다면 <code>createMediaElementSource</code> 메소드를 사용해야 한다.</p><p>그럼 이제 <code>GainNode</code>를 생성하고 소스 노드에 연결만 시켜주면 바로 이 오디오 소스의 음량을 조절할 수 있게 된다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> gainNode = audioContext.createGain();</span><br><span class="line">sourceNode.connect(gainNode);</span><br><span class="line">gainNode.connect(audioContext.destination);</span><br></pre></td></tr></table></figure><p>이 코드에서 <code>소스 -&gt; 게인 -&gt; 데스티네이션</code>으로 설정된 오디오의 흐름이 보인다면 사실상 Audio API에 대한 이해는 거의 끝났다고 봐도 무방하다. 위에서도 말했듯이 오디오를 컨트롤할 때는 이 개념을 이해하는 게 제일 중요하기 때문이다.</p><p>또한 <code>gainNode</code>가 연결된 <code>audioContext.destination</code>은 최종 아웃풋, 즉 스피커로 향하는 정보를 가지고 있다. 그럼 이제 여기서 오디오의 소리를 증폭시키거나 감소시키려면 어떻게 해야할까?</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gainNode.gain.value = <span class="hljs-number">1.2</span>;</span><br><span class="line"><span class="hljs-comment">// 또는</span></span><br><span class="line">gainNode.gain.setValueAtTime(<span class="hljs-number">1.2</span>, audioContext.currentTime);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 그 후 소스를 재생해보자</span></span><br><span class="line">sourceNode.start();</span><br></pre></td></tr></table></figure><blockquote><p>[Warinig] 너무 값을 크게 올리면 재생했을 때 고막 터집니다.</p></blockquote><p>간단하다. 그냥 <code>GainNode.gain.value</code>에 접근해서 값을 변경해주면 된다. 게인 같은 경우는 값에 직접 접근하여 변경하는 것이 가능하지만 다른 노드의 경우 자신의 값을 직접 변경하는 것이 허용되지 않는 경우가 있는데, 이럴 때는 <code>setValueAtTime</code> 메소드를 사용하면 된다.</p><p><code>setValueAtTime</code> 메소드는 일종의 스케줄러같은 개념인데, 두번째 인자로 넘긴 시간이 지난 후에 값을 적용하는 기능을 가지고 있다. 이때 인자로 넘기는 시간의 단위는 <code>초</code>이다. <code>audioContext.currentTime</code>을 인자로 사용하면 곧바로 값의 변경이 적용된다.</p><p>필자는 처음에 이런 노드들의 값을 변경할 때 헷갈렸던 것이 하나 있는데, 바로 <code>min</code>과 <code>max</code>이다. 즉, 이 노드가 가지는 값의 범위를 알 수가 없었다. 물론 공식 문서에 다 나와있긴 하지만 그걸 어느 세월에 하나하나 검색해서 보겠는가?</p><p>그래서 문서를 조금 더 뒤져보니 이 노드들이 가지는 값은 공통적으로 <code>AudioParam</code> 타입이라는 것을 알 수 있었다. 이 타입은 <code>min</code>, <code>max</code>, <code>defaultValue</code>, <code>value</code> 속성을 가지고 있었고, 이 값들은 <code>input[type=&quot;range&quot;]</code>를 사용하여 오디오를 컨트롤할때 유용하게 사용할 수 있다.</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(gainNode.gain);</span><br></pre></td></tr></table></figure><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AudioParam &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">automationRate</span>: <span class="hljs-string">"a-rate"</span>, <span class="hljs-attr">defaultValue</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">minValue</span>: <span class="hljs-number">-3.4028234663852886e+38</span>, <span class="hljs-attr">maxValue</span>: <span class="hljs-number">3.4028234663852886e+38</span>&#125;</span><br></pre></td></tr></table></figure><p>이 값을 잘 확인하고 게인의 값을 설정하면 적어도 고막과 이어폰이 터져나가는 불상사는 방지할 수 있을 것이다. 위에서 말했듯이 컴퓨터가 처리할 수 있는 신호의 세기를 넘어가게 되면 클리핑 현상이 발생하면서 찢어지는 듯한 소리가 나기 때문에 만약 이어폰을 끼고 있었다면 농담이 아니고 진짜 귀에 무리가 갈 수도 있다.</p><p>자, 이렇게 간단하게 오디오 소스의 게인을 조절해보았다. 나머지 이펙터들도 대부분 이런 느낌으로 구현된다. 간혹 조금 더 복잡한 연결이 필요한 이펙터들이 있긴 하지만 대부분의 경우 간단한 몇개의 노드를 연결하는 것만으로 구현할 수 있기 때문에 그렇게 어렵지 않다.</p><p>다음 포스팅에서는 이번에 알아본 개념을 바탕으로 소리를 압축하거나 공간감을 부여하고, 특정 주파수를 잘라내어 소리에 특별한 느낌을 줄 수 있는 다른 이펙터들을 만들어보도록 하겠다. 또한 기회가 된다면 이미 존재하는 오디오 소스를 변형하는 이펙터가 아니라 진짜로 오디오 신호 자체를 만들어 낼 수 있는 <code>오실레이터(Oscillator)</code>를 사용하여 나만의 악기를 만들어볼 수 있는 포스팅도 진행할 예정이다.</p><p>이상으로 JavaScript로 오디오 이펙터를 만들어보자 - 소리의 흐름을 파악하자 포스팅을 마친다.</p>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/08/19/javascript-audio-effectors-gain/#disqus_thread</comments>
    </item>
    
    <item>
      <title>2년 동안 근무했던 회사를 떠나며</title>
      <link>https://evan-moon.github.io/2019/08/17/leave-the-company/</link>
      <guid>https://evan-moon.github.io/2019/08/17/leave-the-company/</guid>
      <pubDate>Sat, 17 Aug 2019 07:52:40 GMT</pubDate>
      <description>
      
        &lt;p&gt;오늘, 2019년 8월 16일을 마지막으로 지난 2년 동안 근무했던 회사를 떠나게 되었다. 지금은 사무실에서 말년의 여유를 즐기며 이 포스팅을 서두를 작성하고 있다. 그래서 이번 포스팅에서는 지난 2년 간 필자가 이 회사를 다니면서 느꼈던 점이나 입사 당시와 비교해서 지금 달라진 점들에 대해서 회고를 진행하려고 한다.&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>오늘, 2019년 8월 16일을 마지막으로 지난 2년 동안 근무했던 회사를 떠나게 되었다. 지금은 사무실에서 말년의 여유를 즐기며 이 포스팅을 서두를 작성하고 있다. 그래서 이번 포스팅에서는 지난 2년 간 필자가 이 회사를 다니면서 느꼈던 점이나 입사 당시와 비교해서 지금 달라진 점들에 대해서 회고를 진행하려고 한다.<br><a id="more"></a></p><p>필자가 처음 이 회사에 입사했을 때는 직원 수 13명 정도에 아직 Series A 투자도 받지 못했던 신생 스타트업이었지만, 지금은 어느 덧 120억 정도의 Series B 투자도 받고 직원 수도 50명 정도 되는 규모의 회사가 되었다. 필자도 회사가 이렇게 성장하는 것을 직접 경험하는 것이 처음이었기에 재밌는 점도 있었지만 한편으로는 조직이 커짐에 따라 변해가는 사내 문화와 조직의 분위기를 보면서 규모가 작을 때에 대한 향수를 느끼기도 했었다.</p><p>어쨌든 필자는 이제 휴식과 재정비를 위해 오늘을 마지막으로 회사를 그만 두게 되었으니 입사 당시의 기억부터 2년이 지난 오늘까지의 기억을 되짚어 보며 한번 회고를 진행해보도록 하겠다.</p><h2 id="내가-만든-레거시-코드"><a href="#내가-만든-레거시-코드" class="headerlink" title="내가 만든 레거시 코드"></a>내가 만든 레거시 코드</h2><p>필자는 이 회사에 입사하기 전에 아는 분과 함께 하던 스타트업을 시원하게 말아먹고 2개월 정도 혼자서 토이 프로젝트로 이것저것 만들면서 놀고 있는 한량 개발자였다. 하루는 홍대에 있는 필자의 단골 카페<small>(지금은 없어진 홍대 디자이너스 라운지…)</small>에서 혼자 코딩을 하고 있었는데 왠 이상한 외국인 아저씨가 링크드인으로 면접 제안 메세지를 보낸 것이다.</p><p>그래서 몇 마디를 나눠보니 그 분이 지금 만들고 있는 서비스도 나름 재밌을 것 같았고, 회사의 분위기나 비전도 필자와 잘 맞을 것 같아서 그 다음 주에 바로 면접을 진행했고, 면접이 끝난 그 자리에서 바로 합격 통보를 받았다. 그 당시 주고 받았던 질답 중에 지금까지 기억나는 질답은 딱 이거 하나다.</p><blockquote><p><strong>CTO</strong>: 혹시 VueJS 하실 수 있으세요? 저희가 이런 거를 만들어 보려고 하는데…<small>(다른 서비스의 컴포넌트를 보여줌)</small><br><strong>필자</strong>: Vue는 거의 안 써보긴 했는데… 뭐 개인적으로 공부 하면서 하면 만들 수 있을 것 같네요.</p></blockquote><p>면접이 끝나고 나서 생각해보니 <code>이 사람들 도대체 뭘 보고 날 뽑은거지...?</code>라는 생각이 들 정도로 프론트엔드에 대한 깊은 질문이나 코드 테스트도 없었는데, 입사 첫 날에 바로 현재 상황을 파악할 수 있었다. 일단 필자가 이 회사의 첫번째 프론트엔드 개발자였다. CTO가 기존 Django로만 작성된 프로젝트를 운영하다가 프론트엔드 프레임워크의 필요성을 느끼고 React를 도입하려다가 한번 실패하고 차선책으로 Vue를 어떻게든 돌아가게만 적용해놓은 상황이었다.</p><p>하지만 당시 CTO는 백엔드 개발자였기 때문에 프론트엔드에 전문성을 가진 누군가가 이 상황을 타개해줬으면 했던 것이고 그래서 필자가 간택당한 것이다. 그래서 필자가 입사한 다음 했던 첫 작업이 바로 <code>gulp</code>와 <code>webpack</code>을 사용해서 프론트엔드 빌드 프로세스를 만들고, 번들링되어 나온 파일들을 Django와 연동시키는 그런 작업이었다. 하지만 당시 비즈니스 상황 상 프론트엔드 어플리케이션을 Django로부터 완전 분리해서 작성할 수가 없었기에 Django가 서버에서 자체 템플릿 엔진을 사용하여 한번 HTML을 렌더하고 클라이언트에서 Vue가 2차 렌더링을 진행하는 방식으로 적용할 수 밖에 없었다.</p><p>그리고 2019년 현재 구글에 <code>Django Vue</code>라고 검색해보면 Django 템플릿과 Vue를 동시에 사용할 수 있는 방법을 설명한 몇 개의 포스팅이 나오지만 필자가 이 작업을 진행했던 2017년 5월에는 그런 레퍼런스가 단 한개도 존재하지 않았기 때문에 모든 것을 필자 스스로 설계하고 아이디어를 짜내서 연동해야했다. 당시에 이 작업으로 포스팅을 작성했으면 좋았을 것 같은데 입사한 지 얼마 되지 않았을 때라 포스팅이고 나발이고 일단 전체 코드를 파악하는 것만 해도 정신이 없었다.</p><p>결국 이 어플리케이션은 현재 프론트엔드 챕터에게 <code>레거시</code>라고 불리며 필자를 포함한 그 누구도 건드리기 싫어하는 어플리케이션이 되었는데, 뭐 사실 그때 당시에는 그게 최선이긴 했기 때문에 당시 결정에 후회는 없다. 하지만 필자가 작성한 코드가 시간이 지나서 다른 개발자들에게 레거시라고 불리게 되는 경험은 처음이었기에 나름 흥미로웠다.</p><p>이 코드는 사실 그 당시 필자가 만들면서도 <code>이거 나중에 분명히 문제될 것 같은데...?</code>라고 생각할 정도로 일반적인 프론트엔드들이 이해하기 힘든 기형적인 구조였다. 문제가 많아서 일일히 나열하기는 힘들지만 대표적인 이슈는 바로 여러 개의 <code>Vue 인스턴스</code>가 존재한다는 것과 DJango를 할 줄 알아야 수정이 가능한 부분이 있다는 것, 그리고 기존 코드에서 bower 패키지를 사용하고 있었기 때문에 bower를 걷어내고 npm으로 완전히 갈아타는 것이 불가능하다는 것이었다. 물론 이 이슈는 현재진행형이다.</p><p>이런 것들이 하나하나 쌓여서 결국 기술 부채가 누적되는 것이기 때문에 언젠가 청산을 하긴 해야 했다. 그래서 필자는 퇴사 후 현 직장과 2개월 프리랜서 계약을 체결하고 이 레거시 어플리케이션에 붙어있는 프론트엔드 어플리케이션을 전부 새로 만든 프론트엔드 어플리케이션 프로젝트로 마이그레이션하는 작업을 진행하기로 하였다.<small>(내 똥은 내가 치운다! 라는 느낌이랄까)</small></p><h2 id="기술만능주의에서-조직을-보는-개발자로"><a href="#기술만능주의에서-조직을-보는-개발자로" class="headerlink" title="기술만능주의에서 조직을 보는 개발자로"></a>기술만능주의에서 조직을 보는 개발자로</h2><p>이 내용은 <a href="/2019/06/06/what-is-good-programmer/" title="좋은 프로그래머란 무엇일까?">좋은 프로그래머란 무엇일까?</a>라는 포스팅에서도 한번 언급한 적이 있었는데, 처음 필자가 이 회사에 입사했을 때 필자가 생각하는 좋은 개발자의 기준은 <code>요구사항을 빠르고 완벽하게 개발하는 개발자</code>였고 필자의 개발 스타일은 <code>빠르게는 만들지만 자잘한 버그가 많은 스타일</code>이었다. 그래서 필자는 당시 이 단점을 보완하기 위해 유닛 테스트나 실수를 줄일 수 있는 설계 패턴 등을 통해서 신뢰성이 떨어지는 필자 코드에 대한 방어선을 펼치는 방향으로 노력을 했었다.</p><p>하지만 필자의 첫 직장과 다르게 여기서는 CTO가 모든 의사결정을 하지 않고 프론트엔드 어플리케이션에 대한 의사결정은 프론트엔드 개발자가 하는 구조였다. 단순히 필자의 단점을 보완하는 것 뿐만 아니라 비즈니스에 유연하게 대응할 수 있는 설계와 인프라, 현재 어플리케이션이 가지고 있는 문제점의 분석 등 많은 것을 함께 해야했던 것이다. 또한 팀 외부와 소통하는 것 또한 필자가 프론트엔드 개발자로써 직접 해야했다.<small>(특히 마케팅팀과 SEO, 유저 행동 데이터 수집 등에 대해 많은 커뮤니케이션을 했었다)</small></p><p>이 과정에서 필자가 생각하고 있던 개발의 영역이 많이 확장되게 되었는데, 기존에는 <code>내가 어떻게 하면 더 개발을 잘할 수 있을까?</code>를 위주로 고민했다면 이 과정을 겪고 나서는 <code>이 어플리케이션이 어떻게 하면 더 발전할 수 있을까?</code>를 더 고민하게 되었다. 더 나아가서 지금은 어플리케이션 뿐만 아니라 <code>이 팀이 어떻게 하면 더 효율적으로 일할 수 있을까?</code>까지 고민하고 있는 상황이다.</p><h2 id="같은-팀이라는-것"><a href="#같은-팀이라는-것" class="headerlink" title="같은 팀이라는 것"></a>같은 팀이라는 것</h2><p>필자가 입사하고 얼마 되지 않았을 때 회사가 Series A 투자를 받게 되었는데, 그때 CEO가 했던 약속이 <code>우리 투자받으면 해외로 한번 워크샵가자!</code>였었다. 그래서 필자는 입사한지 거의 한달만에 베트남 다낭으로 워크샵을 떠나게 되었다.<small>(개꿀)</small></p><p>대략 3박 4일 정도였던 것 같은데 문제는 한국으로 귀국하기 바로 전날 밤에 터졌다. 필자가 워크샵을 오기 전에 개발했던 기능이 있었는데 이 기능이 Internet Explorer에서 아예 작동하지않고 있었던 것이다. 그 기능이 배포된 지는 대략 3주 정도 되었고, 유저들이 IE에서 해당 기능을 사용하지 못하자 데이터 플로우 차트가 이상하게 그려지기 시작했던 것이다.</p><p>당시 사내에 IE를 사용하는 사람이 단 한명도 없었기에 이 문제를 조기에 발견하지 못했다. 하지만 제일 큰 책임은 해당 기능을 개발하고 제대로 크로스 브라우징을 테스트하지않았던 필자에게 있었다. 그래서 필자는 그 이야기를 듣자마자 바로 맥북을 펴고 핫픽스를 하기 시작했는데 그때 시간은 이미 00시를 넘기고 있었다.</p><p>그때 들었던 감정은 음, 테스트를 제대로 하지 않았다는 자책감과 나의 부주의함으로 인해 회사에 피해를 끼쳤다는 미안함이었던 것 같다. 어쨌든 이걸 빨리 고쳐야하니 정신없이 분석하면서 원인을 찾게 되었는데, 제일 큰 문제는 바로 <code>Array.prototype.findIndex</code> 메소드를 babel이 제대로 트랜스파일링 해주지 않았던 것이었고 그 외 자잘한 이슈도 몇개 더 있었다.<small>(필자는 이 이후로 babel을 안 믿는다)</small></p><p>다행히 빠르게 버그 원인을 알아냈지만 진짜 문제는 베트남 인터넷이 너무 느려서 소스를 빌드하고 해당 기능의 작동을 확인하는 것도 오래 걸리고 문제가 발생한 부분이 서버와의 API 통신을 담당하는 모듈이라서 해당 모듈을 사용하는 핵심 기능을 전부 테스트해야 했었다. 게다가 그걸 고치는 과정에서 빌드 프로세스도 갑자기 맛이 가는 등 연쇄적으로 문제가 커져서 픽스 시간은 점점 늘어났다.</p><center><br>  <img src="/2019/08/17/leave-the-company/vietnam_commit.png" width="500"><br>  <small>추억돋는 그 날의 커밋들</small><br>  <br><br></center><p>결국 이런 저런 이슈들이 겹쳐서 최종 릴리즈는 오전 5시가 넘어서야 할 수 있었다. 이때 중요한 점은 모든 팀원들이 그때까지 필자와 함께 밤을 샜다는 것이다. 사실 이건 100% 프론트엔드 이슈였다. 당시 프론트엔드 개발자는 필자밖에 없었고 나머지는 전부 모바일 앱 개발자, 백엔드 개발자였기 때문에 다른 개발자 분들이 픽스를 도와줄 수 있는 것도 아니었다. 게다가 필자와 함께 밤을 새준 사람 중에는 UI/UX 디자이너도 있었다.</p><center><br>  <img src="/2019/08/17/leave-the-company/hotfix.png" width="500"><br>  <small>새벽 한시에도 옆을 함께 지켜준 팀원들</small><br>  <br><br></center><p>이때 필자는 팀원들한테 미안하면서도 굉장히 고마운 마음이 들었다. 당시 당황한 마음으로 버그 픽스하고 있는 필자에게 팀원들은 괜찮으니까 천천히 꼼꼼히 고치라면서 격려도 해주고 먹을 것도 가져다주고 도와줄 게 없는 지 물어봐주기도 했다. 앞으로도 다른 회사에서 또 이런 팀을 만나볼 수 있을까라는 생각이 들 정도로 정말 고마운 분들이었고 다들 각자의 길을 찾아나선 지금도 물론 꾸준히 연락을 주고 받으면서 잘 지내고 있다.<small>(어제는 퇴사 선물도 받았다.)</small></p><p>필자는 사실 개인주의적인 성향이 강한 사람이었는데 이런 경험들은 필자가 <code>팀의 발전</code>에 대해서 꾸준히 고민할 수 있게 만들어준 소중한 경험이 되었다.</p><h2 id="다른-사람을-도와주는-사람으로"><a href="#다른-사람을-도와주는-사람으로" class="headerlink" title="다른 사람을 도와주는 사람으로"></a>다른 사람을 도와주는 사람으로</h2><p>작년 여름 쯤에, 필자가 입사할 때부터 CX팀에서 일하던 분이 보직 변경을 통해 <code>PO(Product Owner)</code>로 오게된 일이 있었다. 물론 이 분의 전공은 이 쪽 분야가 아니기도 하고 프로덕트와 관련된 일을 해본 경험도 거의 없었기 때문에 신입과 다름 없는 상태였다.</p><p>그러다가 팀을 스쿼드 편제로 나누게 되면서 이 분과 필자는 같은 스쿼드에서 함께 일을 하게 되었는데, 처음 같이 일을 할때는 사실 별로 이 분에 대해서 신경을 안썼다. 뭐 알아서 잘하시겠지… 혹여나 못하더라도 나나 누군가가 커버할 수 있겠지 정도?</p><p>하지만 같이 일을 하게 되면서 그 전까지는 몰랐던 이 분의 새로운 모습들을 많이 보게 되었다. 비록 남들보다 경험은 적을지라도 굉장히 프로덕트를 만든다는 일에 열정적이었고, 또 질문도 굉장히 많이 하시는 편이었는데 질문의 질이 굉장히 좋았다. 그래서였는지 이 분이 필자에게 개발에 대한 질문을 할 때마다 필자도 점점 열의를 가지고 가르쳐드리게 되었는데, 이 분은 항상 그 점에 있어서 필자에게 고맙다는 이야기를 많이 해줬었다.</p><p>필자 또한 필자가 알고 있는 지식을 그 분에게 알려드리면서 실제로 그 분이 빠르게 성장하는 모습을 보고 나니 필자도 기분이 굉장히 좋았다. 내가 이미 알고 있는 별 것 아니라고 생각했던 지식이 다른 사람에게는 굉장한 도움이 될 수 있다는 생각을 이때 처음으로 하게 되었던 것 같다.</p><p>그리고 그 분의 스쿼드 운영 스타일은 개발자와 디자이너들이 모두 자유롭게 아이디어를 내고 본인이 그걸 취합하고 정리하면서 진행하는 <code>참여형</code>이었는데 그 분의 경험과 실력이 점점 쌓이면서 시너지 효과가 발생해서 팀의 생산성도 높아지고 팀의 사기와 분위기도 많이 좋았던 기억이 난다. 결국 필자가 그 분에게 개발에 대한 지식을 알려줬던 그 행동이 필자와 그 분뿐만 아니라 팀 전체에 영향을 주었던 것이다.</p><p>그런 과정을 겪으면서 필자는 <code>개인이 각자 잘하면 팀은 알아서 잘 굴러간다</code>와 같은 생각에 더 이상 동의하지 않게 되었다.</p><h2 id="아싸에서-나름-인싸로"><a href="#아싸에서-나름-인싸로" class="headerlink" title="아싸에서 나름 인싸로"></a>아싸에서 나름 인싸로</h2><p>필자는 원래 사람 만나는 것을 별로 좋아하는 편이 아니었다. 하지만 이 직장에서 많은 일을 겪으면서 뭔가 성격이 좀 변했다고 해야하나…? 갑자기 인싸 짓을 하고 다니기 시작했다.</p><p>처음 입사했을 때 필자와 며칠 차이로 입사했던 백엔드 개발자분이 계셨는데, 이 분과는 입사하고 거의 한달 정도는 업무 이야기 외에 별로 말을 안할 정도로 사람한테 관심이 없었다.<small>(이 분도 낯가리는 성격이라 둘 다 말을 잘 안걸었다)</small></p><p>근데 지금은 어떤 분이 새로 입사하면 먼저 말도 걸기도 하고 다른 팀과 같이 술을 마시거나 게임도 하러가는 등 인싸같은 행동을 많이 하게 되었는데, 지금 생각해보면 아마도 작년의 번아웃이 뭔가 계기가 되었던 것 같다.</p><p>필자는 2018년 여름 쯤에 한번 번아웃을 크게 겪은 적이 있었는데, 그 전까지 필자는 1년 365일 매일 코딩만 하는 사람이었다. 평일에는 밤 11시까지 야근하고 집에 와서 새벽 2~3시까지 토이 프로젝트를 하고, 주말에는 친구들과 또 다른 토이 프로젝트를 진행하고는 했던 그런 시기였다. 그렇게 일주일 내내 하루에 무조건 코딩을 7시간 씩은 했던 것 같다.</p><p>필자는 이 생활을 군대 전역 후 대학교에 복학했던 2014년부터 계속 해왔으니 번아웃이 왔던 2018년에는 대략 5년 정도 그렇게 살아왔던 셈이다. 그러다가 갑자기 번아웃이 찾아왔는데, 그때는 그냥 코딩 자체에 흥미가 떨어져서 아무것도 하기 싫었다.</p><center><br>  <img src="/2019/08/17/leave-the-company/contributions.png" width="500"><br>  <small>듬성듬성한 필자의 2018년 깃허브 잔디</small><br>  <br><br></center><p>지금 생각해봐도 굉장히 당혹스러운 감정이었다. 코딩이 그렇게 즐겁고 재밌어서 5년 내내 매일 7~8시간씩 코딩을 했던 사람이었는데 하루 아침에 갑자기 코딩이 싫어지게 되는 기분이란 꽤나 이상한 감정이다. <code>내가 왜 이렇게까지 아둥바둥해야하지?</code>라는 회의감도 들었고 <code>이러다가 뒤쳐지는 거 아니야?</code>라는 불안함도 들었다. <code>개발이 나랑 맞지 않나?</code>라는 생각도 들었던 것 같다.</p><p>이 당시 필자가 잘못 했던 것은 바로 일하기 싫은 티를 너무 팍팍 내고 다닌 것이었다. 이 당시 필자의 속마음은 <code>아 너무 재미없고 힘들다. 회사 그만 둘까...?</code>였기 때문에 팀원들과도 거리를 두고 업무 태도도 불량했다. 낮에는 업무를 설렁설렁하고 혼자 야근하면서 일을 끝내는 경우가 많았기 때문에 일이 밀리거나 하지는 않았지만 팀원들과 커뮤니케이션을 많이 못했었다.</p><p>나중에 들어보니 당시 필자와 함께 오래 일했던 팀원들은 <code>얘 갑자기 뭔가 맛이 갔는데...?</code>라는 생각을 하고 필자에게 먼저 다가와 주었지만, 필자를 잘 몰랐던 다른 팀 분들은 업무를 제대로 하지 않는다고 생각하기도 했다고 한다. 그래서 당시 팀 리더가 필자에게 티타임을 신청하고 잠깐 이야기를 나눴었는데, 그때 그 분이 했던 말이 아직도 기억에 남는다.</p><blockquote><p>에반이 힘든 건 에반 개인의 문제가 아니라 팀의 문제에요. 팀이 도와줄 수 있는 건 최대한 도와줄게요.<br>대신 뭐 때문에 힘든지는 이야기 해줘야해요.</p></blockquote><p>이 이야기를 듣고 솔직히 감동까지는 아니였지만 <code>맞네. 우리는 팀이었지.</code>라는 생각이 새삼스럽게 다시 들었었다. 그래서 이때부터 필자는 주변에 계신 분들께 필자의 현재 상황을 설명하고 많은 조언을 들을 수 있었는데, 주변에 계신 분들이 전부 똑같이 이야기한 것이 바로 <code>좀 쉬어라</code>였다.</p><p>매일 야근하고 주말에도 코딩하고 취미도 없고 연애도 하지 않는 생활이 필자를 지치게 만들었다는 것이다. 이런 피로감은 어느 순간 슬금슬금 생기다가 어떤 임계점을 넘어가는 순간 빵! 터지게 되는 경우가 많고, 지금이 바로 그 타이밍이라고 했다. 그래서 다들 코딩말고 좀 다른 것도 해보면서 쉬라는 조언을 많이 해주셨었다.</p><center><br>  <img src="/2019/08/17/leave-the-company/hwan.jpeg" width="400"><br>  <small>평소에도 이런 이야기를 주변에서 많이들 해주셨다</small><br>  <br><br></center><p>그래서 이때 필자는 거의 매일 술먹고 당구치고 노래방에 가는 등 나름 필자 기준에서는 스트레스를 풀기 위한 방탕한 생활을 했었는데, 이때 개발팀 외에 다른 팀에 있는 사람들과 많이 친해질 수 있었다. 개발팀끼리 놀 때는 거의 프로그래밍이나 조직문화같이 어느 정도 일과 관련된 이야기를 많이 나누었는데, 다른 팀 사람들과 술을 마시게 되니 새로운 이야기들을 들어볼 수 있어서 좋았다.</p><p>그렇게 다른 팀들의 이야기를 들었던 경험들은 회사에서 일을 할 때도 필자가 다른 팀의 상황을 조금 더 이해하고 배려할 수 있는 기반이 될 수 있었다.</p><h2 id="능력있는-팀원들이-주는-자극"><a href="#능력있는-팀원들이-주는-자극" class="headerlink" title="능력있는 팀원들이 주는 자극"></a>능력있는 팀원들이 주는 자극</h2><p>이것 또한 주관적인 평가겠지만 필자가 생각했을 때 필자가 지난 2년간 이 직장에서 함께 일했던 팀원들은 대부분 자기주도적인 업무를 하며 능동적인 의사결정과 전문분야에 대한 스킬도 좋았던 것 같다. 물론 개발자만 이야기하는 것이 아니라 다른 팀에 있는 분들도 포함하는 이야기이다.</p><p>물론 가장 큰 자극은 같은 팀에서 일하는 개발자들로부터 많이 받게 되었는데, 가장 많은 자극을 받았던 팀원은 아무래도 같은 프론트엔드 개발자가 아닐까 싶다. 이 분은 바로 어제까지 필자와 함께 일했던 시니어 프론트엔드 개발자이다. 이 분은 사실 개발에 엄청난 열정을 가지고 집에서도 공부하고 그런 스타일은 아니다. 하지만 아무렇지 않게 툭툭 던지는 아이디어가 문제를 바로 해결할 수 있을 정도로 신박한 것들이 많았다.</p><p>물론 이 아이디어들은 자바스크립트에 대한 깊은 이해가 없이는 나올 수 없는 것들이었고, 이 분이 입사한지 이틀만에 필자가 일주일 동안 고민했던 문제를 단박에 풀어버리는 것을 보고 <code>역시 세상엔 굇수가 많군</code>이라는 생각이 다시 들었던 것 같다.</p><p>외부 SDK 스크립트 로드가 끝나는 시점을 알 수가 없어서 어플리케이션 초기화 시 해당 SDK가 담기는 전역 변수가 <code>null</code>인 일종의 타이밍 이슈였는데, 필자는 이걸 <code>setTimeout</code>으로 간신히 작동하게만 만들어 놓고 더 이상 아이디어가 없어서 방치하고 있던 상황이었다. 근데 이 분이 이 문제를 보자마자 <code>isLoaded</code> 변수를 <code>Promise</code>로 선언하고 외부 SDK 로드가 끝나면 해당 프로미스를 <code>resolve</code>하는 방식으로 해결했다.<small>(지금 생각해도 변태같지만 신박한 방법이다.)</small></p><p>그리고 필자가 Express로 작성한 프론트엔드 렌더 서버에 있던 메모리 릭도 이 분이 해결했었는데, 이 문제는 필자가 몇번 개선은 해서 당장은 문제가 없었지만 누수 자체는 그래도 조금씩 발생하고 있었다. 그런 와중에 이 시니어분이 프론트엔드에서 사용하고 있는 외부 패키지들을 최신화했는데 갑자기 메모리 릭이 가속화된 상황이었다. 하지만 필자는 이 문제의 근본적인 원인이 무엇인지 파악하지 못하고 있는 상태였다. 그래서 이 분이 이 이슈를 가져가서 고치기로 했는데, 예상보다 빠른 시간 안에 문제를 해결해서 꽤나 놀랬던 기억이 난다.</p><center><br>  <img src="/2019/08/17/leave-the-company/leak_fix.png" width="500"><br>  <small>드라마틱한 트랜잭션 타임의 변화</small><br>  <br><br></center><p>클라이언트에서만 사용할 수 있게 설계된 일부 외부 패키지가 서버사이드 렌더링 타이밍 때 사용되면서 발생하는 누수였는데, 필자는 이런 상황이 발생할 수 있을 것이라는 경우의 수조차 생각하지 못했었다.</p><p>그 외에도 같이 오래 일했던 백엔드 개발자 분에게도 설계나 비즈니스를 보는 관점 등에 대해서 좋은 영향을 많이 받았고, 야근을 좋아하는 모바일 개발자에게는 프로덕트에 대한 열정을 배웠다. 솔직히 팀원들에게 배운 것들이 너무 많아서 이런 것들을 하나하나 다 나열하자면 한도 끝도 없으니 이 정도만 이야기하도록 하겠다.<small>(아마 본인들은 이 글만 보면 누군지 다 알듯)</small></p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>지난 2년 동안 이 팀에서 정말 많은 일을 함께 겪었던 팀원들에게 감사의 말을 전하고 싶다.</p><p>여러분과 함께 일했던 2년은, 경력과 직종에 상관없이 개발자로써 또는 한명의 인간으로써 굉장히 많은 것을 배울 수 있었던 기회였다. 개발자가 아닌 분들에게서는 개발을 넘어선 다른 분야의 지식도 함께 배울 수 있었다. 필자에게 여러분은 어떤 때에는 프로페셔널한 팀원이었고 어떤 때에는 같이 일하는 친구같은 느낌이었다. 비록 회사를 떠나며 함께 일할 수 없게 되었지만 다른 곳에서 또 만날 수 있게 되기를 바란다.</p><p>2년 동안 좋은 추억을 만들어준 여러분께 감사하다는 말을 전하며 이 글을 마친다.</p>]]></content:encoded>
      
      <comments>https://evan-moon.github.io/2019/08/17/leave-the-company/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
